<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ASM 代码注入技术]]></title>
    <url>%2Fblog%2F2020%2F07%2F24%2FASM%20%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[字节码增强技术ASM 字节码层面的字节码增强库，需要手动操作字节码指令。 对于需要手动操纵字节码的需求，可以使用ASM，它可以直接生产 .class字节码文件，也可以在类被加载入JVM之前动态修改类行为。PS：载入之后再通过asm修改类行为会导致报错，但是可以通过JVMTI来重载。 ASM的应用场景有AOP（Cglib就是基于ASM）、热部署、修改其他jar包中的类等。 ASM 修改案例 12345678910111213141516171819202122232425ClassReader classReader = null;String fileName = "/xxx/Algr/assets/Base.class";try &#123; InputStream is = new FileInputStream(fileName); classReader = new ClassReader(is);&#125; catch (IOException e) &#123; e.printStackTrace(); return;&#125;ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS);//处理ClassVisitor classVisitor = new MyClassVisitor(classWriter);classReader.accept(classVisitor, ClassReader.SKIP_DEBUG);byte[] data = classWriter.toByteArray();//输出File f = new File(fileName);FileOutputStream fout = null;try &#123; fout = new FileOutputStream(f); fout.write(data); fout.close();&#125; catch (Exception e) &#123; e.printStackTrace();&#125;System.out.println("now generator cc success!!!!!"); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import jdk.internal.org.objectweb.asm.ClassVisitor;import jdk.internal.org.objectweb.asm.MethodVisitor;import jdk.internal.org.objectweb.asm.Opcodes;public class MyClassVisitor extends ClassVisitor implements Opcodes &#123; public MyClassVisitor(ClassVisitor cv) &#123; super(ASM5, cv); &#125; @Override public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) &#123; cv.visit(version, access, name, signature, superName, interfaces); &#125; @Override public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) &#123; MethodVisitor mv = cv.visitMethod(access, name, desc, signature, exceptions); //Base类中有两个方法：无参构造以及process方法，这里不增强构造方法 if (!name.equals("&lt;init&gt;") &amp;&amp; mv != null) &#123; mv = new MyMethodVisitor(mv); &#125; return mv; &#125; class MyMethodVisitor extends MethodVisitor implements Opcodes &#123; public MyMethodVisitor(MethodVisitor mv) &#123; super(Opcodes.ASM5, mv); &#125; @Override public void visitCode() &#123; super.visitCode(); // 这里可以通过在IDEA 上安装ASM ByteCode Viewer 插件，将java语句翻译为ASM语句。然后直接copy过来 mv.visitFieldInsn(GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;"); mv.visitLdcInsn("start"); mv.visitMethodInsn(INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/String;)V", false); &#125; @Override public void visitInsn(int opcode) &#123; if ((opcode &gt;= Opcodes.IRETURN &amp;&amp; opcode &lt;= Opcodes.RETURN) || opcode == Opcodes.ATHROW) &#123; //方法在返回之前，打印"end" mv.visitFieldInsn(GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;"); mv.visitLdcInsn("end"); mv.visitMethodInsn(INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/String;)V", false); &#125; mv.visitInsn(opcode); &#125; &#125;&#125; Javassist 源码层面操作字节码，相比asm更加简单。 首先下载jar包，http://www.javassist.org/ 12345678910111213public static void test() throws NotFoundException, CannotCompileException, IOException, IllegalAccessException, InstantiationException &#123;// String fileName = "/xxx/IdeaProjects/Algr/assets/Base"; String fileName = "asm.Base"; ClassPool cp = ClassPool.getDefault(); CtClass cc = cp.get(fileName); CtMethod m = cc.getDeclaredMethod("process"); m.insertBefore("&#123;System.out.println(\"start\");&#125;"); m.insertAfter("&#123;System.out.println(\"end\");&#125;"); Class c = cc.toClass(); cc.writeFile("out/production/Algr"); Base h = (Base)c.newInstance(); h.process(); &#125; 热更新、动态注入技术 运行一个java程序 12345678910111213141516171819202122232425262728// asm/Base.java 文件package asm;public class Base &#123; public void process()&#123; System.out.println("process"); &#125;&#125;// Main.java 文件public class Main &#123; public static void main(String[] args) &#123; String name = ManagementFactory.getRuntimeMXBean().getName(); String s = name.split("@")[0]; //打印当前Pid System.out.println("pid:"+s); Base base = new Base(); while (true) &#123; try &#123; Thread.sleep(5000L); &#125; catch (Exception e) &#123; break; &#125; // 没5s调用一次，当base类被动态注入修改之后，输出内容发生变化 base.process(); &#125; &#125;&#125; 创建一个Agent的jar包，用于动态修改Base类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// Baes.java 类package asm;public class Base &#123; public void process()&#123; System.out.println("process"); &#125;&#125;// TestAgent.java 类package asm;import java.lang.instrument.Instrumentation;public class TestAgent &#123; public static void agentmain(String args, Instrumentation inst) &#123; //指定我们自己定义的Transformer，在其中利用Javassist做字节码替换 inst.addTransformer(new TestTransformer(), true); try &#123; //重定义类并载入新的字节码 inst.retransformClasses(Base.class); System.out.println("Agent Load Done."); &#125; catch (Exception e) &#123; System.out.println("agent load failed!"); &#125; &#125;&#125;// TestTransformer.java 类package asm;import javassist.ClassPool;import javassist.CtClass;import javassist.CtMethod;import java.lang.instrument.ClassFileTransformer;import java.security.ProtectionDomain;public class TestTransformer implements ClassFileTransformer &#123; @Override public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) &#123; System.out.println("Transforming " + className); try &#123; ClassPool cp = ClassPool.getDefault(); CtClass cc = cp.get("asm.Base"); CtMethod m = cc.getDeclaredMethod("process"); m.insertBefore("&#123; System.out.println(\"start\"); &#125;"); m.insertAfter("&#123; System.out.println(\"end\"); &#125;"); return cc.toBytecode(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 打jar包 这里生成jar包使用IDEA工具，File-&gt;Project settings -&gt; Artifacts -&gt; + -&gt; Jar -&gt; Create JAR from Modules -&gt; output Layout -&gt; + -&gt; 添加依赖的第三方jar -&gt; OK 修改Manifest.MF 1234567Manifest-Version: 1.0Agent-Class: asm.TestAgent // 这里不是Main-ClassCreated-By: lplCan-Redefine-Classes: trueCan-Retransform-Classes: trueBoot-Class-Path: javassist.jarPermissions: all-permissions 将Agent 关联到 第一步运行的java进程，通过AgentTest修改内存中的Base类，改变对象base.process()的执行逻辑 1234567public class Main &#123; public static void main(String[] args) throws AttachNotSupportedException, IOException, AgentLoadException, AgentInitializationException &#123; // 传入目标 JVM pid VirtualMachine vm = VirtualMachine.attach("92074"); vm.loadAgent("/Users/lipeilong/IdeaProjects/AgentTest/out/artifacts/AgentTest_jar/AgentTest.jar"); &#125;&#125; 参考文章JVMTI(JVM tools interface) https://cloud.tencent.com/developer/article/1478720 ASM 注入 https://www.jianshu.com/p/905be2a9a700 ASM 官网 https://asm.ow2.io/developer-guide.html 字节码注入到class的运行时动态重载 https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html 字节码指令 http://gityuan.com/2015/10/24/jvm-bytecode-grammar/ ASM 编写辅助插件 https://plugins.jetbrains.com/plugin/5918-asm-bytecode-outline/versions]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>asm</tag>
        <tag>java</tag>
        <tag>jvmti</tag>
        <tag>javassit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 性能监控-启动时长]]></title>
    <url>%2Fblog%2F2020%2F07%2F09%2FAndroid%20%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7-%E5%90%AF%E5%8A%A8%E6%97%B6%E9%95%BF%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[#####]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>apm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 性能监控-内存]]></title>
    <url>%2Fblog%2F2020%2F06%2F23%2FAndroid%20%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7-%E5%86%85%E5%AD%98%2F</url>
    <content type="text"><![CDATA[四种内存指标区别 VSS （Virtual Set Size） 虚拟耗用内存（包含共享库占用的内存） VSS表示一个进程可访问的全部内存地址空间的大小。这个大小包括了进程已经申请但尚未使用的内存空间。在实际中很少用这种方式来表示进程占用内存的情况，用它来表示单个进程的内存使用情况是不准确的。 RSS （Resident Set Size） 实际使用物理内存（包含共享库即so文件占用的内存） 表示一个进程在RAM中实际使用的空间地址大小，包括了全部共享库占用的内存，这种表示进程占用内存的情况也是不准确的。 PSS （Proportional Set Size） 实际使用的物理内存（比例分配共享库占用的内存） 表示一个进程在RAM中实际使用的空间地址大小，它按比例包含了共享库占用的内存。假如有3个进程使用同一个共享库，那么每个进程的PSS就包括了1/3大小的共享库内存。这种方式表示进程的内存使用情况较准确，但当只有一个进程使用共享库时，其情况和RSS一模一样。 USS （Unique Set Size） 进程独自占用的物理内存（不包含共享库占用的内存） USS：表示一个进程本身占用的内存空间大小，不包含其它任何成分，这是表示进程内存大小的最好方式！可以看到:VSS&gt;=RSS&gt;=PSS&gt;=USS 采集PSS方法 使用Debug类采集PSS 1234567private MemoryInfo getMemoryInfo() &#123; // 注意：这里是耗时和耗CPU的操作，一定要谨慎调用 Debug.MemoryInfo info = new Debug.MemoryInfo(); Debug.getMemoryInfo(info); // 这里采集了总的Pss、dalvik Pss、native Pss、other Pss； return new MemoryInfo(ProcessUtils.getCurrentProcessName(), info.getTotalPss(), info.dalvikPss, info.nativePss, info.otherPss);&#125; Android Studio Profiler 工具 Memory 模块直接查看占用内存 top命令查看内存信息 12# 按照实际使用内存排序，取前20个进程，显示一次; 参数解释见参考文章 内存优化下adb shell top -m 20 -n 1 -s rss ## 命令行查看内存方法 dumpsys命令 1234#查看内存adb shell dumpsys meminfo &lt;package_name&gt;# 查找进程adb shell top | grep app_name top命令查看内存信息 12# 按照实际使用内存排序，取前20个进程，显示一次; 参数解释见参考文章 内存优化下adb shell top -m 20 -n 1 -s rss Android Studio Profiler 工具 Memory 模块直接查看占用内存 LeakInspector，采集dump 内存信息保存hprof文件，上传服务器使用mat工具分析 LeakCanary，也是基于hprof文件分析泄漏 MAT 用来分析hprof文件的工具 JHat 内置JDK中用于分析hprof的工具，可以生成web，适合多人协作。 GC日志分析(Dalvik、ART)；PS 内存优化中有详细介绍 chrome devtool 可以用来分析h5 Android Studio的Debugger 可以查看线程状态。 参考文章 https://blog.csdn.net/bigconvience/article/details/35553983 https://juejin.im/post/5e72b2d151882549236f9cb8 (内存优化上) https://juejin.im/post/5e780257f265da575209652c (内存优化下) https://axiu.me/coding/dump-android-memory-info/ https://www.jianshu.com/p/06aa6702093c (共享库) https://blog.csdn.net/MRYZJ/article/details/100890648 (meminfo 名词解释)]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>memory</tag>
        <tag>apm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 性能监控-网络]]></title>
    <url>%2Fblog%2F2020%2F06%2F23%2FAndroid%20%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7-%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[网络性能监控的指标 采集DNS解析域名花费时间 采集URL 采集开始时间 采集request数据长度 采集连接时间 采集response数据长度 采集statusCode 采集读取数据时间 采集整个连接的时间 数据采集方式 静态代理方式实现AOP 1234567891011121314151617181920212223242526/** * @author ArgusAPM Team 通过重写父类中的方法，拦截消息 */public class AopHttpURLConnection extends HttpURLConnection implements IStreamCompleteListener &#123; ...... @Override public Object getContent() throws IOException &#123; intAndGetMyData(); Object obj; try &#123; obj = this.myConnection.getContent(); &#125; catch (IOException e) &#123; // TODO throw e; &#125; // 拦截消息长度，保存 int len = this.myConnection.getContentLength(); if (len &gt;= 0) &#123; NetInfo data = intAndGetMyData(); data.setReceivedBytes(len); recordData(data); &#125; return obj; &#125;......&#125; 动态代理实现 使用ASM、Jaspect等 在编译时插桩 参考文章 https://www.jianshu.com/p/007bd6e1ba1b AOP 解释]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>apm</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 性能监控-ANR]]></title>
    <url>%2Fblog%2F2020%2F06%2F23%2FAndroid%20%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7-ANR%2F</url>
    <content type="text"><![CDATA[ANR(application not response) 监控的两种方法1、360采用的方式，通过监听/data/anr目录下面的anr文件来判断是否发生anr 其一通过文件观察器FileObserver来监听anr目录 12345678910111213141516171819202122232425262728293031public class AnrFileTask extends AnrTask &#123; public static final String SUB_TAG = "AnrFileTask"; FileObserver fileObserver = new FileObserver(ANR_DIR, FileObserver.CLOSE_WRITE) &#123; @Override public void onEvent(int event, String simplePath) &#123; if (TextUtils.isEmpty(simplePath)) &#123; return; &#125; String path = ANR_DIR + simplePath; if (!path.contains("trace")) &#123; if (Env.DEBUG) &#123; LogX.d(Env.TAG, SUB_TAG, path + " is not anr file"); &#125; return; &#125; handle(path); &#125; &#125;; @Override public void start() &#123; super.start(); fileObserver.startWatching(); &#125; @Override public void stop() &#123; super.stop(); fileObserver.stopWatching(); &#125;&#125; 通过Looper 循环采样监听anr目录 12345678910111213141516171819202122232425262728293031323334353637383940public class AnrLoopTask extends AnrTask &#123; ...... private Runnable runnable = new Runnable() &#123; @Override public void run() &#123; if (!isCanWork()) &#123; return; &#125; if (CommonUtils.isWiFiConnected(mContext)) &#123; if (Env.DEBUG) &#123; LogX.d(Env.TAG, SUB_TAG, "anr start obtain"); &#125; readAnrFiles(); &#125; AsyncThreadTask.getInstance().executeDelayed(runnable, 30*1000); &#125; &#125;; private void readAnrFiles() &#123; File anrDirF = new File(ANR_DIR); if (anrDirF.exists() &amp;&amp; anrDirF.isDirectory()) &#123; File[] anrFiles = anrDirF.listFiles(); if (anrFiles != null &amp;&amp; anrFiles.length &gt; 0) &#123; for (File f : anrFiles) &#123; String fileName = f.getName(); if (fileName.contains("trace") &amp;&amp; (System.currentTimeMillis() - f.lastModified() &lt; TaskConfig.ANR_VALID_TIME) &amp;&amp; (f.length() &lt;= TaskConfig.MAX_READ_FILE_SIZE) &amp;&amp; parser != null) &#123; handle(f.getPath()); &#125; &#125; &#125; &#125; &#125; @Override public void start() &#123; super.start(); AsyncThreadTask.executeDelayed(runnable, (int) (Math.round(Math.random() * 1000))); &#125;&#125; 解析、上传anr文件 源码参考 https://github.com/Qihoo360/ArgusAPM 2、微信matrix 的方案，通过监控帧回调判断是否发生ANR，然后采集信息上报 判断是否发生anr 12345678910111213141516171819202122232425262728@Override public void onAlive() &#123; super.onAlive(); if (isAnrTraceEnable) &#123; UIThreadMonitor.getMonitor().addObserver(this); this.anrHandler = new Handler(MatrixHandlerThread.getDefaultHandler().getLooper()); &#125; &#125; @Override public void dispatchBegin(long beginMs, long cpuBeginMs, long token) &#123; super.dispatchBegin(beginMs, cpuBeginMs, token); anrTask = new AnrHandleTask(AppMethodBeat.getInstance().maskIndex("AnrTracer#dispatchBegin"), token); // 在帧开始的时候，抛一个延时5s的任务给handle。如果5s内没有被清除，执行anr任务 anrHandler.postDelayed(anrTask, Constants.DEFAULT_ANR - (SystemClock.uptimeMillis() - token)); &#125; @Override public void dispatchEnd(long beginMs, long cpuBeginMs, long endMs, long cpuEndMs, long token, boolean isBelongFrame) &#123; super.dispatchEnd(beginMs, cpuBeginMs, endMs, cpuEndMs, token, isBelongFrame); if (null != anrTask) &#123; // 如果5s内本帧执行结束，清除回调。 anrTask.getBeginRecord().release(); anrHandler.removeCallbacks(anrTask); &#125; &#125; anr任务 123456789101112131415161718192021222324252627282930@Override public void run() &#123; long curTime = SystemClock.uptimeMillis(); boolean isForeground = isForeground(); // process 采集进程信息 int[] processStat = Utils.getProcessPriority(Process.myPid()); long[] data = AppMethodBeat.getInstance().copyData(beginRecord); beginRecord.release(); String scene = AppMethodBeat.getVisibleScene(); // memory 采集内存信息 long[] memoryInfo = dumpMemory(); // Thread state，采集线程信息 Thread.State status = Looper.getMainLooper().getThread().getState(); StackTraceElement[] stackTrace = Looper.getMainLooper().getThread().getStackTrace(); String dumpStack = Utils.getStack(stackTrace, "|*\t\t", 12); // frame 采集帧耗时信息(input 输入事件、animation 动画、traversal 绘制) UIThreadMonitor monitor = UIThreadMonitor.getMonitor(); long inputCost = monitor.getQueueCost(UIThreadMonitor.CALLBACK_INPUT, token); long animationCost = monitor.getQueueCost(UIThreadMonitor.CALLBACK_ANIMATION, token); long traversalCost = monitor.getQueueCost(UIThreadMonitor.CALLBACK_TRAVERSAL, token); // 方法调用栈，需要用asm技术给每个方法插桩，记录每个方法的调用。提供给这里使用。 // trace ...... // report ...... &#125; matrx 源码 https://github.com/zubao/matrix 参考文章 https://www.cnblogs.com/lanrenxinxin/p/5536969.html FileObserver]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>apm</tag>
        <tag>ANR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 性能监控-栈采样]]></title>
    <url>%2Fblog%2F2020%2F06%2F20%2FAndroid%20%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7-%20%E6%A0%88%E4%BF%A1%E6%81%AF%E9%87%87%E6%A0%B7%2F</url>
    <content type="text"><![CDATA[栈采样 从当前线程中获取栈信息 12345678910111213141516protected void doSample() &#123; StringBuilder stringBuilder = new StringBuilder(); // 从线程中获取栈信息 for (StackTraceElement stackTraceElement : mCurrentThread.getStackTrace()) &#123; stringBuilder .append(stackTraceElement.toString()) .append(BlockInfo.SEPARATOR); &#125; synchronized (sStackMap) &#123; if (sStackMap.size() == mMaxEntryCount &amp;&amp; mMaxEntryCount &gt; 0) &#123; sStackMap.remove(sStackMap.keySet().iterator().next()); &#125; sStackMap.put(System.currentTimeMillis(), stringBuilder.toString()); &#125; &#125; 从异常中获取 123456789101112131415161718192021public static String getStack() &#123; StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); // 从异常中获取 new Throwable().printStackTrace(pw); String stacks = sw.toString(); if (!TextUtils.isEmpty(stacks)) &#123; String[] lines = stacks.split("\n\tat"); StringBuilder sb = new StringBuilder(); final int start = 4; final int end = Math.min(start + 10, lines.length); // 前4行没有意义，都是aop带来的额外开销，最多只取10行 for (int i = start; i &lt; end; i++) &#123; sb.append(lines[i]).append("\n\tat"); &#125; return sb.toString(); &#125; return ""; &#125;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>apm</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 性能监控-FPS监控]]></title>
    <url>%2Fblog%2F2020%2F06%2F20%2FAndroid%20%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7-FPS%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[帧率监控 的几种方法 Looper 采用监听Looper中消费Message前后日志的方式，来判断是否有丢帧。 123456789101112131415161718192021222324252627282930313233// Looper.java public void setMessageLogging(@Nullable Printer printer) &#123; mLogging = printer;&#125;public static void loop() &#123; final Looper me = myLooper(); ....... for (;;) &#123; ...... // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println("&gt;&gt;&gt;&gt;&gt; Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what); &#125; ...... try &#123; msg.target.dispatchMessage(msg); dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0; &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; ....... if (logging != null) &#123; logging.println("&lt;&lt;&lt;&lt;&lt; Finished to " + msg.target + " " + msg.callback); &#125; ...... &#125; &#125; 1234567891011121314151617181920212223242526class LooperPrinter implements Printer &#123; public Printer origin; LooperPrinter(Printer printer) &#123; this.origin = printer; &#125; // 劫持Looper的日志 @Override public void println(String x) &#123; ...... if (!mPrintingStarted) &#123; ...... // 开始采样(CPU、栈) startDump(); &#125; else &#123; ....... // 判断本次事件执行时间是否超过阈值(3s)，超过就算堵塞 if (isBlock(endTime)) &#123; notifyBlockEvent(endTime); &#125; // 结束采样 stopDump(); &#125; &#125; &#125; 源码连接：https://github.com/markzhai/AndroidPerformanceMonitor 1、检测handle执行是否超过阈值3s 2、超过阈值就将采样的CPU、栈信息上传。 Choreographer 通过Chorographer.FrameCallback 来实现 12345678910111213141516171819202122232425262728293031323334353637383940public class FpsTask extends BaseTask implements Choreographer.FrameCallback &#123; ...... //定时任务 private Runnable runnable = new Runnable() &#123; @Override public void run() &#123; ...... calculateFPS(); mCurrentCount++; //实现分段采集 ...... &#125; &#125;; // 在异步线程，根据帧数和时间计算帧率 private void calculateFPS() &#123; ...... &#125; @Override public void start() &#123; super.start(); // 在异步线程runnable中采集栈信息。 ...... // 设置回调，监听帧回调 Choreographer.getInstance().postFrameCallback(this); &#125; @Override public void doFrame(long frameTimeNanos) &#123; // 记录帧数和时间 mFpsCount++; mFrameTimeNanos = frameTimeNanos; if (isCanWork()) &#123; //注册下一帧回调 Choreographer.getInstance().postFrameCallback(this); &#125; else &#123; mCurrentCount = 0; &#125; &#125; 这个是360的方案 源码： https://github.com/Qihoo360/ArgusAPM 1、记录帧数，和最近一帧的时间 2、采样的时候，使用上次采样的时间和最近一帧的时间，计算总是时间。帧率 = 帧数 * 1000/ 总时间； 3、如果帧率小于阈值，上报 Looper 和Choreographer 混合使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class LooperMonitor implements MessageQueue.IdleHandler &#123; private static final LooperMonitor mainMonitor = new LooperMonitor(); // 空闲队列回调，当MessageQueue中没有Message需要处理的时候执行。 @Override public boolean queueIdle() &#123; if (SystemClock.uptimeMillis() - lastCheckPrinterTime &gt;= CHECK_TIME) &#123; // 重置Printer，避免Printer被其他地方覆盖 resetPrinter(); lastCheckPrinterTime = SystemClock.uptimeMillis(); &#125; // 返回true，表示执行完之后不从空闲队列移出。 return true; &#125; private synchronized void resetPrinter() &#123; ...... looper.setMessageLogging(printer = new LooperPrinter(originPrinter)); ...... &#125; // 将当前类加入空闲队列中 private synchronized void addIdleHandler(Looper looper) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; looper.getQueue().addIdleHandler(this); &#125; else &#123; try &#123; MessageQueue queue = ReflectUtils.get(looper.getClass(), "mQueue", looper); queue.addIdleHandler(this); &#125; catch (Exception e) &#123; Log.e(TAG, "[removeIdleHandler] %s", e); &#125; &#125; &#125; class LooperPrinter implements Printer &#123; ...... @Override public void println(String x) &#123; ...... if (isValid) &#123; // 通过字符串判断Message执行开始、结束 dispatch(x.charAt(0) == '&gt;', x); &#125; &#125; &#125; private void dispatch(boolean isBegin, String log) &#123; ...... &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180public class UIThreadMonitor implements BeatLifecycle, Runnable &#123; ...... public void init(TraceConfig config) &#123; if (Thread.currentThread() != Looper.getMainLooper().getThread()) &#123; throw new AssertionError("must be init in main thread!"); &#125; choreographer = Choreographer.getInstance(); callbackQueueLock = reflectObject(choreographer, "mLock"); // 获取doCallback 中的callbackQueues callbackQueues = reflectObject(choreographer, "mCallbackQueues"); // 获取input、animation、traversal 方法 addInputQueue = reflectChoreographerMethod(callbackQueues[CALLBACK_INPUT], ADD_CALLBACK, long.class, Object.class, Object.class); addAnimationQueue = reflectChoreographerMethod(callbackQueues[CALLBACK_ANIMATION], ADD_CALLBACK, long.class, Object.class, Object.class); addTraversalQueue = reflectChoreographerMethod(callbackQueues[CALLBACK_TRAVERSAL], ADD_CALLBACK, long.class, Object.class, Object.class); frameIntervalNanos = reflectObject(choreographer, "mFrameIntervalNanos"); // 监听Looper回调 LooperMonitor.register(new LooperMonitor.LooperDispatchListener() &#123; ...... &#125;); ...... &#125; private synchronized void addFrameCallback(int type, Runnable callback, boolean isAddHeader) &#123; ...... if (null != method) &#123; // 将回调callback加入到指定类型（input、animation、traversal）的回调队列中 method.invoke(callbackQueues[type], !isAddHeader ? SystemClock.uptimeMillis() : -1, callback, null); callbackExist[type] = true; &#125; ...... &#125; public void addObserver(LooperObserver observer) &#123; if (!isAlive) &#123; // 监听Choreographer回调 onStart(); &#125; ...... &#125; /** * Looper中使用handle处理Message之前 */ private void dispatchBegin() &#123; token = dispatchTimeMs[0] = SystemClock.uptimeMillis(); dispatchTimeMs[2] = SystemClock.currentThreadTimeMillis(); ...... &#125; /** * 帧开始 * @param token */ private void doFrameBegin(long token) &#123; // 标记是帧 this.isBelongFrame = true; &#125; /** *指定类型的队列回调开始 */ private void doQueueBegin(int type) &#123; queueStatus[type] = DO_QUEUE_BEGIN; queueCost[type] = System.nanoTime(); &#125; /** *指定类型的队列回调结束 */ private void doQueueEnd(int type) &#123; queueStatus[type] = DO_QUEUE_END; queueCost[type] = System.nanoTime() - queueCost[type]; synchronized (this) &#123; callbackExist[type] = false; &#125; &#125; /** * 帧结束 * @param token */ private void doFrameEnd(long token) &#123; // 标记TRAVERSAL 回调结束了 doQueueEnd(CALLBACK_TRAVERSAL); ...... // 重新添加回调到 INPUT 的回调队列 addFrameCallback(CALLBACK_INPUT, this, true); this.isBelongFrame = false; &#125; /** * handle 处理Message 结束 */ private void dispatchEnd() &#123; // 如果处理的消息是帧消息 if (isBelongFrame) &#123; // doFrameEnd(token); &#125; long start = token; long end = SystemClock.uptimeMillis(); synchronized (observers) &#123; for (LooperObserver observer : observers) &#123; if (observer.isDispatchBegin()) &#123; observer.doFrame(AppMethodBeat.getVisibleScene(), token, SystemClock.uptimeMillis(), isBelongFrame ? end - start : 0, queueCost[CALLBACK_INPUT], queueCost[CALLBACK_ANIMATION], queueCost[CALLBACK_TRAVERSAL]); &#125; &#125; &#125; ...... &#125; /** * 开始 */ @Override public synchronized void onStart() &#123; ...... // 添加callback到 Choreographer 的 INPUT 回调队列； // 会在 Choreographer 执行 doFrames-&gt;doCallback -&gt; callback的run方法 addFrameCallback(CALLBACK_INPUT, this, true); ...... &#125; /** INPUT 的回调 * Choreographer： * -&gt; FrameDisplayEventReceiver.onVsync 接收其他线程|进程的刷新消息，抛给Handle 处理 * -&gt; LooperMonitor 通过代理Looper中的日志输出类Printer，拦截日志，分析Handler处理消息前、后日志 * -&gt; Looper loop * -&gt; LooperMonitor onDispatchStart * -&gt; Choreographer FrameHandler doFrame -&gt; doCallback * -&gt; run * -&gt; doFrameBegin * -&gt; doQueueBegin INPUT * -&gt; doQueueEnd INPUT, doQueueBegin ANIMATION * -&gt; doQueueEnd ANIMATION, doQueueEnd TRAVERSAL * -&gt; doFrameEnd * -&gt; doQueueEnd TRAVERSAL * -&gt; addFrameCallback INPUT * -&gt; LooperMonitor onDispatchEnd * -&gt; 回调 doFrame * * FrameDisplayEventReceiver.run */ @Override public void run() &#123; final long start = System.nanoTime(); try &#123; // 标记帧开始了 doFrameBegin(token); // 标记INPUT 回调开始了 doQueueBegin(CALLBACK_INPUT); // 添加对应的回调；回调结束之后，会从队列中移出。 addFrameCallback(CALLBACK_ANIMATION, new Runnable() &#123; @Override public void run() &#123; // INPUT 回调结束了； doQueueEnd(CALLBACK_INPUT); // ANIMATION 回调开始了 doQueueBegin(CALLBACK_ANIMATION); &#125; &#125;, true); addFrameCallback(CALLBACK_TRAVERSAL, new Runnable() &#123; @Override public void run() &#123; // ANIMATION 回调结束了 doQueueEnd(CALLBACK_ANIMATION); // TRAVERSAL 回调开始了 doQueueBegin(CALLBACK_TRAVERSAL); &#125; &#125;, true); &#125; finally &#123; ....... &#125; &#125;&#125; 123456789101112131415161718192021private final class FrameDisplayEventReceiver extends DisplayEventReceiver implements Runnable &#123; ...... @Override public void onVsync(long timestampNanos, int builtInDisplayId, int frame) &#123; ...... mTimestampNanos = timestampNanos; mFrame = frame; // 监听系统消息，收到消息后发送消息到Handler Message msg = Message.obtain(mHandler, this); msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS); &#125; @Override public void run() &#123; mHavePendingVsync = false; // 执行帧消息 doFrame(mTimestampNanos, mFrame); &#125; &#125; 123456789101112131415161718192021222324252627void doFrame(long frameTimeNanos, int frame) &#123; ...... try &#123; ...... // 依次执行INPUT、ANIMATION、TRAVERSAL回调 doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos); ...... doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos); ...... doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos); ...... doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos); &#125; finally &#123; ...... &#125; ......&#125;void doCallbacks(int callbackType, long frameTimeNanos) &#123; ...... // 执行指定类型的队列中的回调 for (CallbackRecord c = callbacks; c != null; c = c.next) &#123; c.run(frameTimeNanos); &#125; // 执行完之后从队列中移出 ......&#125; 12345678910111213141516171819202122232425262728293031public class FrameTracer extends Tracer &#123; @Override public void onAlive() &#123; super.onAlive(); // 注册观察者 UIThreadMonitor.getMonitor().addObserver(this); &#125; // 观察者 回调接口 @Override public void doFrame(String focusedActivityName, long start, long end, long frameCostMs, long inputCostNs, long animationCostNs, long traversalCostNs) &#123; if (isForeground()) &#123; notifyListener(focusedActivityName, end - start, frameCostMs, frameCostMs &gt;= 0); &#125; &#125; private void notifyListener(final String visibleScene, final long taskCostMs, final long frameCostMs, final boolean isContainsFrame) &#123; // 计算本次handle执行，过去了多少帧；这里用的时间和Choreography没有关系。 final int dropFrame = (int) (taskCostMs / frameIntervalMs); if (null != listener.getExecutor()) &#123; listener.getExecutor().execute(new Runnable() &#123; @Override public void run() &#123; // 这里会分析帧，并上报 listener.doFrameAsync(visibleScene, taskCostMs, frameCostMs, dropFrame, isContainsFrame); &#125; &#125;); &#125; &#125;&#125; 微信源码： https://github.com/zubao/matrix 1、采集了每次Handle执行Message 花的时间，以及Input、Animation、traversal的时间； 2、按照每帧16.66ms，计算本次执行过去了多少帧，并与当前页面名称关联； 3、超过42表示卡顿；超过24表示掉帧严重；超过9表示中等；超过3表示一般；小于3表示良好； 4、每10s中上传一次。 参考文章 Choreographer 与绘制的关系 https://juejin.im/entry/5ae1a4aef265da0b7e0bf94a Systrace 角度看Choreographer https://androidperformance.com/2019/10/22/Android-Choreographer/]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>apm</tag>
        <tag>FPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 设备ID]]></title>
    <url>%2Fblog%2F2020%2F06%2F18%2FAndroid%20%E8%AE%BE%E5%A4%87ID%2F</url>
    <content type="text"><![CDATA[设备ID https://wetest.qq.com/lab/view/116.html https://juejin.im/post/5d8ab56df265da5bb252d67c CID（for MMC，SDCard） 终端标准采集方式： adb shell cat /sys/class/mmc_host/mmc/mmc:*/cid 一般来讲MMC0 保存的是内置存储卡的信息，MMC1 保存的是扩展存储卡也就是SD卡的信息。因为SD卡跟终端设备又不是强关联的，会因为更换升级发生变化，那么我们主要看手机内置存储卡的CID。 采集有效率：95%~96% 与IMEI相当，在部分山寨低端机器上，会出现采集不到和采集的是SD卡的CID，初步分析是由于山寨低端机器上采用的存储设备为Flash卡或者并未遵循标准的设计规范，因此而采集不到。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 网络性能优化]]></title>
    <url>%2Fblog%2F2020%2F06%2F18%2FAndroid%20%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[参考文章 https://juejin.im/post/5eba5a39e51d454de64e49b1 https://juejin.im/post/5ecf149af265da76ce577fbc https://juejin.im/post/5edc594ef265da76ea2e988c]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android mmap demo]]></title>
    <url>%2Fblog%2F2020%2F06%2F17%2FAndroid%20mmap%20demo%2F</url>
    <content type="text"><![CDATA[创建指定大小的文件 12touch text.txtmkfile -n 10k text.txt android jni mmap demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187#include &lt;jni.h&gt;#include &lt;string&gt;#include &lt;sys/mman.h&gt;#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;android/log.h&gt;#define TAG "JNITEST"#define LOGI(...) __android_log_print(ANDROID_LOG_INFO,TAG,__VA_ARGS__)int mmapWrite()&#123; const char * file = "/data/data/com.pa.mmp/text.txt"; //打开文件，fd文件句柄 int fd = open(file, O_RDWR ); if(fd &lt; 0)&#123; LOGI("Can't open %s\n",file); exit(-1); &#125; //获取文件信息（此处获取大小信息） struct stat sb; if((fstat(fd, &amp;sb)) == -1)&#123; LOGI("Can't file status failed\n"); exit(-1); &#125; LOGI("SB file size %d\n", sb.st_size); //使用mmap进行映射,映射整个文件大小sb.st_size void* mapped = mmap(NULL, sb.st_size , PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); if(mapped== MAP_FAILED)&#123; LOGI("File mmap failed\n"); exit(-1); &#125; LOGI("SB file size %d\n", 1); //映射结束，关闭文件 close(fd); LOGI("SB file size %d\n", 2); //对映射内存进行修改,首地址写入Hello World strcpy((char*)mapped,"Hello World!"); LOGI("SB file size %d\n", 3); //同步内存与文件 //只要文件映射存在，就可以通过msync将映射空间的内容写入文件，实现空间和文件的同步。 if(msync ((void *) mapped, sb.st_size, MS_SYNC)== -1)&#123; LOGI("msync failed \n"); exit(-1); &#125; LOGI("SB file size %d\n", 4); //释放映射区，取消映射 if ((munmap ((void *) mapped, sb.st_size)) == -1) &#123; LOGI("munmap failed \n"); exit(-1); &#125; LOGI("mmap success \n"); return 0;&#125;// 读取字符串char* mmapRead()&#123; const char * file = "/data/data/com.pa.mmp/text.txt"; //打开文件，fd文件句柄 int fd = open(file, O_RDWR ); if(fd &lt; 0)&#123; LOGI("Can't open %s\n",file); exit(-1); &#125; void *start; struct stat sb; fstat(fd, &amp;sb); /* 取得文件大小 */ LOGI("Can't open %d\n",sb.st_size); start = mmap(NULL, sb.st_size, PROT_READ, MAP_PRIVATE, fd, 0); if(start == MAP_FAILED) /* 判断是否映射成功 */ return ""; char *res = (char*)malloc(1024*sizeof(char)); strcpy(res, (char*)start); LOGI("String : %s\n", res); munmap(start, sb.st_size); /* 解除映射 */ close(fd); LOGI("mmap success \n"); return (char*)res;&#125;// 写入字符串int mmapWrite(const char* ch)&#123; const char * file = "/data/data/com.pa.mmp/text.txt"; //打开文件，fd文件句柄 int fd = open(file, O_RDWR ); if(fd &lt; 0)&#123; LOGI("Can't open %s\n",file); exit(-1); &#125; //获取文件信息（此处获取大小信息） struct stat sb; if((fstat(fd, &amp;sb)) == -1)&#123; LOGI("Can't file status failed\n"); exit(-1); &#125; LOGI("SB file size %d\n", sb.st_size); //使用mmap进行映射,映射整个文件大小sb.st_size void* mapped = mmap(NULL, sb.st_size , PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); if(mapped== MAP_FAILED)&#123; LOGI("File mmap failed\n"); exit(-1); &#125; LOGI("SB file size %d\n", 1); //映射结束，关闭文件 close(fd); LOGI("SB file size %d\n", 2); //对映射内存进行修改,首地址写入Hello World strcpy((char*)mapped,ch); LOGI("SB file size %d\n", 3); //同步内存与文件 //只要文件映射存在，就可以通过msync将映射空间的内容写入文件，实现空间和文件的同步。 if(msync ((void *) mapped, sb.st_size, MS_SYNC)== -1)&#123; LOGI("msync failed \n"); exit(-1); &#125; LOGI("SB file size %d\n", 4); //释放映射区，取消映射 if ((munmap ((void *) mapped, sb.st_size)) == -1) &#123; LOGI("munmap failed \n"); exit(-1); &#125; LOGI("mmap success \n"); return 0;&#125;extern "C" JNIEXPORT jstring JNICALLJava_com_pa_mmp_MainActivity_stringFromJNI( JNIEnv* env, jobject /* this */) &#123; std::string hello = "Hello from C++"; LOGI("the string is :%s", "stringFromJNI start ...."); mmapWrite(); LOGI("the string is :%s", "stringFromJNI end ...."); return env-&gt;NewStringUTF(hello.c_str());&#125;extern "C" JNIEXPORT jstring JNICALLJava_com_pa_mmp_MainActivity_readTime( JNIEnv* env, jobject /* this */) &#123; std::string hello = "Hello from C++"; LOGI("the string is :%s", "readTime start ...."); char* msg = mmapRead(); LOGI("the string is :%s", "readTime end ...."); return env-&gt;NewStringUTF(msg);&#125;extern "C" JNIEXPORT jint JNICALLJava_com_pa_mmp_MainActivity_writeTime( JNIEnv* env, jobject /* this */, jstring time) &#123; std::string hello = "Hello from C++"; LOGI("the string is :%s", "writeTime start ...."); const char *dname=NULL; dname = env-&gt;GetStringUTFChars(time, 0); mmapWrite(dname); LOGI("the string is :%s", "writeTime end ...."); return 0;&#125; 参考文章 https://blog.n0texpecterr0r.cn/2019/01/14/%E3%80%90i-o%E3%80%91%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84-mmap-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/ https://blog.csdn.net/u012702547/article/details/48222859 https://blog.csdn.net/mcryeasy/article/details/86741781]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>demo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 性能监控]]></title>
    <url>%2Fblog%2F2020%2F06%2F15%2FAndroid%20%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[rabbit https://juejin.im/post/5e189537f265da3e413f4da2 源码： https://github.com/zubao/rabbit-client Firebase Performance Monitoring SDK 谷歌 https://firebase.google.com/docs/perf-mon/get-started-android?hl=zh-cn matrix 腾讯-微信 https://github.com/zubao/matrix https://dahei.me/2018/12/27/%E8%85%BE%E8%AE%AF%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E6%A1%86%E6%9E%B6Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E7%AC%AC%E4%B8%80%E7%AF%87/ ArgusAPM 360 https://github.com/Qihoo360/ArgusAPM Emmagee 网易 https://github.com/Qihoo360/ArgusAPM fpsviewer https://github.com/SilenceDut/fpsviewer Android Performance Monitor https://github.com/markzhai/AndroidPerformanceMonitor 参考文章： https://github.com/D-clock/Doc/blob/master/Android/%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86%E6%B1%87%E6%80%BB.md]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>apm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 虚拟机 JVMTI]]></title>
    <url>%2Fblog%2F2020%2F06%2F09%2FJava%20%E8%99%9A%E6%8B%9F%E6%9C%BA%20JVMTI%2F</url>
    <content type="text"><![CDATA[JVMTI(JVM tools interface) https://cloud.tencent.com/developer/article/1478720]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvmti</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac gdb调试]]></title>
    <url>%2Fblog%2F2020%2F06%2F08%2FMac%20GDB%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[安装gdb 命令行安装 1brew install gdb 编译安装 1234567 # 下载源码 http://ftp.gnu.org/gnu/gdb/gdb-8.0.tar.gz # 编译安装 ./configuremake j4make installgdb -v 创建证书 使用钥匙串创建证书 打开 应用程序&gt;实用工具&gt;钥匙串 左上角菜单&gt;钥匙串访问-&gt;证书助理-&gt;创建证书 名称 gdb_codesign；身份类型：自签名根证书；证书类型：代码签名；勾选：让我覆盖这些默认设置 一直next，直到出现“指定证书位置”，选择登录，然后完成。 将创建的证书拖到桌面； 打开钥匙串，两指单击系统&gt;解锁钥匙串系统&gt;添加证书&gt;将上步拖到桌面的证书添加到系统。 删除登录中的gdb_codesign证书 点击系统-gdb_codesign，展开信任，选择始终信任； 签名gdb sudo codesign -s gdb_codesign /usr/local/bin/gdb 1234567891011121310.14及以后先创建一个文件 gdb-entitlement.xml，内容为:&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;&lt;plist version="1.0"&gt;&lt;dict&gt; &lt;key&gt;com.apple.security.cs.debugger&lt;/key&gt; &lt;true/&gt;&lt;/dict&gt;&lt;/plist&gt;&lt;/pre&gt;codesign --entitlements gdb-entitlement.xml -fs gdb-cert $(which gdb) echo “set startup-with-shell off” &gt;&gt; ~/.gdbinit gdb 调试 https://blog.csdn.net/feixiaoxing/article/details/7199643 参考文章 https://blog.csdn.net/wj1066/article/details/83653153 https://segmentfault.com/q/1010000004136334 https://sourceware.org/gdb/wiki/PermissionsDarwin]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 虚拟机 启动跟踪]]></title>
    <url>%2Fblog%2F2020%2F06%2F06%2FJava%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%90%AF%E5%8A%A8%E8%B7%9F%E8%B8%AA%2F</url>
    <content type="text"><![CDATA[环境配置 macosx 10.14 虚拟机源码版本 OpenJDK11U 编译命令 12sh configure --with-jvm-variants=client --disable-warnings-as-errors --with-debug-level=slowdebug make images 源码跟踪 虚拟机入口方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140// 虚拟机入口文件 src/java.base/share/native/launcher/main.c/* * Entry point. */#ifdef JAVAWchar **__initenv;int WINAPIWinMain(HINSTANCE inst, HINSTANCE previnst, LPSTR cmdline, int cmdshow)&#123; int margc; char** margv; int jargc; char** jargv; const jboolean const_javaw = JNI_TRUE; __initenv = _environ;#else /* JAVAW */JNIEXPORT intmain(int argc, char **argv)&#123; int margc; char** margv; int jargc; char** jargv; const jboolean const_javaw = JNI_FALSE;#endif /* JAVAW */ &#123; int i, main_jargc, extra_jargc; JLI_List list; main_jargc = (sizeof(const_jargs) / sizeof(char *)) &gt; 1 ? sizeof(const_jargs) / sizeof(char *) : 0; // ignore the null terminator index extra_jargc = (sizeof(const_extra_jargs) / sizeof(char *)) &gt; 1 ? sizeof(const_extra_jargs) / sizeof(char *) : 0; // ignore the null terminator index if (main_jargc &gt; 0 &amp;&amp; extra_jargc &gt; 0) &#123; // combine extra java args jargc = main_jargc + extra_jargc; list = JLI_List_new(jargc + 1); for (i = 0 ; i &lt; extra_jargc; i++) &#123; JLI_List_add(list, JLI_StringDup(const_extra_jargs[i])); &#125; for (i = 0 ; i &lt; main_jargc ; i++) &#123; JLI_List_add(list, JLI_StringDup(const_jargs[i])); &#125; // terminate the list JLI_List_add(list, NULL); jargv = list-&gt;elements; &#125; else if (extra_jargc &gt; 0) &#123; // should never happen fprintf(stderr, "EXTRA_JAVA_ARGS defined without JAVA_ARGS"); abort(); &#125; else &#123; // no extra args, business as usual jargc = main_jargc; jargv = (char **) const_jargs; &#125; &#125; JLI_InitArgProcessing(jargc &gt; 0, const_disable_argfile);#ifdef _WIN32 &#123; int i = 0; if (getenv(JLDEBUG_ENV_ENTRY) != NULL) &#123; printf("Windows original main args:\n"); for (i = 0 ; i &lt; __argc ; i++) &#123; printf("wwwd_args[%d] = %s\n", i, __argv[i]); &#125; &#125; &#125; JLI_CmdToArgs(GetCommandLine()); margc = JLI_GetStdArgc(); // add one more to mark the end margv = (char **)JLI_MemAlloc((margc + 1) * (sizeof(char *))); &#123; int i = 0; StdArg *stdargs = JLI_GetStdArgs(); for (i = 0 ; i &lt; margc ; i++) &#123; margv[i] = stdargs[i].arg; &#125; margv[i] = NULL; &#125;#else /* *NIXES */ &#123; // accommodate the NULL at the end JLI_List args = JLI_List_new(argc + 1); int i = 0; // Add first arg, which is the app name JLI_List_add(args, JLI_StringDup(argv[0])); // Append JDK_JAVA_OPTIONS if (JLI_AddArgsFromEnvVar(args, JDK_JAVA_OPTIONS)) &#123; // JLI_SetTraceLauncher is not called yet // Show _JAVA_OPTIONS content along with JDK_JAVA_OPTIONS to aid diagnosis if (getenv(JLDEBUG_ENV_ENTRY)) &#123; char *tmp = getenv("_JAVA_OPTIONS"); if (NULL != tmp) &#123; JLI_ReportMessage(ARG_INFO_ENVVAR, "_JAVA_OPTIONS", tmp); &#125; &#125; &#125; // Iterate the rest of command line for (i = 1; i &lt; argc; i++) &#123; JLI_List argsInFile = JLI_PreprocessArg(argv[i], JNI_TRUE); if (NULL == argsInFile) &#123; JLI_List_add(args, JLI_StringDup(argv[i])); &#125; else &#123; int cnt, idx; cnt = argsInFile-&gt;size; for (idx = 0; idx &lt; cnt; idx++) &#123; JLI_List_add(args, argsInFile-&gt;elements[idx]); &#125; // Shallow free, we reuse the string to avoid copy JLI_MemFree(argsInFile-&gt;elements); JLI_MemFree(argsInFile); &#125; &#125; margc = args-&gt;size; // add the NULL pointer at argv[argc] JLI_List_add(args, NULL); margv = args-&gt;elements; &#125;#endif /* WIN32 */ return JLI_Launch(margc, margv, jargc, (const char**) jargv, 0, NULL, VERSION_STRING, DOT_VERSION, (const_progname != NULL) ? const_progname : *margv, (const_launcher != NULL) ? const_launcher : *margv, jargc &gt; 0, const_cpwildcard, const_javaw, 0);&#125; JLI_Launch 方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132// src/java.base/share/native/libjli/java.c/* * Entry point. */JNIEXPORT int JNICALLJLI_Launch(int argc, char ** argv, /* main argc, argv */ int jargc, const char** jargv, /* java args */ int appclassc, const char** appclassv, /* app classpath */ const char* fullversion, /* full version defined */ const char* dotversion, /* UNUSED dot version defined */ const char* pname, /* program name */ const char* lname, /* launcher name */ jboolean javaargs, /* JAVA_ARGS */ jboolean cpwildcard, /* classpath wildcard*/ jboolean javaw, /* windows-only javaw */ jint ergo /* unused */)&#123; int mode = LM_UNKNOWN; char *what = NULL; char *main_class = NULL; int ret; InvocationFunctions ifn; jlong start = 0, end = 0; char jvmpath[MAXPATHLEN]; char jrepath[MAXPATHLEN]; char jvmcfg[MAXPATHLEN]; _fVersion = fullversion; _launcher_name = lname; _program_name = pname; _is_java_args = javaargs; _wc_enabled = cpwildcard; printf("LPL Java Enter Point！\n"); InitLauncher(javaw); DumpState(); if (JLI_IsTraceLauncher()) &#123; int i; printf("Java args:\n"); for (i = 0; i &lt; jargc ; i++) &#123; printf("jargv[%d] = %s\n", i, jargv[i]); &#125; printf("Command line args:\n"); for (i = 0; i &lt; argc ; i++) &#123; printf("argv[%d] = %s\n", i, argv[i]); &#125; AddOption("-Dsun.java.launcher.diag=true", NULL); &#125; /* * SelectVersion() has several responsibilities: * * 1) Disallow specification of another JRE. With 1.9, another * version of the JRE cannot be invoked. * 2) Allow for a JRE version to invoke JDK 1.9 or later. Since * all mJRE directives have been stripped from the request but * the pre 1.9 JRE [ 1.6 thru 1.8 ], it is as if 1.9+ has been * invoked from the command line. */ SelectVersion(argc, argv, &amp;main_class); // 这里进入会新开线程，并重新执行上面的main方法 CreateExecutionEnvironment(&amp;argc, &amp;argv, jrepath, sizeof(jrepath), jvmpath, sizeof(jvmpath), jvmcfg, sizeof(jvmcfg)); if (!IsJavaArgs()) &#123; SetJvmEnvironment(argc,argv); &#125; ifn.CreateJavaVM = 0; ifn.GetDefaultJavaVMInitArgs = 0; if (JLI_IsTraceLauncher()) &#123; start = CounterGet(); &#125; // 载入JVM if (!LoadJavaVM(jvmpath, &amp;ifn)) &#123; return(6); &#125; if (JLI_IsTraceLauncher()) &#123; end = CounterGet(); &#125; JLI_TraceLauncher("%ld micro seconds to LoadJavaVM\n", (long)(jint)Counter2Micros(end-start)); ++argv; --argc; if (IsJavaArgs()) &#123; /* Preprocess wrapper arguments */ TranslateApplicationArgs(jargc, jargv, &amp;argc, &amp;argv); if (!AddApplicationOptions(appclassc, appclassv)) &#123; return(1); &#125; &#125; else &#123; /* Set default CLASSPATH */ char* cpath = getenv("CLASSPATH"); if (cpath != NULL) &#123; SetClassPath(cpath); &#125; &#125; /* Parse command line options; if the return value of * ParseArguments is false, the program should exit. */ if (!ParseArguments(&amp;argc, &amp;argv, &amp;mode, &amp;what, &amp;ret, jrepath)) &#123; return(ret); &#125; /* Override class path if -jar flag was specified */ if (mode == LM_JAR) &#123; SetClassPath(what); /* Override class path */ &#125; /* set the -Dsun.java.command pseudo property */ SetJavaCommandLineProp(what, argc, argv); /* Set the -Dsun.java.launcher pseudo property */ SetJavaLauncherProp(); /* set the -Dsun.java.launcher.* platform properties */ SetJavaLauncherPlatformProps(); return JVMInit(&amp;ifn, threadStackSize, argc, argv, mode, what, ret);&#125;//参考 https://blog.csdn.net/weixin_37477523/article/details/88117056 CreateExecutionEnvironment 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 文件：/src/java.base/macosx/native/libjli/java_md_macosx.cvoidCreateExecutionEnvironment(int *pargc, char ***pargv, char jrepath[], jint so_jrepath, char jvmpath[], jint so_jvmpath, char jvmcfg[], jint so_jvmcfg) &#123; jboolean jvmpathExists; /* Compute/set the name of the executable */ SetExecname(*pargv); char * jvmtype = NULL; int argc = *pargc; char **argv = *pargv; /* Find out where the JRE is that we will be using. */ if (!GetJREPath(jrepath, so_jrepath, JNI_FALSE) ) &#123; JLI_ReportErrorMessage(JRE_ERROR1); exit(2); &#125; JLI_Snprintf(jvmcfg, so_jvmcfg, "%s%slib%sjvm.cfg", jrepath, FILESEP, FILESEP); /* Find the specified JVM type */ if (ReadKnownVMs(jvmcfg, JNI_FALSE) &lt; 1) &#123; JLI_ReportErrorMessage(CFG_ERROR7); exit(1); &#125; jvmpath[0] = '\0'; jvmtype = CheckJvmType(pargc, pargv, JNI_FALSE); if (JLI_StrCmp(jvmtype, "ERROR") == 0) &#123; JLI_ReportErrorMessage(CFG_ERROR9); exit(4); &#125; if (!GetJVMPath(jrepath, jvmtype, jvmpath, so_jvmpath)) &#123; JLI_ReportErrorMessage(CFG_ERROR8, jvmtype, jvmpath); exit(4); &#125; /* * Mac OS X requires the Cocoa event loop to be run on the "main" * thread. Spawn off a new thread to run main() and pass * this thread off to the Cocoa event loop. */ // Mac OS X 上面需要在 Cocoa event loop 上面运行 main线程，这里就将当前线程停止，新建一个线程重新运行main方法。 MacOSXStartup(argc, argv); /* * we seem to have everything we need */ return;&#125; MacOSXStartup 12345678910111213141516171819202122232425262728293031323334// 文件：/src/java.base/macosx/native/libjli/java_md_macosx.c/* * Mac OS X mandates that the GUI event loop run on very first thread of * an application. This requires that we re-call Java's main() on a new * thread, reserving the 'main' thread for Cocoa. */static void MacOSXStartup(int argc, char *argv[]) &#123; // Thread already started? // 只有第一次会另起一个线程去重新执行main方法 static jboolean started = false; if (started) &#123; return; &#125; started = true; // Hand off arguments struct NSAppArgs args; args.argc = argc; args.argv = argv; // Fire up the main thread pthread_t main_thr; // 新建一个线程，通过apple_main方法去重新运行 main方法 if (pthread_create(&amp;main_thr, NULL, &amp;apple_main, &amp;args) != 0) &#123; JLI_ReportErrorMessageSys("Could not create main thread: %s\n", strerror(errno)); exit(1); &#125; if (pthread_detach(main_thr)) &#123; JLI_ReportErrorMessageSys("pthread_detach() failed: %s\n", strerror(errno)); exit(1); &#125; ParkEventLoop();&#125; apple_main 1234567891011121314151617181920212223// 文件：/src/java.base/macosx/native/libjli/java_md_macosx.c/* * Unwrap the arguments and re-run main() */static void *apple_main (void *arg)&#123; if (main_fptr == NULL) &#123;#ifdef STATIC_BUILD extern int main(int argc, char **argv); main_fptr = &amp;main;#else main_fptr = (int (*)())dlsym(RTLD_DEFAULT, "main");#endif if (main_fptr == NULL) &#123; JLI_ReportErrorMessageSys("error locating main entrypoint\n"); exit(1); &#125; &#125; struct NSAppArgs *args = (struct NSAppArgs *) arg; // 重新运行main方法 exit(main_fptr(args-&gt;argc, args-&gt;argv));&#125; LoadJavaVM 载入虚拟机 1234567891011121314151617181920212223242526272829303132333435363738394041424344// src/java.base/macosx/native/libjli/java_md_macosx.cjbooleanLoadJavaVM(const char *jvmpath, InvocationFunctions *ifn)&#123; Dl_info dlinfo; void *libjvm; JLI_TraceLauncher("macosx JVM path is %s\n", jvmpath); // 读取、载入编译好的jvm库文件 jdk/lib/client/libjvm.dylib#ifndef STATIC_BUILD libjvm = dlopen(jvmpath, RTLD_NOW + RTLD_GLOBAL);#else libjvm = dlopen(NULL, RTLD_FIRST);#endif if (libjvm == NULL) &#123; JLI_ReportErrorMessage(DLL_ERROR1, __LINE__); JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror()); return JNI_FALSE; &#125;// 从库文件中获取指定的JNI_CreateJavaVM方法。 ifn-&gt;CreateJavaVM = (CreateJavaVM_t) dlsym(libjvm, "JNI_CreateJavaVM"); if (ifn-&gt;CreateJavaVM == NULL) &#123; JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror()); return JNI_FALSE; &#125; ifn-&gt;GetDefaultJavaVMInitArgs = (GetDefaultJavaVMInitArgs_t) dlsym(libjvm, "JNI_GetDefaultJavaVMInitArgs"); if (ifn-&gt;GetDefaultJavaVMInitArgs == NULL) &#123; JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror()); return JNI_FALSE; &#125; ifn-&gt;GetCreatedJavaVMs = (GetCreatedJavaVMs_t) dlsym(libjvm, "JNI_GetCreatedJavaVMs"); if (ifn-&gt;GetCreatedJavaVMs == NULL) &#123; JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror()); return JNI_FALSE; &#125; return JNI_TRUE;&#125; JNI_CreateJavaVM 创建jvm 123456789101112131415// 文件：src/hotspot/share/prims/jni.cpp_JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_CreateJavaVM(JavaVM **vm, void **penv, void *args) &#123; jint result = JNI_ERR; // On Windows, let CreateJavaVM run with SEH protection#ifdef _WIN32 __try &#123;#endif result = JNI_CreateJavaVM_inner(vm, penv, args);#ifdef _WIN32 &#125; __except(topLevelExceptionFilter((_EXCEPTION_POINTERS*)_exception_info())) &#123; // Nothing to do. &#125;#endif return result;&#125; JNI_CreateJavaVM_inner 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148// 文件：src/hotspot/share/prims/jni.cppstatic jint JNI_CreateJavaVM_inner(JavaVM **vm, void **penv, void *args) &#123; HOTSPOT_JNI_CREATEJAVAVM_ENTRY((void **) vm, penv, args); jint result = JNI_ERR; DT_RETURN_MARK(CreateJavaVM, jint, (const jint&amp;)result); // We're about to use Atomic::xchg for synchronization. Some Zero // platforms use the GCC builtin __sync_lock_test_and_set for this, // but __sync_lock_test_and_set is not guaranteed to do what we want // on all architectures. So we check it works before relying on it.#if defined(ZERO) &amp;&amp; defined(ASSERT) &#123; jint a = 0xcafebabe; jint b = Atomic::xchg((jint) 0xdeadbeef, &amp;a); void *c = &amp;a; void *d = Atomic::xchg(&amp;b, &amp;c); assert(a == (jint) 0xdeadbeef &amp;&amp; b == (jint) 0xcafebabe, "Atomic::xchg() works"); assert(c == &amp;b &amp;&amp; d == &amp;a, "Atomic::xchg() works"); &#125;#endif // ZERO &amp;&amp; ASSERT // At the moment it's only possible to have one Java VM, // since some of the runtime state is in global variables. // We cannot use our mutex locks here, since they only work on // Threads. We do an atomic compare and exchange to ensure only // one thread can call this method at a time // We use Atomic::xchg rather than Atomic::add/dec since on some platforms // the add/dec implementations are dependent on whether we are running // on a multiprocessor, and at this stage of initialization the os::is_MP // function used to determine this will always return false. Atomic::xchg // does not have this problem. if (Atomic::xchg(1, &amp;vm_created) == 1) &#123; return JNI_EEXIST; // already created, or create attempt in progress &#125; // If a previous creation attempt failed but can be retried safely, // then safe_to_recreate_vm will have been reset to 1 after being // cleared here. If a previous creation attempt succeeded and we then // destroyed that VM, we will be prevented from trying to recreate // the VM in the same process, as the value will still be 0. if (Atomic::xchg(0, &amp;safe_to_recreate_vm) == 0) &#123; return JNI_ERR; &#125; assert(vm_created == 1, "vm_created is true during the creation"); /** * Certain errors during initialization are recoverable and do not * prevent this method from being called again at a later time * (perhaps with different arguments). However, at a certain * point during initialization if an error occurs we cannot allow * this function to be called again (or it will crash). In those * situations, the 'canTryAgain' flag is set to false, which atomically * sets safe_to_recreate_vm to 1, such that any new call to * JNI_CreateJavaVM will immediately fail using the above logic. */ bool can_try_again = true; // 在Threads 类中创建虚拟机 result = Threads::create_vm((JavaVMInitArgs*) args, &amp;can_try_again); if (result == JNI_OK) &#123; // 如果创建成功 JavaThread *thread = JavaThread::current(); assert(!thread-&gt;has_pending_exception(), "should have returned not OK"); /* thread is thread_in_vm here */ *vm = (JavaVM *)(&amp;main_vm); *(JNIEnv**)penv = thread-&gt;jni_environment();#if INCLUDE_JVMCI if (EnableJVMCI) &#123; if (UseJVMCICompiler) &#123; // JVMCI is initialized on a CompilerThread if (BootstrapJVMCI) &#123; JavaThread* THREAD = thread; JVMCICompiler* compiler = JVMCICompiler::instance(true, CATCH); compiler-&gt;bootstrap(THREAD); if (HAS_PENDING_EXCEPTION) &#123; HandleMark hm; vm_exit_during_initialization(Handle(THREAD, PENDING_EXCEPTION)); &#125; &#125; &#125; &#125;#endif // Tracks the time application was running before GC RuntimeService::record_application_start(); // Notify JVMTI if (JvmtiExport::should_post_thread_life()) &#123; JvmtiExport::post_thread_start(thread); &#125; post_thread_start_event(thread);#ifndef PRODUCT // Check if we should compile all classes on bootclasspath if (CompileTheWorld) ClassLoader::compile_the_world(); if (ReplayCompiles) ciReplay::replay(thread); // Some platforms (like Win*) need a wrapper around these test // functions in order to properly handle error conditions. VMError::test_error_handler(); if (ExecuteInternalVMTests) &#123; InternalVMTests::run(); &#125;#endif // Since this is not a JVM_ENTRY we have to set the thread state manually before leaving. ThreadStateTransition::transition_and_fence(thread, _thread_in_vm, _thread_in_native); &#125; else &#123; // If create_vm exits because of a pending exception, exit with that // exception. In the future when we figure out how to reclaim memory, // we may be able to exit with JNI_ERR and allow the calling application // to continue. if (Universe::is_fully_initialized()) &#123; // otherwise no pending exception possible - VM will already have aborted JavaThread* THREAD = JavaThread::current(); if (HAS_PENDING_EXCEPTION) &#123; HandleMark hm; vm_exit_during_initialization(Handle(THREAD, PENDING_EXCEPTION)); &#125; &#125; if (can_try_again) &#123; // reset safe_to_recreate_vm to 1 so that retrial would be possible safe_to_recreate_vm = 1; &#125; // Creation failed. We must reset vm_created *vm = 0; *(JNIEnv**)penv = 0; // reset vm_created last to avoid race condition. Use OrderAccess to // control both compiler and architectural-based reordering. OrderAccess::release_store(&amp;vm_created, 0); &#125; // Flush stdout and stderr before exit. fflush(stdout); fflush(stderr); return result;&#125; create_vm 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383// 文件：src/hotspot/share/runtime/thread.cppjint Threads::create_vm(JavaVMInitArgs* args, bool* canTryAgain) &#123; extern void JDK_Version_init(); // Preinitialize version info. VM_Version::early_initialize(); // Check version if (!is_supported_jni_version(args-&gt;version)) return JNI_EVERSION; // Initialize library-based TLS ThreadLocalStorage::init(); // Initialize the output stream module ostream_init(); // Process java launcher properties. Arguments::process_sun_java_launcher_properties(args); // Initialize the os module os::init(); // Record VM creation timing statistics TraceVmCreationTime create_vm_timer; create_vm_timer.start(); // Initialize system properties. Arguments::init_system_properties(); // So that JDK version can be used as a discriminator when parsing arguments JDK_Version_init(); // Update/Initialize System properties after JDK version number is known Arguments::init_version_specific_system_properties(); // Make sure to initialize log configuration *before* parsing arguments LogConfiguration::initialize(create_vm_timer.begin_time()); // Parse arguments // Note: this internally calls os::init_container_support() jint parse_result = Arguments::parse(args); if (parse_result != JNI_OK) return parse_result; os::init_before_ergo(); jint ergo_result = Arguments::apply_ergo(); if (ergo_result != JNI_OK) return ergo_result; // Final check of all ranges after ergonomics which may change values. if (!JVMFlagRangeList::check_ranges()) &#123; return JNI_EINVAL; &#125; // Final check of all 'AfterErgo' constraints after ergonomics which may change values. bool constraint_result = JVMFlagConstraintList::check_constraints(JVMFlagConstraint::AfterErgo); if (!constraint_result) &#123; return JNI_EINVAL; &#125; JVMFlagWriteableList::mark_startup(); if (PauseAtStartup) &#123; os::pause(); &#125; HOTSPOT_VM_INIT_BEGIN(); // Timing (must come after argument parsing) TraceTime timer("Create VM", TRACETIME_LOG(Info, startuptime)); // Initialize the os module after parsing the args jint os_init_2_result = os::init_2(); if (os_init_2_result != JNI_OK) return os_init_2_result;#ifdef CAN_SHOW_REGISTERS_ON_ASSERT // Initialize assert poison page mechanism. if (ShowRegistersOnAssert) &#123; initialize_assert_poison(); &#125;#endif // CAN_SHOW_REGISTERS_ON_ASSERT SafepointMechanism::initialize(); jint adjust_after_os_result = Arguments::adjust_after_os(); if (adjust_after_os_result != JNI_OK) return adjust_after_os_result; // Initialize output stream logging ostream_init_log(); // Convert -Xrun to -agentlib: if there is no JVM_OnLoad // Must be before create_vm_init_agents() if (Arguments::init_libraries_at_startup()) &#123; convert_vm_init_libraries_to_agents(); &#125; // Launch -agentlib/-agentpath and converted -Xrun agents if (Arguments::init_agents_at_startup()) &#123; create_vm_init_agents(); &#125; // Initialize Threads state _thread_list = NULL; _number_of_threads = 0; _number_of_non_daemon_threads = 0; // Initialize global data structures and create system classes in heap vm_init_globals();#if INCLUDE_JVMCI if (JVMCICounterSize &gt; 0) &#123; JavaThread::_jvmci_old_thread_counters = NEW_C_HEAP_ARRAY(jlong, JVMCICounterSize, mtInternal); memset(JavaThread::_jvmci_old_thread_counters, 0, sizeof(jlong) * JVMCICounterSize); &#125; else &#123; JavaThread::_jvmci_old_thread_counters = NULL; &#125;#endif // INCLUDE_JVMCI // Attach the main thread to this os thread JavaThread* main_thread = new JavaThread(); main_thread-&gt;set_thread_state(_thread_in_vm); main_thread-&gt;initialize_thread_current(); // must do this before set_active_handles main_thread-&gt;record_stack_base_and_size(); main_thread-&gt;register_thread_stack_with_NMT(); main_thread-&gt;set_active_handles(JNIHandleBlock::allocate_block()); if (!main_thread-&gt;set_as_starting_thread()) &#123; vm_shutdown_during_initialization( "Failed necessary internal allocation. Out of swap space"); main_thread-&gt;smr_delete(); *canTryAgain = false; // don't let caller call JNI_CreateJavaVM again return JNI_ENOMEM; &#125; // Enable guard page *after* os::create_main_thread(), otherwise it would // crash Linux VM, see notes in os_linux.cpp. main_thread-&gt;create_stack_guard_pages(); // Initialize Java-Level synchronization subsystem ObjectMonitor::Initialize(); // Initialize global modules jint status = init_globals(); if (status != JNI_OK) &#123; main_thread-&gt;smr_delete(); *canTryAgain = false; // don't let caller call JNI_CreateJavaVM again return status; &#125; JFR_ONLY(Jfr::on_create_vm_1();) // Should be done after the heap is fully created main_thread-&gt;cache_global_variables(); HandleMark hm; &#123; MutexLocker mu(Threads_lock); Threads::add(main_thread); &#125; // Any JVMTI raw monitors entered in onload will transition into // real raw monitor. VM is setup enough here for raw monitor enter. JvmtiExport::transition_pending_onload_raw_monitors(); // Create the VMThread &#123; TraceTime timer("Start VMThread", TRACETIME_LOG(Info, startuptime)); VMThread::create(); Thread* vmthread = VMThread::vm_thread(); if (!os::create_thread(vmthread, os::vm_thread)) &#123; vm_exit_during_initialization("Cannot create VM thread. " "Out of system resources."); &#125; // Wait for the VM thread to become ready, and VMThread::run to initialize // Monitors can have spurious returns, must always check another state flag &#123; MutexLocker ml(Notify_lock); os::start_thread(vmthread); while (vmthread-&gt;active_handles() == NULL) &#123; Notify_lock-&gt;wait(); &#125; &#125; &#125; assert(Universe::is_fully_initialized(), "not initialized"); if (VerifyDuringStartup) &#123; // Make sure we're starting with a clean slate. VM_Verify verify_op; VMThread::execute(&amp;verify_op); &#125; // We need this to update the java.vm.info property in case any flags used // to initially define it have been changed. This is needed for both CDS and // AOT, since UseSharedSpaces and UseAOT may be changed after java.vm.info // is initially computed. See Abstract_VM_Version::vm_info_string(). // This update must happen before we initialize the java classes, but // after any initialization logic that might modify the flags. Arguments::update_vm_info_property(VM_Version::vm_info_string()); Thread* THREAD = Thread::current(); // Always call even when there are not JVMTI environments yet, since environments // may be attached late and JVMTI must track phases of VM execution JvmtiExport::enter_early_start_phase(); // Notify JVMTI agents that VM has started (JNI is up) - nop if no agents. JvmtiExport::post_early_vm_start(); initialize_java_lang_classes(main_thread, CHECK_JNI_ERR); quicken_jni_functions(); // No more stub generation allowed after that point. StubCodeDesc::freeze(); // Set flag that basic initialization has completed. Used by exceptions and various // debug stuff, that does not work until all basic classes have been initialized. set_init_completed(); LogConfiguration::post_initialize(); Metaspace::post_initialize(); HOTSPOT_VM_INIT_END(); // record VM initialization completion time#if INCLUDE_MANAGEMENT Management::record_vm_init_completed();#endif // INCLUDE_MANAGEMENT // Signal Dispatcher needs to be started before VMInit event is posted os::initialize_jdk_signal_support(CHECK_JNI_ERR); // Start Attach Listener if +StartAttachListener or it can't be started lazily if (!DisableAttachMechanism) &#123; AttachListener::vm_start(); if (StartAttachListener || AttachListener::init_at_startup()) &#123; AttachListener::init(); &#125; &#125; // Launch -Xrun agents // Must be done in the JVMTI live phase so that for backward compatibility the JDWP // back-end can launch with -Xdebug -Xrunjdwp. if (!EagerXrunInit &amp;&amp; Arguments::init_libraries_at_startup()) &#123; create_vm_init_libraries(); &#125; if (CleanChunkPoolAsync) &#123; Chunk::start_chunk_pool_cleaner_task(); &#125; // initialize compiler(s)#if defined(COMPILER1) || COMPILER2_OR_JVMCI#if INCLUDE_JVMCI bool force_JVMCI_intialization = false; if (EnableJVMCI) &#123; // Initialize JVMCI eagerly when it is explicitly requested. // Or when JVMCIPrintProperties is enabled. // The JVMCI Java initialization code will read this flag and // do the printing if it's set. force_JVMCI_intialization = EagerJVMCI || JVMCIPrintProperties; if (!force_JVMCI_intialization) &#123; // 8145270: Force initialization of JVMCI runtime otherwise requests for blocking // compilations via JVMCI will not actually block until JVMCI is initialized. force_JVMCI_intialization = UseJVMCICompiler &amp;&amp; (!UseInterpreter || !BackgroundCompilation); &#125; &#125;#endif CompileBroker::compilation_init_phase1(CHECK_JNI_ERR); // Postpone completion of compiler initialization to after JVMCI // is initialized to avoid timeouts of blocking compilations. if (JVMCI_ONLY(!force_JVMCI_intialization) NOT_JVMCI(true)) &#123; CompileBroker::compilation_init_phase2(); &#125;#endif // Pre-initialize some JSR292 core classes to avoid deadlock during class loading. // It is done after compilers are initialized, because otherwise compilations of // signature polymorphic MH intrinsics can be missed // (see SystemDictionary::find_method_handle_intrinsic). initialize_jsr292_core_classes(CHECK_JNI_ERR); // This will initialize the module system. Only java.base classes can be // loaded until phase 2 completes call_initPhase2(CHECK_JNI_ERR); JFR_ONLY(Jfr::on_create_vm_2();) // Always call even when there are not JVMTI environments yet, since environments // may be attached late and JVMTI must track phases of VM execution JvmtiExport::enter_start_phase(); // Notify JVMTI agents that VM has started (JNI is up) - nop if no agents. JvmtiExport::post_vm_start(); // Final system initialization including security manager and system class loader call_initPhase3(CHECK_JNI_ERR); // cache the system and platform class loaders SystemDictionary::compute_java_loaders(CHECK_JNI_ERR);#if INCLUDE_CDS if (DumpSharedSpaces) &#123; // capture the module path info from the ModuleEntryTable ClassLoader::initialize_module_path(THREAD); &#125;#endif#if INCLUDE_JVMCI if (force_JVMCI_intialization) &#123; JVMCIRuntime::force_initialization(CHECK_JNI_ERR); CompileBroker::compilation_init_phase2(); &#125;#endif // Always call even when there are not JVMTI environments yet, since environments // may be attached late and JVMTI must track phases of VM execution JvmtiExport::enter_live_phase(); // Notify JVMTI agents that VM initialization is complete - nop if no agents. JvmtiExport::post_vm_initialized(); JFR_ONLY(Jfr::on_create_vm_3();)#if INCLUDE_MANAGEMENT Management::initialize(THREAD); if (HAS_PENDING_EXCEPTION) &#123; // management agent fails to start possibly due to // configuration problem and is responsible for printing // stack trace if appropriate. Simply exit VM. vm_exit(1); &#125;#endif // INCLUDE_MANAGEMENT if (MemProfiling) MemProfiler::engage(); StatSampler::engage(); if (CheckJNICalls) JniPeriodicChecker::engage(); BiasedLocking::init();#if INCLUDE_RTM_OPT RTMLockingCounters::init();#endif if (JDK_Version::current().post_vm_init_hook_enabled()) &#123; call_postVMInitHook(THREAD); // The Java side of PostVMInitHook.run must deal with all // exceptions and provide means of diagnosis. if (HAS_PENDING_EXCEPTION) &#123; CLEAR_PENDING_EXCEPTION; &#125; &#125; &#123; MutexLocker ml(PeriodicTask_lock); // Make sure the WatcherThread can be started by WatcherThread::start() // or by dynamic enrollment. WatcherThread::make_startable(); // Start up the WatcherThread if there are any periodic tasks // NOTE: All PeriodicTasks should be registered by now. If they // aren't, late joiners might appear to start slowly (we might // take a while to process their first tick). if (PeriodicTask::num_tasks() &gt; 0) &#123; WatcherThread::start(); &#125; &#125; create_vm_timer.end();#ifdef ASSERT _vm_complete = true;#endif if (DumpSharedSpaces) &#123; MetaspaceShared::preload_and_dump(CHECK_JNI_ERR); ShouldNotReachHere(); &#125; return JNI_OK;&#125; vm_init_globals 123456789101112// 文件：src/hotspot/share/runtime/init.cppvoid vm_init_globals() &#123; check_ThreadShadow(); // 基础类型初始化 basic_types_init(); eventlog_init(); // 互斥锁 mutex_init(); chunkpool_init(); perfMemory_init(); SuspendibleThreadSet_init();&#125; init_globals 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 文件：src/hotspot/share/runtime/init.cppjint init_globals() &#123; HandleMark hm; management_init(); // 操作符初始化 bytecodes_init(); // classLoader_init1(); compilationPolicy_init(); codeCache_init(); VM_Version_init(); os_init_globals(); stubRoutines_init1(); // 堆初始化 jint status = universe_init(); // dependent on codeCache_init and // stubRoutines_init1 and metaspace_init. if (status != JNI_OK) return status; gc_barrier_stubs_init(); // depends on universe_init, must be before interpreter_init interpreter_init(); // before any methods loaded invocationCounter_init(); // before any methods loaded accessFlags_init(); templateTable_init(); InterfaceSupport_init(); VMRegImpl::set_regName(); // need this before generate_stubs (for printing oop maps). SharedRuntime::generate_stubs(); universe2_init(); // dependent on codeCache_init and stubRoutines_init1 javaClasses_init();// must happen after vtable initialization, before referenceProcessor_init referenceProcessor_init(); jni_handles_init();#if INCLUDE_VM_STRUCTS vmStructs_init();#endif // INCLUDE_VM_STRUCTS vtableStubs_init(); InlineCacheBuffer_init(); compilerOracle_init(); dependencyContext_init(); if (!compileBroker_init()) &#123; return JNI_EINVAL; &#125; if (!universe_post_init()) &#123; return JNI_ERR; &#125; stubRoutines_init2(); // note: StubRoutines need 2-phase init MethodHandles::generate_adapters();#if INCLUDE_NMT // Solaris stack is walkable only after stubRoutines are set up. // On Other platforms, the stack is always walkable. NMT_stack_walkable = true;#endif // INCLUDE_NMT // All the flags that get adjusted by VM_Version_init and os::init_2 // have been set so dump the flags now. if (PrintFlagsFinal || PrintFlagsRanges) &#123; JVMFlag::printFlags(tty, false, PrintFlagsRanges); &#125; return JNI_OK;&#125; universe_init 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// 文件 /src/hotspot/share/memory/universe.cppjint universe_init() &#123; assert(!Universe::_fully_initialized, "called after initialize_vtables"); guarantee(1 &lt;&lt; LogHeapWordSize == sizeof(HeapWord), "LogHeapWordSize is incorrect."); guarantee(sizeof(oop) &gt;= sizeof(HeapWord), "HeapWord larger than oop?"); guarantee(sizeof(oop) % sizeof(HeapWord) == 0, "oop size is not not a multiple of HeapWord size"); TraceTime timer("Genesis", TRACETIME_LOG(Info, startuptime)); JavaClasses::compute_hard_coded_offsets(); // 初始化堆 jint status = Universe::initialize_heap(); if (status != JNI_OK) &#123; return status; &#125; SystemDictionary::initialize_oop_storage(); Metaspace::global_initialize(); // Initialize performance counters for metaspaces MetaspaceCounters::initialize_performance_counters(); CompressedClassSpaceCounters::initialize_performance_counters(); AOTLoader::universe_init(); // Checks 'AfterMemoryInit' constraints. if (!JVMFlagConstraintList::check_constraints(JVMFlagConstraint::AfterMemoryInit)) &#123; return JNI_EINVAL; &#125; // Create memory for metadata. Must be after initializing heap for // DumpSharedSpaces. ClassLoaderData::init_null_class_loader_data(); // We have a heap so create the Method* caches before // Metaspace::initialize_shared_spaces() tries to populate them. Universe::_finalizer_register_cache = new LatestMethodCache(); Universe::_loader_addClass_cache = new LatestMethodCache(); Universe::_pd_implies_cache = new LatestMethodCache(); Universe::_throw_illegal_access_error_cache = new LatestMethodCache(); Universe::_throw_no_such_method_error_cache = new LatestMethodCache(); Universe::_do_stack_walk_cache = new LatestMethodCache();#if INCLUDE_CDS if (UseSharedSpaces) &#123; // Read the data structures supporting the shared spaces (shared // system dictionary, symbol table, etc.). After that, access to // the file (other than the mapped regions) is no longer needed, and // the file is closed. Closing the file does not affect the // currently mapped regions. MetaspaceShared::initialize_shared_spaces(); StringTable::create_table(); &#125; else#endif &#123; SymbolTable::create_table(); StringTable::create_table();#if INCLUDE_CDS if (DumpSharedSpaces) &#123; MetaspaceShared::prepare_for_dumping(); &#125;#endif &#125; if (strlen(VerifySubSet) &gt; 0) &#123; Universe::initialize_verify_flags(); &#125; ResolvedMethodTable::create_table(); return JNI_OK;&#125; initialize_heap 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 文件 /src/hotspot/share/memory/universe.cppjint Universe::initialize_heap() &#123; _collectedHeap = create_heap(); jint status = _collectedHeap-&gt;initialize(); if (status != JNI_OK) &#123; return status; &#125; log_info(gc)("Using %s", _collectedHeap-&gt;name()); ThreadLocalAllocBuffer::set_max_size(Universe::heap()-&gt;max_tlab_size());#ifdef _LP64 if (UseCompressedOops) &#123; // Subtract a page because something can get allocated at heap base. // This also makes implicit null checking work, because the // memory+1 page below heap_base needs to cause a signal. // See needs_explicit_null_check. // Only set the heap base for compressed oops because it indicates // compressed oops for pstack code. if ((uint64_t)Universe::heap()-&gt;reserved_region().end() &gt; UnscaledOopHeapMax) &#123; // Didn't reserve heap below 4Gb. Must shift. Universe::set_narrow_oop_shift(LogMinObjAlignmentInBytes); &#125; if ((uint64_t)Universe::heap()-&gt;reserved_region().end() &lt;= OopEncodingHeapMax) &#123; // Did reserve heap below 32Gb. Can use base == 0; Universe::set_narrow_oop_base(0); &#125; AOTLoader::set_narrow_oop_shift(); Universe::set_narrow_ptrs_base(Universe::narrow_oop_base()); LogTarget(Info, gc, heap, coops) lt; if (lt.is_enabled()) &#123; ResourceMark rm; LogStream ls(lt); Universe::print_compressed_oops_mode(&amp;ls); &#125; // Tell tests in which mode we run. Arguments::PropertyList_add(new SystemProperty("java.vm.compressedOopsMode", narrow_oop_mode_to_string(narrow_oop_mode()), false)); &#125; // Universe::narrow_oop_base() is one page below the heap. assert((intptr_t)Universe::narrow_oop_base() &lt;= (intptr_t)(Universe::heap()-&gt;base() - os::vm_page_size()) || Universe::narrow_oop_base() == NULL, "invalid value"); assert(Universe::narrow_oop_shift() == LogMinObjAlignmentInBytes || Universe::narrow_oop_shift() == 0, "invalid value");#endif // We will never reach the CATCH below since Exceptions::_throw will cause // the VM to exit if an exception is thrown during initialization if (UseTLAB) &#123; assert(Universe::heap()-&gt;supports_tlab_allocation(), "Should support thread-local allocation buffers"); ThreadLocalAllocBuffer::startup_initialization(); &#125; return JNI_OK;&#125; create_heap 123456// 文件 /src/hotspot/share/memory/universe.cppCollectedHeap* Universe::create_heap() &#123; assert(_collectedHeap == NULL, "Heap already created"); return GCConfig::arguments()-&gt;create_heap();&#125; create_heap 12345// 假设是G1垃圾回收器// 文件： /src/hotspot/share/gc/g1/g1Arguments.cppCollectedHeap* G1Arguments::create_heap() &#123; return create_heap_with_policy&lt;G1CollectedHeap, G1CollectorPolicy&gt;();&#125; G1CollectedHeap 的构造方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// 文件 /src/hotspot/share/gc/g1/g1CollectedHeap.cppG1CollectedHeap::G1CollectedHeap(G1CollectorPolicy* collector_policy) : CollectedHeap(), _young_gen_sampling_thread(NULL), _collector_policy(collector_policy), _soft_ref_policy(), _card_table(NULL), _memory_manager("G1 Young Generation", "end of minor GC"), _full_gc_memory_manager("G1 Old Generation", "end of major GC"), _eden_pool(NULL), _survivor_pool(NULL), _old_pool(NULL), _gc_timer_stw(new (ResourceObj::C_HEAP, mtGC) STWGCTimer()), _gc_tracer_stw(new (ResourceObj::C_HEAP, mtGC) G1NewTracer()), _g1_policy(new G1Policy(_gc_timer_stw)), _collection_set(this, _g1_policy), _dirty_card_queue_set(false), _ref_processor_stw(NULL), _is_alive_closure_stw(this), _is_subject_to_discovery_stw(this), _ref_processor_cm(NULL), _is_alive_closure_cm(this), _is_subject_to_discovery_cm(this), _bot(NULL), _hot_card_cache(NULL), _g1_rem_set(NULL), _cr(NULL), _g1mm(NULL), _preserved_marks_set(true /* in_c_heap */), _old_set("Old Set", false /* humongous */, new OldRegionSetMtSafeChecker()), _humongous_set("Master Humongous Set", true /* humongous */, new HumongousRegionSetMtSafeChecker()), _humongous_reclaim_candidates(), _has_humongous_reclaim_candidates(false), _archive_allocator(NULL), _summary_bytes_used(0), _survivor_evac_stats("Young", YoungPLABSize, PLABWeight), _old_evac_stats("Old", OldPLABSize, PLABWeight), _expand_heap_after_alloc_failure(true), _old_marking_cycles_started(0), _old_marking_cycles_completed(0), _in_cset_fast_test() &#123; _workers = new WorkGang("GC Thread", ParallelGCThreads, /* are_GC_task_threads */true, /* are_ConcurrentGC_threads */false); _workers-&gt;initialize_workers(); _verifier = new G1HeapVerifier(this); _allocator = new G1Allocator(this); _heap_sizing_policy = G1HeapSizingPolicy::create(this, _g1_policy-&gt;analytics()); _humongous_object_threshold_in_words = humongous_threshold_for(HeapRegion::GrainWords); // Override the default _filler_array_max_size so that no humongous filler // objects are created. _filler_array_max_size = _humongous_object_threshold_in_words; uint n_queues = ParallelGCThreads; _task_queues = new RefToScanQueueSet(n_queues); _evacuation_failed_info_array = NEW_C_HEAP_ARRAY(EvacuationFailedInfo, n_queues, mtGC); for (uint i = 0; i &lt; n_queues; i++) &#123; RefToScanQueue* q = new RefToScanQueue(); q-&gt;initialize(); _task_queues-&gt;register_queue(i, q); ::new (&amp;_evacuation_failed_info_array[i]) EvacuationFailedInfo(); &#125; // Initialize the G1EvacuationFailureALot counters and flags. NOT_PRODUCT(reset_evacuation_should_fail();) _gc_tracer_stw-&gt;initialize(); guarantee(_task_queues != NULL, "task_queues allocation failure.");&#125; initialize 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204// 文件： /src/hotspot/share/gc/g1/g1CollectedHeap.cppjint G1CollectedHeap::initialize() &#123; os::enable_vtime(); // Necessary to satisfy locking discipline assertions. MutexLocker x(Heap_lock); // While there are no constraints in the GC code that HeapWordSize // be any particular value, there are multiple other areas in the // system which believe this to be true (e.g. oop-&gt;object_size in some // cases incorrectly returns the size in wordSize units rather than // HeapWordSize). guarantee(HeapWordSize == wordSize, "HeapWordSize must equal wordSize"); size_t init_byte_size = collector_policy()-&gt;initial_heap_byte_size(); size_t max_byte_size = collector_policy()-&gt;max_heap_byte_size(); size_t heap_alignment = collector_policy()-&gt;heap_alignment(); // Ensure that the sizes are properly aligned. Universe::check_alignment(init_byte_size, HeapRegion::GrainBytes, "g1 heap"); Universe::check_alignment(max_byte_size, HeapRegion::GrainBytes, "g1 heap"); Universe::check_alignment(max_byte_size, heap_alignment, "g1 heap"); // Reserve the maximum. // When compressed oops are enabled, the preferred heap base // is calculated by subtracting the requested size from the // 32Gb boundary and using the result as the base address for // heap reservation. If the requested size is not aligned to // HeapRegion::GrainBytes (i.e. the alignment that is passed // into the ReservedHeapSpace constructor) then the actual // base of the reserved heap may end up differing from the // address that was requested (i.e. the preferred heap base). // If this happens then we could end up using a non-optimal // compressed oops mode. ReservedSpace heap_rs = Universe::reserve_heap(max_byte_size, heap_alignment); initialize_reserved_region((HeapWord*)heap_rs.base(), (HeapWord*)(heap_rs.base() + heap_rs.size())); // Create the barrier set for the entire reserved region. G1CardTable* ct = new G1CardTable(reserved_region()); ct-&gt;initialize(); G1BarrierSet* bs = new G1BarrierSet(ct); bs-&gt;initialize(); assert(bs-&gt;is_a(BarrierSet::G1BarrierSet), "sanity"); BarrierSet::set_barrier_set(bs); _card_table = ct; // Create the hot card cache. _hot_card_cache = new G1HotCardCache(this); // Carve out the G1 part of the heap. ReservedSpace g1_rs = heap_rs.first_part(max_byte_size); size_t page_size = UseLargePages ? os::large_page_size() : os::vm_page_size(); G1RegionToSpaceMapper* heap_storage = G1RegionToSpaceMapper::create_mapper(g1_rs, g1_rs.size(), page_size, HeapRegion::GrainBytes, 1, mtJavaHeap); os::trace_page_sizes("Heap", collector_policy()-&gt;min_heap_byte_size(), max_byte_size, page_size, heap_rs.base(), heap_rs.size()); heap_storage-&gt;set_mapping_changed_listener(&amp;_listener); // Create storage for the BOT, card table, card counts table (hot card cache) and the bitmaps. G1RegionToSpaceMapper* bot_storage = create_aux_memory_mapper("Block Offset Table", G1BlockOffsetTable::compute_size(g1_rs.size() / HeapWordSize), G1BlockOffsetTable::heap_map_factor()); G1RegionToSpaceMapper* cardtable_storage = create_aux_memory_mapper("Card Table", G1CardTable::compute_size(g1_rs.size() / HeapWordSize), G1CardTable::heap_map_factor()); G1RegionToSpaceMapper* card_counts_storage = create_aux_memory_mapper("Card Counts Table", G1CardCounts::compute_size(g1_rs.size() / HeapWordSize), G1CardCounts::heap_map_factor()); size_t bitmap_size = G1CMBitMap::compute_size(g1_rs.size()); G1RegionToSpaceMapper* prev_bitmap_storage = create_aux_memory_mapper("Prev Bitmap", bitmap_size, G1CMBitMap::heap_map_factor()); G1RegionToSpaceMapper* next_bitmap_storage = create_aux_memory_mapper("Next Bitmap", bitmap_size, G1CMBitMap::heap_map_factor()); _hrm.initialize(heap_storage, prev_bitmap_storage, next_bitmap_storage, bot_storage, cardtable_storage, card_counts_storage); _card_table-&gt;initialize(cardtable_storage); // Do later initialization work for concurrent refinement. _hot_card_cache-&gt;initialize(card_counts_storage); // 6843694 - ensure that the maximum region index can fit // in the remembered set structures. const uint max_region_idx = (1U &lt;&lt; (sizeof(RegionIdx_t)*BitsPerByte-1)) - 1; guarantee((max_regions() - 1) &lt;= max_region_idx, "too many regions"); // The G1FromCardCache reserves card with value 0 as "invalid", so the heap must not // start within the first card. guarantee(g1_rs.base() &gt;= (char*)G1CardTable::card_size, "Java heap must not start within the first card."); // Also create a G1 rem set. _g1_rem_set = new G1RemSet(this, _card_table, _hot_card_cache); _g1_rem_set-&gt;initialize(max_capacity(), max_regions()); size_t max_cards_per_region = ((size_t)1 &lt;&lt; (sizeof(CardIdx_t)*BitsPerByte-1)) - 1; guarantee(HeapRegion::CardsPerRegion &gt; 0, "make sure it's initialized"); guarantee(HeapRegion::CardsPerRegion &lt; max_cards_per_region, "too many cards per region"); FreeRegionList::set_unrealistically_long_length(max_regions() + 1); _bot = new G1BlockOffsetTable(reserved_region(), bot_storage); &#123; HeapWord* start = _hrm.reserved().start(); HeapWord* end = _hrm.reserved().end(); size_t granularity = HeapRegion::GrainBytes; _in_cset_fast_test.initialize(start, end, granularity); _humongous_reclaim_candidates.initialize(start, end, granularity); &#125; // Create the G1ConcurrentMark data structure and thread. // (Must do this late, so that "max_regions" is defined.) _cm = new G1ConcurrentMark(this, prev_bitmap_storage, next_bitmap_storage); if (_cm == NULL || !_cm-&gt;completed_initialization()) &#123; vm_shutdown_during_initialization("Could not create/initialize G1ConcurrentMark"); return JNI_ENOMEM; &#125; _cm_thread = _cm-&gt;cm_thread(); // Now expand into the initial heap size. if (!expand(init_byte_size, _workers)) &#123; vm_shutdown_during_initialization("Failed to allocate initial heap."); return JNI_ENOMEM; &#125; // Perform any initialization actions delegated to the policy. g1_policy()-&gt;init(this, &amp;_collection_set); G1BarrierSet::satb_mark_queue_set().initialize(SATB_Q_CBL_mon, SATB_Q_FL_lock, G1SATBProcessCompletedThreshold, Shared_SATB_Q_lock); jint ecode = initialize_concurrent_refinement(); if (ecode != JNI_OK) &#123; return ecode; &#125; ecode = initialize_young_gen_sampling_thread(); if (ecode != JNI_OK) &#123; return ecode; &#125; G1BarrierSet::dirty_card_queue_set().initialize(DirtyCardQ_CBL_mon, DirtyCardQ_FL_lock, (int)concurrent_refine()-&gt;yellow_zone(), (int)concurrent_refine()-&gt;red_zone(), Shared_DirtyCardQ_lock, NULL, // fl_owner true); // init_free_ids dirty_card_queue_set().initialize(DirtyCardQ_CBL_mon, DirtyCardQ_FL_lock, -1, // never trigger processing -1, // no limit on length Shared_DirtyCardQ_lock, &amp;G1BarrierSet::dirty_card_queue_set()); // Here we allocate the dummy HeapRegion that is required by the // G1AllocRegion class. HeapRegion* dummy_region = _hrm.get_dummy_region(); // We'll re-use the same region whether the alloc region will // require BOT updates or not and, if it doesn't, then a non-young // region will complain that it cannot support allocations without // BOT updates. So we'll tag the dummy region as eden to avoid that. dummy_region-&gt;set_eden(); // Make sure it's full. dummy_region-&gt;set_top(dummy_region-&gt;end()); G1AllocRegion::setup(this, dummy_region); _allocator-&gt;init_mutator_alloc_region(); // Do create of the monitoring and management support so that // values in the heap have been properly initialized. _g1mm = new G1MonitoringSupport(this); G1StringDedup::initialize(); _preserved_marks_set.init(ParallelGCThreads); _collection_set.initialize(max_regions()); return JNI_OK;&#125; reserve_heap 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 文件： /src/hotspot/share/memory/universe.cppReservedSpace Universe::reserve_heap(size_t heap_size, size_t alignment) &#123; assert(alignment &lt;= Arguments::conservative_max_heap_alignment(), "actual alignment " SIZE_FORMAT " must be within maximum heap alignment " SIZE_FORMAT, alignment, Arguments::conservative_max_heap_alignment()); size_t total_reserved = align_up(heap_size, alignment); assert(!UseCompressedOops || (total_reserved &lt;= (OopEncodingHeapMax - os::vm_page_size())), "heap size is too big for compressed oops"); bool use_large_pages = UseLargePages &amp;&amp; is_aligned(alignment, os::large_page_size()); assert(!UseLargePages || UseParallelGC || use_large_pages, "Wrong alignment to use large pages"); // Now create the space. ReservedHeapSpace total_rs(total_reserved, alignment, use_large_pages, AllocateHeapAt); if (total_rs.is_reserved()) &#123; assert((total_reserved == total_rs.size()) &amp;&amp; ((uintptr_t)total_rs.base() % alignment == 0), "must be exactly of required size and alignment"); // We are good. if (UseCompressedOops) &#123; // Universe::initialize_heap() will reset this to NULL if unscaled // or zero-based narrow oops are actually used. // Else heap start and base MUST differ, so that NULL can be encoded nonambigous. Universe::set_narrow_oop_base((address)total_rs.compressed_oop_base()); &#125; if (AllocateHeapAt != NULL) &#123; log_info(gc,heap)("Successfully allocated Java heap at location %s", AllocateHeapAt); &#125; return total_rs; &#125; vm_exit_during_initialization( err_msg("Could not reserve enough space for " SIZE_FORMAT "KB object heap", total_reserved/K)); // satisfy compiler ShouldNotReachHere(); return ReservedHeapSpace(0, 0, false);&#125; JVMInit 初始化虚拟机 1234567891011121314151617181920212223242526272829303132333435363738// 文件：src/java.base/macosx/native/libjli/java_md_macosx.c// MacOSX we may continue in the same threadintJVMInit(InvocationFunctions* ifn, jlong threadStackSize, int argc, char **argv, int mode, char *what, int ret) &#123; if (sameThread) &#123; JLI_TraceLauncher("In same thread\n"); // need to block this thread against the main thread // so signals get caught correctly __block int rslt = 0; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; &#123; NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock: ^&#123; JavaMainArgs args; args.argc = argc; args.argv = argv; args.mode = mode; args.what = what; args.ifn = *ifn; rslt = JavaMain(&amp;args); &#125;]; /* * We cannot use dispatch_sync here, because it blocks the main dispatch queue. * Using the main NSRunLoop allows the dispatch queue to run properly once * SWT (or whatever toolkit this is needed for) kicks off it's own NSRunLoop * and starts running. */ [op performSelectorOnMainThread:@selector(start) withObject:nil waitUntilDone:YES]; &#125; [pool drain]; return rslt; &#125; else &#123; // 会走这个分支 return ContinueInNewThread(ifn, threadStackSize, argc, argv, mode, what, ret); &#125;&#125; ContinueInNewThread 12345678910111213141516171819202122232425262728293031323334353637383940//文件：/src/java.base/share/native/libjli/java.cintContinueInNewThread(InvocationFunctions* ifn, jlong threadStackSize, int argc, char **argv, int mode, char *what, int ret)&#123; /* * If user doesn't specify stack size, check if VM has a preference. * Note that HotSpot no longer supports JNI_VERSION_1_1 but it will * return its default stack size through the init args structure. */ if (threadStackSize == 0) &#123; struct JDK1_1InitArgs args1_1; memset((void*)&amp;args1_1, 0, sizeof(args1_1)); args1_1.version = JNI_VERSION_1_1; ifn-&gt;GetDefaultJavaVMInitArgs(&amp;args1_1); /* ignore return value */ if (args1_1.javaStackSize &gt; 0) &#123; threadStackSize = args1_1.javaStackSize; &#125; &#125; &#123; /* Create a new thread to create JVM and invoke main method */ JavaMainArgs args; int rslt; args.argc = argc; args.argv = argv; args.mode = mode; args.what = what; args.ifn = *ifn; rslt = ContinueInNewThread0(JavaMain, threadStackSize, (void*)&amp;args); /* If the caller has deemed there is an error we * simply return that, otherwise we return the value of * the callee */ return (ret != 0) ? ret : rslt; &#125;&#125; ContinueInNewThread0 1234567891011121314151617181920212223242526272829303132333435// 文件：/src/java.base/macosx/native/libjli/java_md_macosx.c/* * Block current thread and continue execution in a new thread */intContinueInNewThread0(int (JNICALL *continuation)(void *), jlong stack_size, void * args) &#123; int rslt; pthread_t tid; pthread_attr_t attr; pthread_attr_init(&amp;attr); pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); if (stack_size &gt; 0) &#123; pthread_attr_setstacksize(&amp;attr, stack_size); &#125; pthread_attr_setguardsize(&amp;attr, 0); // no pthread guard page on java threads // 另开一个线程去执行java代码；PS：这里是执行java.c 中的 JavaMain方法 if (pthread_create(&amp;tid, &amp;attr, (void *(*)(void*))continuation, (void*)args) == 0) &#123; void * tmp; pthread_join(tid, &amp;tmp); rslt = (int)(intptr_t)tmp; &#125; else &#123; /* * Continue execution in current thread if for some reason (e.g. out of * memory/LWP) a new thread can't be created. This will likely fail * later in continuation as JNI_CreateJavaVM needs to create quite a * few new threads, anyway, just give it a try.. */ rslt = continuation(args); &#125; pthread_attr_destroy(&amp;attr); return rslt;&#125; pthread_create int pthread_create(pthread_t tidp, const pthread_attr_t *attr, (void)(start_rtn)(void), void *arg); 返回值: 若线程创建成功，则返回0。若线程创建失败，则返回出错编号，并且*thread中的内容是未定义的。参数: 第一个参数为指向线程标识符的指针。 第二个参数用来设置线程属性。 第三个参数是线程运行函数的起始地址。 最后一个参数是运行函数的参数。注意事项因为pthread并非Linux系统的默认库，而是POSIX线程库。在Linux中将其作为一个库来使用，因此加上 -lpthread（或-pthread）以显式链接该库。函数在执行错误时的错误信息将作为返回值返回，并不修改系统全局变量errno，当然也无法使用perror()打印错误信息。 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt; void printids(const char *s)&#123; pid_t pid; pthread_t tid; pid = getpid(); tid = pthread_self(); printf("%s pid %u tid %u (0x%x)\n", s, (unsigned int) pid, (unsigned int) tid, (unsigned int) tid);&#125; void *thr_fn(void *arg)&#123; printids("new thread: "); return NULL;&#125; int main(void)&#123; int err; pthread_t ntid; err = pthread_create(&amp;ntid, NULL, thr_fn, NULL); if (err != 0) printf("can't create thread: %s\n", strerror(err)); printids("main thread:"); pthread_join(ntid,NULL); return EXIT_SUCCESS;&#125; 1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169// 文件： /src/java.base/share/native/libjli/java.cint JNICALLJavaMain(void * _args)&#123; JavaMainArgs *args = (JavaMainArgs *)_args; int argc = args-&gt;argc; char **argv = args-&gt;argv; int mode = args-&gt;mode; char *what = args-&gt;what; InvocationFunctions ifn = args-&gt;ifn; JavaVM *vm = 0; JNIEnv *env = 0; jclass mainClass = NULL; jclass appClass = NULL; // actual application class being launched jmethodID mainID; jobjectArray mainArgs; int ret = 0; jlong start = 0, end = 0; RegisterThread(); /* Initialize the virtual machine */ start = CounterGet(); if (!InitializeJVM(&amp;vm, &amp;env, &amp;ifn)) &#123; JLI_ReportErrorMessage(JVM_ERROR1); exit(1); &#125; if (showSettings != NULL) &#123; ShowSettings(env, showSettings); CHECK_EXCEPTION_LEAVE(1); &#125; // show resolved modules and continue if (showResolvedModules) &#123; ShowResolvedModules(env); CHECK_EXCEPTION_LEAVE(1); &#125; // list observable modules, then exit if (listModules) &#123; ListModules(env); CHECK_EXCEPTION_LEAVE(1); LEAVE(); &#125; // describe a module, then exit if (describeModule != NULL) &#123; DescribeModule(env, describeModule); CHECK_EXCEPTION_LEAVE(1); LEAVE(); &#125; if (printVersion || showVersion) &#123; PrintJavaVersion(env, showVersion); CHECK_EXCEPTION_LEAVE(0); if (printVersion) &#123; LEAVE(); &#125; &#125; // modules have been validated at startup so exit if (validateModules) &#123; LEAVE(); &#125; /* If the user specified neither a class name nor a JAR file */ if (printXUsage || printUsage || what == 0 || mode == LM_UNKNOWN) &#123; PrintUsage(env, printXUsage); CHECK_EXCEPTION_LEAVE(1); LEAVE(); &#125; FreeKnownVMs(); /* after last possible PrintUsage */ if (JLI_IsTraceLauncher()) &#123; end = CounterGet(); JLI_TraceLauncher("%ld micro seconds to InitializeJVM\n", (long)(jint)Counter2Micros(end-start)); &#125; /* At this stage, argc/argv have the application's arguments */ if (JLI_IsTraceLauncher())&#123; int i; printf("%s is '%s'\n", launchModeNames[mode], what); printf("App's argc is %d\n", argc); for (i=0; i &lt; argc; i++) &#123; printf(" argv[%2d] = '%s'\n", i, argv[i]); &#125; &#125; ret = 1; /* * Get the application's main class. It also checks if the main * method exists. * * See bugid 5030265. The Main-Class name has already been parsed * from the manifest, but not parsed properly for UTF-8 support. * Hence the code here ignores the value previously extracted and * uses the pre-existing code to reextract the value. This is * possibly an end of release cycle expedient. However, it has * also been discovered that passing some character sets through * the environment has "strange" behavior on some variants of * Windows. Hence, maybe the manifest parsing code local to the * launcher should never be enhanced. * * Hence, future work should either: * 1) Correct the local parsing code and verify that the * Main-Class attribute gets properly passed through * all environments, * 2) Remove the vestages of maintaining main_class through * the environment (and remove these comments). * * This method also correctly handles launching existing JavaFX * applications that may or may not have a Main-Class manifest entry. */ mainClass = LoadMainClass(env, mode, what); CHECK_EXCEPTION_NULL_LEAVE(mainClass); /* * In some cases when launching an application that needs a helper, e.g., a * JavaFX application with no main method, the mainClass will not be the * applications own main class but rather a helper class. To keep things * consistent in the UI we need to track and report the application main class. */ appClass = GetApplicationClass(env); NULL_CHECK_RETURN_VALUE(appClass, -1); /* Build platform specific argument array */ mainArgs = CreateApplicationArgs(env, argv, argc); CHECK_EXCEPTION_NULL_LEAVE(mainArgs); if (dryRun) &#123; ret = 0; LEAVE(); &#125; /* * PostJVMInit uses the class name as the application name for GUI purposes, * for example, on OSX this sets the application name in the menu bar for * both SWT and JavaFX. So we'll pass the actual application class here * instead of mainClass as that may be a launcher or helper class instead * of the application class. */ PostJVMInit(env, appClass, vm); CHECK_EXCEPTION_LEAVE(1); /* * The LoadMainClass not only loads the main class, it will also ensure * that the main method's signature is correct, therefore further checking * is not required. The main method is invoked here so that extraneous java * stacks are not in the application stack trace. */ mainID = (*env)-&gt;GetStaticMethodID(env, mainClass, "main", "([Ljava/lang/String;)V"); CHECK_EXCEPTION_NULL_LEAVE(mainID); /* Invoke main method. */ (*env)-&gt;CallStaticVoidMethod(env, mainClass, mainID, mainArgs); /* * The launcher's exit code (in the absence of calls to * System.exit) will be non-zero if main threw an exception. */ ret = (*env)-&gt;ExceptionOccurred(env) == NULL ? 0 : 1; LEAVE();&#125; 虚拟机的启动 HotSpot VM 启动时JNI_CreateJavaVM方法将执行以下一系列操作。（1）确保只有一个线程调用这个方法并且确保只创建一个HotSpot VM实例。因为HotSpot VM创建的静态数据结构无法再次初始化，所以一旦初始化到达某个确定点后，进程空间里就只能有一个HotSpot VM，在HotSpot VM的开发工程师看来，HotSpot VM启动至此已经是无法逆转了。（2）检查并确保支持当前的JNI版本，初始化垃圾收集日志的输出流。（3）初始化OS模块，如随机数生成器（Random Number Generator）、当前进程id（Current Process id）、高精度计时器（High-Resolution Timer）、内存页尺寸（Memory Page Sizes）、保护页（Guard Pages）。保护页是不可访问的内存页，用作内存访问区域的边界。例如，操作系统常在线程栈顶压入一个保护页以保证引用不会超出栈的边界。（4）解析传入JNI_CreateJavaVM的命令行选项，保存以备将来使用。（5）初始化标准的Java系统属性，例如java.version、java.vendor、os.name等。（6）初始化支持同步、栈、内存和安全点页的模块。（7）加载libzip、libhpi、libjava及libthread等库。（8）初始化并设置信号处理器（Signal Handler）。（9）初始化线程库。（10）初始化输出流日志记录器（Logger）。（11）如果用到Agent库（hprof、jdi），则初始化并启动。（12）初始化线程状态（Thread State）和线程本地存储（Thread Local Storage），它们存储了线程私有数据。（13）初始化部分HotSpot VM全局数据，例如事件日志（Event Log），OS同步原语、perfMemory（性能统计数据内存），以及chunkPool（内存分配器）。（14）至此，HotSpot VM可以创建线程了。创建出来的Java版main线程被关联到当前操作系统线程，只不过还没有添加到已知线程列表中。（15）初始化并激活Java级别的同步。（16）初始化启动类加载器（Bootclassloader）、代码缓存、解释器、JIT编译器、JNI、系统词典（System Dictionary）及universe（一种必备的全局数据结构集）。（17）现在，添加Java主线程到已知线程列表中。检查universe是否正常。创建HotSpot VMThread，它执行HotSpot VM所有的关键功能。同事发出适当的JVMTI事件，报告HotSpot VM当前的状态。（18）加载和初始化以下Java类：java.lang.String、java.lang.System、java.lang.Thread、java.lang.ThreadGroup、java.lang.reflect.Method、java.lang.ref.Finalizer、java.lang.Class以及余下的Java系统类。此时，HotSpot已经初始化完毕并可使用，只是功能还不完备。（19）启动HotSpot VM的信号处理器线程，初始化JIT编译器并启动HotSpot编译代理线程。启动HotSpot VM辅助线程（如监控线程和统计抽样器）。至此，HotSpot VM已功能完备。（20）最后，生成JNIEnv对象返回给调用者，HotSpot则准备响应新的JNI请求。如果HotSpot VM启动过程中发生错误，启动器则调用DestroyJavaVM方法关闭HotSpot VM。如果HotSpot VM启动后执行过程中发生很严重的错误，也会调用DestroyJavaVM方法。 DestroyJavaVM按以下步骤停止HotSpot VM。（1）一直等待，直到只有一个非守护的线程执行，注意此时HotSpot VM仍然可用。（2）调用java.lang.Shutdown.shutdown()，它会调用Java上的shutdown钩子方法，如果finalization-on-exit为true，则运行Java对象的finalizer。（3）运行HotSpot VM上的shutdown钩子（通过JVM_OnExit()注册），停止以下线程：性能分线器、统计数据抽样器、监控线程及垃圾收集器线程。发出状态事件通知JVMTI，然后关闭JVMTI、停止信号线程。（4）调用HotSpot的JavaThread::exit()释放JNI处理块，移除保护页，并将当前线程从已知线程队列中移除。从这时起，HotSpot VM就无法执行任何Java代码了。（5）停止HotSpot VM线程，将遗留的HotSpot VM线程带到安全点并停止JIT编译器线程。（6）停止追踪JNI，HotSpot VM及JVMTI屏障。（7）为哪些仍然以本地代码运行的线程设置标记“vm exited”。（8）删除当前线程。（9）删除或移除所有的输入/输出流，释放PerfMemory（性能统计内存）资源。（10）最后返回到调用者。 参考文章 https://hunterzhao.io/post/2018/02/23/hotspot-explore-startup-process-initialization/]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>虚拟机</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 打包流程]]></title>
    <url>%2Fblog%2F2020%2F06%2F03%2FAndroid%20%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Android 打包流程 打包资源文件，生成R.java文件 使用工具：aapt（The Android Asset Packaing Tool），目录 sdk\build-tools\25.0.0\aapt。 1、填充xml文件中的引用，并编译为二进制文件；同时生成R.java、resource.arse文件； 2、R文件保存资源名称到ResourceID的映射关系。 3、resource.arse文件为ResourceID、资源名称、资源路径的映射关系。 4、压缩图片 处理AIDL文件，生成Java文件 使用工具是：aidl（Android Interface Definition Language），即Android接口描述语言，目录 sdk\build-tools\25.0.0\aidl。 aidl工具解析接口定义文件然后生成相应的Java代码接口供程序调用。如果在项目没有使用到aidl文件，则可以跳过这一步。 编译源码，生成class文件 使用工具是: Java编译器（javac） 项目中所有的Java代码，包括R.java和.aidl文件，都会变Java编译器（javac）编译成.class文件，生成的class文件位于工程中的app/build/intermediates/javac/release/compileReleaseJavaWithJavac目录下。 根据class文件生成Dex文件 使用工具是： dx（dex），工具目录（sdk\build-tools\25.0.0\dx）。 1、将所有的class文件(自己的源码、引用的第三方Jar、aar等) 转换为可供Android系统Dalvik虚拟机执行的classes.dex文件； 2、优点是：dx工具的主要工作是将Java字节码转成 Dalvik字节码、压缩常量池、消除冗余信息等。 打包生成APK文件 使用工具是：apkbuilder，目录 android-sdk/tools，apkbuilder为一个脚本文件，实际调用的是（sdk\tools\lib）文件中的com.android.sdklib.build.ApkbuilderMain类。 1、所有没有编译的资源，如images、assets目录下资源 2、编译过的资源，如dex、res、resource.arse、AndroidManifest.xml文件都会被apkbuilder工具打包到最终的.apk文件中。 对APK文件进行签名 使用工具是Jarsigner, 对上一步生成的APK进行签名。PS：必须被签名才能被安装在设备上。 1、主要是两种签名的keystore，一种是用于调试的debug.keystore，它主要用于调试。另一种就是用于发布正式版本的relese.keystore，需要开发者自己配置。 2、另外还有一种签名文件release.jks文件。 3、jks文件和keystore文件的区别是，前者是Android Studio打包使用的，而后者是Eclipse打包用的。 4、证书生成工具keytool，例如：keytool -list -v -keystore debug.keystore 对签名后的文件进行对齐处理 使用工具是:zipalign，目录 sdk\build-tools\25.0.0\zipalign。 1、对齐的主要过程是将APK包中所有的资源文件距离文件起始偏移为4字节整数倍，这样通过内存映射访问apk文件时的速度会更快。对齐的作用就是减少运行时内存的使用。 参考文章 https://juejin.im/entry/58b78d1b61ff4b006cd47e5b https://juejin.im/post/5cd0046fe51d453aa5635f98]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据加密算法]]></title>
    <url>%2Fblog%2F2020%2F06%2F03%2F%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[加密、解密的定义 加密 就是对原来为 明文 的文件或数据按 某种算法 进行处理，使其成为 不可读 的一段代码，通常称为 “密文”。通过这样的途径，来达到 保护数据 不被 非法人窃取、阅读的目的。 解密 加密 的 逆过程 为 解密，即将该 编码信息 转化为其 原来数据 的过程。 对称加密和非对称加密 对称加密 对称加密算法 是应用较早的加密算法，又称为 共享密钥加密算法。在 对称加密算法 中，使用的密钥只有一个，发送 和 接收 双方都使用这个密钥对数据进行 加密 和 解密。这就要求加密和解密方事先都必须知道加密的密钥。 非对称加密 非对称加密算法，又称为 公开密钥加密算法。它需要两个密钥，一个称为 公开密钥 (public key)，即 公钥，另一个称为 私有密钥 (private key)，即 私钥。 摘要算法 MD5算法 MD5 用的是 哈希函数，它的典型应用是对一段信息产生 信息摘要，以 防止被篡改。严格来说，MD5 不是一种 加密算法 而是 摘要算法。无论是多长的输入，MD5 都会输出长度为 128bits 的一个串 (通常用 16 进制 表示为 32 个字符)。 SHA1、SHA-256算法 SHA1 是和 MD5 一样流行的 消息摘要算法，然而 SHA1 比 MD5 的 安全性更强。对于长度小于 2 ^ 64 位的消息，SHA1 会产生一个 160 位的 消息摘要。基于 MD5、SHA1 的信息摘要特性以及 不可逆 (一般而言)，可以被应用在检查 文件完整性 以及 数字签名 等场景。 SHA2或者SHA-256有256 位，更加安全，但也更加耗时。 另外还有SHA-224、SHA-384、SHA-512等； https://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F HMAC 、MAC算法 HMAC 是密钥相关的 哈希运算消息认证码（Hash-based Message Authentication Code），HMAC 运算利用 哈希算法 (MD5、SHA1 等)，以 一个密钥 和 一个消息 为输入，生成一个 消息摘要 作为 输出。 对称加密算法 DES算法 DES 加密算法是一种 分组密码，以 64 位为 分组对数据 加密，它的 密钥长度 是 56 位，加密解密 用 同一算法。 DES 加密算法是对 密钥 进行保密，而 公开算法，包括加密和解密算法。这样，只有掌握了和发送方 相同密钥 的人才能解读由 DES加密算法加密的密文数据。因此，破译 DES 加密算法实际上就是 搜索密钥的编码。对于 56 位长度的 密钥 来说，如果用 穷举法 来进行搜索的话，其运算次数为 2 ^ 56 次。 3DES 算法 是基于 DES 的 对称算法，对 一块数据 用 三个不同的密钥 进行 三次加密，强度更高。 AES 算法 AES 加密算法是密码学中的 高级加密标准，该加密算法采用 对称分组密码体制，密钥长度的最少支持为 128 位、 192 位、256 位，分组长度 128 位，算法应易于各种硬件和软件实现。这种加密算法是美国联邦政府采用的 区块加密标准。 AES 本身就是为了取代 DES 的，AES 具有更好的 安全性、效率 和 灵活性。 非对称加密算法 RSA算法 RSA 加密算法是目前最有影响力的 公钥加密算法，并且被普遍认为是目前 最优秀的公钥方案 之一。RSA 是第一个能同时用于 加密 和 数字签名 的算法，它能够 抵抗 到目前为止已知的 所有密码攻击，已被 ISO 推荐为公钥数据加密标准。 RSA 加密算法 基于一个十分简单的数论事实：将两个大 素数 相乘十分容易，但想要对其乘积进行 因式分解 却极其困难，因此可以将 乘积 公开作为 加密密钥。 ECC 算法 ECC 也是一种 非对称加密算法，主要优势是在某些情况下，它比其他的方法使用 更小的密钥，比如 RSA 加密算法，提供 相当的或更高等级 的安全级别。不过一个缺点是 加密和解密操作 的实现比其他机制 时间长 (相比 RSA 算法，该算法对 CPU 消耗严重)。 参考文章 https://juejin.im/post/5b48b0d7e51d4519962ea383]]></content>
      <categories>
        <category>加密</category>
      </categories>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java ClassLoader]]></title>
    <url>%2Fblog%2F2020%2F06%2F01%2FJava%20ClassLoader%2F</url>
    <content type="text"><![CDATA[Java 类是如何被加载的 java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型，这就是虚拟机的类加载机制。 https://zhuanlan.zhihu.com/p/60328095 Java 双亲委派 如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。 https://juejin.im/post/5b3cc84ee51d4519873f08da https://zhuanlan.zhihu.com/p/60328095 参考文章 https://zhuanlan.zhihu.com/p/60328095]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 虚拟机编译(JDK编译)]]></title>
    <url>%2Fblog%2F2020%2F06%2F01%2FJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[Java OpenJDK11u 源码下载 源码下载地址： https://hg.openjdk.java.net/jdk-updates/jdk11u 源码编译介绍： https://zhuanlan.zhihu.com/p/101402297 参考文章： https://www.lixiang.red/articles/2020/01/17/1579266236278.html 编译 12345678910111213unzip xxx.zip# cd 进入jdk目录cd doc# 参考building.md 里面的步骤进行编译。# 安装指定版本的jdk, 参考 https://jdk.java.net/archive/bash configure# 构建make images# 运行 java -version 验证 ./build/macosx-x86_64-normal-server-release/images/jdk/bin/java -version# 下载jtreg 测试框架 https://ci.adoptopenjdk.net/view/Dependencies/job/jtreg/# 测试虚拟机 make run-test-tier1 下载c、c++跨平台编辑器CLion CLion 下载地址： https://www.jetbrains.com/clion/ 下载CLion编辑器介绍： https://blog.csdn.net/zwx19921215/article/details/83306119 免费激活：证书失效了 http://blog.jdk5.com/zh/jetbrains-activation-code/ https://www.techgrow.cn/posts/c0477083.html 虚拟机相关研究文章 https://www.zhihu.com/people/wang-xian-sheng-78-39/posts?page=1 虚拟机目录含义 https://hllvm-group.iteye.com/group/topic/26998 源码阅读 dlopen 1234567891011121314151617dlopen函数：功能：打开一个动态链接库包含头文件： #include &lt;dlfcn.h&gt;函数定义： void * dlopen( const char * pathname, int mode );函数描述： 在dlopen()函数以指定模式打开指定的动态连接库文件，并返回一个句柄给调用进程。通过这个句柄来使用库中的函数和类。使用dlclose()来卸载打开的库。mode：分为这两种 RTLD_LAZY 暂缓决定，等有需要时再解出符号 RTLD_NOW 立即决定，返回前解除所有未决定的符号。 RTLD_LOCAL RTLD_GLOBAL 允许导出符号 RTLD_GROUP RTLD_WORLD返回值: 打开错误返回NULL;成功，返回库引用;编译时候要加入 -ldl (指定dl库) dlsym 123函数定义： void* dlsym(void* handle,const char* symbol)该函数在&lt;dlfcn.h&gt;文件中。handle是由dlopen打开动态链接库后返回的指针，symbol就是要求获取的函数的名称，函数 返回值是void*,指向函数的地址，供调用使用。 例子 参考：https://blog.csdn.net/kingkong1024/article/details/8474210]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xposed 简介]]></title>
    <url>%2Fblog%2F2020%2F05%2F30%2FXposed%20%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[xposed 相关介绍 xposed框架 xposed框架需要刷入系统才可以使用。 其实它就是单独搞了一套 xposed 版的 zygote。这个 zygote 会替换系统原生的 zygote。所以，它需要由 XposedInstaller 在 root 之后放到 /system/bin 下。 可以在不修改APK文件的情况下修改程序的运行（修改系统），基于它可以制作出许多功能强大的模块，且在功能不冲突的情况下同时运作。这套框架需要设备解锁了Bootloader方可安装使用[1]（root为解锁Bootloader的充分不必要条件，而xposed安装仅需通过TWRP等第三方Recovery卡刷安装包而不需要设备拥有完整的root权限）。 参考：https://zh.wikipedia.org/wiki/Xposed_(%E6%A1%86%E6%9E%B6) xposed 编译流程详细 https://www.infoq.cn/article/android-in-depth-xposed xposed 源码 https://github.com/rovo89/Xposed Xposed Installer 这是 Xposed 的插件管理和功能控制 APP，也就是说 Xposed 整体管控功能就是由这个 APP 来完成的，它包括启用 Xposed 插件功能，下载和启用指定插件 APP，还可以禁用 Xposed 插件功能等。注意，这个 app 要正常无误得运行必须能拿到 root 权限。 源码： https://github.com/rovo89/XposedInstaller 作者关于xposed 博客： https://forum.xda-developers.com/showthread.php?t=3034811&amp;page=1 XposedBridge 这个项目也是 Xposed 框架，它属于 Xposed 框架的 Java 部分，编译出来是一个 XposedBridge.jar 包。 XposedBridge 源码： https://github.com/rovo89/XposedBridge XposedTools Xposed 和 XposedBridge 编译依赖于 Android 源码，而且还有一些定制化的东西。所以 XposedTools 就是用来帮助我们编译Xposed和XposedBridge的。 虚拟Xposed框架 Virtual Xposed framework 是一套在 Android 高权限模式下运行的框架服务。与Xposed不同，它不需要设备已解锁Bootloader或者已root，但是多数情况下需要修改APK文件来植入框架。其兼容性较差，且当框架本体未开源并商业化的情况时具有较大的危险性、可检测性及不稳定性。[7]其多数特性与Xposed基本相同。最早发布的虚拟Xposed框架为VirtualXposed。 中文说明文档： https://github.com/android-hacker/VirtualXposed/blob/vxp/CHINESE.md 源码地址： https://github.com/android-hacker/VirtualXposed 使用说明 https://sspai.com/post/44447 Xpatch Xpatch是一款免Root实现App加载Xposed插件的工具，可以非常方便地实现App的逆向破解 参考： https://windysha.github.io/2019/07/27/%E5%85%8DRoot-%E5%AE%9E%E7%8E%B0App%E5%8A%A0%E8%BD%BDXposed%E6%8F%92%E4%BB%B6%E7%9A%84%E5%B7%A5%E5%85%B7Xpatch%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/ xpatch 源码 https://github.com/WindySha/Xpatch]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>xposed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dex 脱壳]]></title>
    <url>%2Fblog%2F2020%2F05%2F29%2Fdex%20%E8%84%B1%E5%A3%B3%2F</url>
    <content type="text"><![CDATA[https://www.52pojie.cn/thread-977325-1-1.html fdex2 https://www.cnblogs.com/cxchanpin/p/7374652.html http://www.droidsec.cn/%E4%BB%8Eandroid%E8%BF%90%E8%A1%8C%E6%97%B6%E5%87%BA%E5%8F%91%EF%BC%8C%E6%89%93%E9%80%A0%E6%88%91%E4%BB%AC%E7%9A%84%E8%84%B1%E5%A3%B3%E7%A5%9E%E5%99%A8/ https://github.com/heartbee/Va_Fdex2 https://www.twblogs.net/a/5b8e6ec92b71771883452139 http://www.520monkey.com/archives/920 https://www.cnblogs.com/goodhacker/p/3961045.html https://github.com/KB5201314/ZjDroid 1.android-unpacker 2.Fdex2 3.drizzledumper 4.dexExtractor 5.zjdroid 6.dumpdex 7.android killer 8.IDA pro 9.showJava(安装app反编译) dex 编辑器 010editor]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>dex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android dex、odex等文件格式]]></title>
    <url>%2Fblog%2F2020%2F05%2F29%2FAndroid%20dex%E7%AD%89%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[文件格式含义 Dalvik Dalvik是Google公司自己设计用于Android平台的Java虚拟机。Dalvik虚拟机是Google等厂商合作开发的Android移动设备平台的核心组成部分之一。 Dalvik 经过优化，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个Dalvik 应用作为一个独立的Linux 进程执行。独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭。 参考 https://www.cnblogs.com/sjjg/p/5319038.html ART (Android Runtime) Android Runtime (ART) 是 Android 上的应用和部分系统服务使用的托管式运行时。ART 及其前身 Dalvik 最初是专为 Android 项目打造的。作为运行时的 ART 可执行 Dalvik 可执行文件并遵循 Dex 字节码规范。 ART 和 Dalvik 是运行 Dex 字节码的兼容运行时，因此针对 Dalvik 开发的应用也能在 ART 环境中运作。不过，一些能在 Dalvik 运转的技术，在 ART 上却不能。 ART 包括一个编译器（dex2oat 工具）和一个为启动 Zygote 而加载的运行时 (libart.so)。 参考 https://source.android.google.cn/devices/tech/dalvik?hl=zh-cn dex Dex文件是Android虚拟机下的可执行文件，包含了应用程序所用到所有操作指令和运行时数据。在程序编译过程中，java源文件先被编译成class文件，然后通过dx工具将多个class文件整合为一个dex文件。这样的文件结构使得各个类能够共享数据，充分减少了存储空间，提升了运行效率。 参考 https://blog.csdn.net/qq1084283172/article/details/53584495 dey 优化后的dex的魔数就是dey。 参考 https://blog.csdn.net/pang3510726681/article/details/11610365 odex 其中包含 APK 中已经过 AOT 编译的方法代码。Android O 版本中由 dex2oat 处理 dex 生成。 参考 https://source.android.google.cn/devices/tech/dalvik/configure?hl=zh-cn 在程序第一次被加载的时候，为了提高以后的启动速度和执行效率，Android系统会对这个class.dex文件做一定程度的优化，并生成一个ODEX文件，存放在/data/dalvik-cache目录下。以后再运行这个程序的时候，就只要直接加载这个优化过的ODEX文件就行了，省去了每次都要优化的时间。 不过，这个优化过程会根据不同设备上Dalvik虚拟机的版本、Framework库的不同等因素而不同。在一台设备上被优化过的ODEX文件，拷贝到另一台设备上不一定能够运行。参考 https://blog.csdn.net/roland_sun/java/article/details/47183119 AOT(预先编译) ART 引入了预先编译机制，可提高应用的性能。ART 还具有比 Dalvik 更严格的安装时验证。 在安装时，ART 使用设备自带的 dex2oat 工具来编译应用。此实用工具接受 DEX 文件作为输入，并为目标设备生成经过编译的应用可执行文件。该工具应能够顺利编译所有有效的 DEX 文件。但是，一些后处理工具会生成无效文件，Dalvik 可以接受这些文件，但 ART 无法编译这些文件。 参考 https://source.android.google.cn/devices/tech/dalvik?hl=zh-cn .vdex：其中包含 APK 的未压缩 DEX 代码，以及一些旨在加快验证速度的元数据。Android O 版本中 dex2oat 生成 .art (optional)：其中包含 APK 中列出的某些字符串和类的 ART 内部表示，用于加快应用启动速度。同上。 .oat: oat文件本质上是一个ELF文件，它将OAT文件格式内嵌在ELF文件里。 在oat文件的dymanic section中，导出了三个符号oatdata、oatexec和oatlastword，分别用来描述oatdata和oatexec段加载到内存后的起止地址。 参考 https://www.jianshu.com/p/065e358b9599 包含提取dex工具 elf: 可执行文件格式。例如.so、.a文件都是elf格式的 elf的详解，包含格式、解析等 https://www.cnblogs.com/1024Planet/p/6272620.html https://www.jianshu.com/p/143c717dfcf4 libdvm.so dalvik 虚拟机。 libart.so art虚拟机。art和dalvik都是虚拟机，但是art会对dex做预处理，加快运行时速度。预处理的时机有可能是在安装的时候，也有可能是在安装之后，手机充电的时候。具体： ART运作方式 参考 https://source.android.google.cn/devices/tech/dalvik/configure?hl=zh-cn #####]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于wait、notify]]></title>
    <url>%2Fblog%2F2020%2F05%2F27%2F%E5%85%B3%E4%BA%8Ewait%E3%80%81notify%2F</url>
    <content type="text"><![CDATA[wait、notify、notifyAll 为什么必须与synchronized 配合使用。 synchronized(obj){} 表示持有当前obj对象的锁，在此线程的这一代码块结束之前，1、其他线程不能进入这段代码块；2、其他线程也不能在任何地方持有obj的对象锁，即不能进入另外一处代码中的synchronized(obj){}代码块。 obj.wait 意思是放弃当前对象的锁并堵塞线程，线程挂起。既然要放弃锁，必须先持有锁。持有锁的语法为synchronized(obj); obj.notify 、obj.notifyAll，notify表示根据算法唤醒一个线程竞争锁；notifyAll唤醒所有线程竞争锁。当前线程如果想要唤醒其他线程去竞争对象锁，必须自己持有该对象锁，并很快会释放。 反例：如果自己不持有obj对象锁，却唤醒其他线程去竞争obj对象锁。假如这个时候有某一个线程正持有obj对象锁，并且在执行一个耗时的操作。这种情况唤醒是没有意义的，不会有线程可以竞争到obj对象锁。 故，必须当前线程自己先竞争到obj对象锁，然后再去唤醒其他线程。 wait、sleep、yield 都可以让当前线程堵塞 都可以堵塞指定时间 wait、sleep、join 都可以被中断。或者说只有当线程处于3个状态的时候。调用改线程的interrupt()方法才会抛中断异常。 wait 表示当前线程释放对象锁，让其他线程有机会获取锁。 sleep、yield 侧重于让当前线程释放CPU资源，让其他线程有更多机会执行。 参考文章： https://www.cnblogs.com/huojg-21442/p/7119895.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[I/O的五中模式]]></title>
    <url>%2Fblog%2F2020%2F05%2F27%2FI%3AO%E7%9A%845%E4%B8%AD%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[五种I/O模式 blocking IO - 阻塞IO nonblocking IO - 非阻塞IO IO multiplexing - IO多路复用 signal driven IO - 信号驱动IO asynchronous IO - 异步IO I/O模型的异同点 以network IO中的read读操作为切入点，一般情况下一次网络IO读操作会涉及: 两个系统对象： a、用户进程(线程)Process； b、内核对象kernel; 两个处理阶段： a、 Waiting for the data to be ready - 等待数据准备好 b、 Copying the data from the kernel to the process - 将数据从内核空间的buffer拷贝到用户空间进程的buffer IO模型的异同点就是区分在这两个系统对象、两个处理阶段的不同上。 阻塞IO 用户进程向内核对象请求数据，如果内核对象数据没准备好，则用户进程一直等下去，直到内核将数据准备好，并且复制到用户进程。即直到a、b、两个阶段完成之后结束堵塞。 非堵塞IO 实际上就是用户进程不断轮寻，看内核进程的数据是否准备好，当然第二阶段(kernel将数据copy到自己的buffer)用户进程是需要等待的。即 阶段a不堵塞，有用户轮询；阶段b堵塞。 多路复用IO IO多路复用，就是我们熟知的select、poll、epoll模型。在IO多路复用的时候，process在两个处理阶段都是单独block住等待的。初看好像IO多路复用没什么用，其实select、poll、epoll的优势在于可以以较少的代价来同时监听处理多个IO。 异步IO a阶段调用后立即返回结果给用户进程，没有堵塞；b阶段结束后通知用户进程，也不堵塞用户进程。 Object 的wait 、notify 与 nativePollOnce、nativeWake的区别 wait、notify 基于 Linux futex 调用 Futex，Fast Userspace muTEXes，作为linux下的一种快速同步（互斥）机制。 nativePollOnce、nativeWake 基于epoll wait基于对象，一般用于单个进程的线程之间； nativePollOnce 基于文件描述符，通常可以用于多进程、多线程。 参考文章 https://www.jianshu.com/p/97e6e6c981b6 https://www.cnblogs.com/jiy-for-you/p/11707356.html https://www.cnblogs.com/bbqzsl/p/6763711.html https://blog.csdn.net/mitushutong11/article/details/51336136]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>I/O</tag>
        <tag>Handle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 处理 Excel]]></title>
    <url>%2Fblog%2F2020%2F04%2F05%2Fpython%20%E5%A4%84%E7%90%86Excel%2F</url>
    <content type="text"><![CDATA[安装python 插件 sudo pip3 install xlrd xlwt 123456789101112131415161718192021222324252627# 打开读文件data = xlrd.open_workbook('ljs.xlsx') # 打开写文件 workbook = xlwt.Workbook(encoding = 'ascii') for i in range(0,5): # 读取第i个sheet表格 table = data.sheet_by_index(i) names = data.sheet_names() # 第i个表格的名字 name = names[i] # 创建一个表格 worksheet = workbook.add_sheet(name) for row in range(table.nrows): for col in range(table.ncols): if row &gt;= 0 and col &gt;= 0: # 获取第row、col单元的值 content = table.cell(row, col).value if col == 9: index = content.rfind("&gt;") if index &gt; -1: content = content[index+1:] print("row %d col %d" % (row, col)) # 写入到第row、col单元 worksheet.write(row, col, content) workbook.save('ljs_copy.xlsx') 参考文章 https://www.cnblogs.com/mrljc/p/3715783.html https://www.cnblogs.com/tynam/p/11204895.html]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派Nginx4b + PHP7.3]]></title>
    <url>%2Fblog%2F2020%2F03%2F29%2F%E6%A0%91%E8%8E%93%E6%B4%BENginx4b%2BPHP7.3%2F</url>
    <content type="text"><![CDATA[安装Nginx sudo apt-get install nginx 安装PHP7.3 sudo apt-get install php Nginx 环境配置 nginx.conf 文件配置 123# 修改导入的文件include /etc/nginx/sites-enabled/*.conf;#include /etc/nginx/sites-enabled/*; sites-enabled/default文件配置 12345678910111213141516171819202122232425262728# 目录/etc/nginx/sites-enabled/default# 首先备份默认配置文件；PS：sites-enabled/default 与 sites-available/default文件为同一份。cp default my.conf# 尝试填入下面的规则location / &#123; try_files $uri $uri/ /index.php?$query_string; #index index.html index.htm index.php; autoindex on; fastcgi_intercept_errors on; #include snippets/fastcgi-php.conf; # 从php-fpm 的 www.conf配置文件中获取 fastcgi_pass unix:/run/php/php7.3-fpm.sock; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125; location ~ \.php$ &#123; #try_files $uri = 404; include snippets/fastcgi-php.conf; fastcgi_pass unix:/run/php/php7.3-fpm.sock; #fastcgi_pass 127.0.0.1:9000; #fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125; 配置php-fpm 123# 路径 /etc/php/7.3/fpm/pool.d/www.conf# 找到listen 对应的 *.sock文件；删除前面的';' listen = /run/php/php7.3-fpm.sock 使用CI框架3.10.2； CI框架需要特别注意文件大小写，如果大小写不正确可能导致404 启动服务命令 12345678910#开启nginxsudo nginx# 重启 ngsudo nginx -s reload# 重启php-fpmsudo /etc/init.d/php7.3-fpm restart# 查看日志systemctl status php7.3-fpm.service# 服务器日志路径/var/log/nginx/ 参考文章 1、https://www.cnblogs.com/jpfss/p/10418150.html 2、https://baijiahao.baidu.com/s?id=1642243866657041522&amp;wfr=spider&amp;for=pc 3、https://zhuanlan.zhihu.com/p/39785392 4、https://www.runoob.com/w3cnote/linux-check-port-usage.html]]></content>
      <categories>
        <category>Raspberry</category>
      </categories>
      <tags>
        <tag>raspberry</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android gradle plugin]]></title>
    <url>%2Fblog%2F2020%2F03%2F12%2FAndroid%20gradle%20plugin%2F</url>
    <content type="text"><![CDATA[方式一、直接在app下面build.gradle 中编辑1234567891011121314//使用插件apply plugin: CustomPlugin//自定义插件：实现Plugin类接口，重写apply方法class CustomPlugin implements Plugin&lt;Project&gt; &#123; @Override void apply(Project project) &#123; project.task(&apos;CustomPluginTask&apos;) &#123; doLast &#123; println &quot;大家好,我是一个自定义插件，在这里写下你的具体功能&quot; &#125; &#125; &#125;&#125; 方式二、创建本地插件Module 工程下面创建文件夹buildSrc buildSrc下面创建空文件build.gradle 创建src目录，其中内容与方式三相同。 插件的使用方式，直接在app的build.gradle 加入，下面语句 1apply plugin: &apos;com.pa.gradleplugin&apos; 测试插件是否集成成功 12// testTask 为在 PluginImpl.groovy文件中定义的任务./gradlew testTask 方式三、创建独立的gradle 插件工程创建Android 项目，添加Android Library module ，具体参考 https://www.jianshu.com/p/af2b0a43133f 删除部分用不到的文件、文件夹 删除main下面的java、res目录 删除AndroidManifest.xml 文件 删除混淆文件 修改插件文件 修改新建module的build.gradle 文件 12345678910111213141516171819202122232425apply plugin: 'groovy'apply plugin: 'maven'dependencies &#123; implementation gradleApi() implementation localGroovy()&#125;repositories &#123; mavenCentral()&#125;uploadArchives &#123; repositories &#123; mavenDeployer &#123; //设置插件的GAV参数 pom.groupId = 'com.pa.gradleplugin'//你的包名 pom.artifactId = 'myPlugin' pom.version = '1.0.0'//版本号 //文件发布到下面目录 ../是父目录 repository(url: uri('../repo')) &#125; &#125;&#125; 参考：https://www.jianshu.com/p/af2b0a43133f 增加部分插件相关的文件 新建groovy目录，在groovy目录下，新建一个包（包名随意），包内新建一个文件，必须以.groovy作为后缀名（文件名随意），这里起名为PluginImpl.groovy main下面新建resources目录，在resources目录下新建一个META-INF文件夹，在META-INF文件夹下新建一个gradle-plugins文件夹，在gradle-plugins里创建一个.properties文件,他的文件名必须是上面提到的那个包名 12// 文件 com.pa.plugin.properties implementation-class=com.pa.plugin.PluginImpl 执行uploadArchives命令发布插件到本地 123执行命令./gradlew uploadArchives会生成repo的目录 使用本地插件 配置工程目录下build.gradle文件 12345678910111213141516171819202122232425262728293031// Top-level build file where you can add configuration options common to all sub-projects/modules.buildscript &#123; repositories &#123; google() jcenter() maven &#123;//本地Maven仓库地址 url uri(&apos;./repo&apos;) &#125; &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:3.5.3&apos; classpath &apos;com.pa.plugin:myPlugin:1.0.0&apos; // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125;allprojects &#123; repositories &#123; google() jcenter() &#125;&#125;task clean(type: Delete) &#123; delete rootProject.buildDir&#125; app Module的build.gradle文件中引用 插件定义的任务 1apply plugin: &apos;com.pa.plugin&apos; 执行PluginImpl.groovy文件中定义的任务 1./gradlew testTaskPlugin 使用nexus搭建本地的代码仓库，模拟jcenter 下载nexus工具 nexus 下载地址 https://help.sonatype.com/repomanager2/download 启动nexus 12cd /Users/xxx/tools/nexus-2.14.16-01-bundle/nexus-2.14.16-01/bin./nexus start 在浏览器打开nexus页面 1http://localhost:8081/nexus/#view-repositories 在插件Module的build.gradle中添加配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091apply plugin: &apos;signing&apos;// 获取仓库urldef getRepositoryUrl() &#123; return &quot;http://localhost:8081/nexus/content/repositories/Maven/&quot;&#125;def siteUrl = &apos;https://github.com/zubao&apos;def gitUrl = &apos;https://github.com/zubao&apos;configurations &#123; deployerJars&#125;// 判断版本是Release or Snapshotsdef isReleaseBuild() &#123; return true&#125;// 进行数字签名signing &#123; // 当 发布版本 &amp; 存在&quot;uploadArchives&quot;任务时，才执行 required &#123; isReleaseBuild() &amp;&amp; gradle.taskGraph.hasTask(&quot;uploadArchives&quot;) &#125; sign configurations.archives&#125;// 生成javadoc.jartask androidJavadocsJar(type: Jar, dependsOn: javadoc) &#123; // 指定文档名称 classifier = &apos;javadoc&apos; from javadoc.destinationDir&#125;// 生成sources.jartask androidSourcesJar(type: Jar) &#123; classifier = &apos;sources&apos; from sourceSets.main.allSource&#125;// 产生相关配置文件的任务artifacts &#123; archives androidSourcesJar archives androidJavadocsJar&#125;uploadArchives &#123; repositories &#123; mavenDeployer &#123; beforeDeployment &#123; MavenDeployment deployment -&gt; signing.signPom(deployment) &#125; pom.version = &quot;1.0.0&quot; pom.artifactId = &quot;myPlugin&quot; pom.groupId = &quot;com.pa.plugin&quot; repository(url: getRepositoryUrl()) &#123; authentication(userName: &quot;admin&quot;, password: &quot;admin123&quot;) // maven授权信息 &#125; // （非必须）库生成的pom.xml文件内容 pom &#123; project &#123; packaging &apos;jar&apos; name &apos;The official Android SDK Plugin for SkyEye Analytics.&apos; url siteUrl licenses &#123; license &#123; name &apos;The Apache Software License, Version 2.0&apos; url &apos;http://www.apache.org/licenses/LICENSE-2.0.txt&apos; &#125; &#125; developers &#123; developer &#123; id &apos;zubao&apos; name &apos;wang li&apos; email &apos;lipeil4195@gmail.com&apos; &#125; &#125; scm &#123; connection gitUrl developerConnection gitUrl url siteUrl &#125; &#125; &#125; &#125; &#125;&#125; 发布到nexus 1./gradlew uploadArchives 使用nexus仓库的文件, 替换本地仓库地址为nexus地址，就可以切换插件 12345678910111213141516171819202122232425buildscript &#123; repositories &#123; google() jcenter() maven &#123;//本地Maven仓库地址 // url uri(&apos;./repo&apos;) url uri(&apos;http://localhost:8081/nexus/content/repositories/Maven/&apos;) &#125; &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:3.5.3&apos; classpath &apos;com.pa.plugin:myPlugin:1.0.0&apos; &#125;&#125;allprojects &#123; repositories &#123; google() jcenter() &#125;&#125;task clean(type: Delete) &#123; delete rootProject.buildDir&#125; 参考文章 https://juejin.im/post/5a51e44b518825733e604764 发布到jcenter 注册bintray账号 https://bintray.com/ 注册建议使用github账号。 发布流程： https://www.jianshu.com/p/47ebb159836c 发布准备, 使用github账号登录bintray，进入Edit Profile 获取api key 配置build.gradle 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128// 发布到jcenterapply plugin: &apos;com.jfrog.bintray&apos;apply plugin: &apos;maven-publish&apos;apply plugin: &apos;java&apos;version = &apos;1.0.0&apos;project.archivesBaseName = &quot;myPlugin&quot;task javadocJar(type: Jar, dependsOn: javadoc) &#123; classifier = &apos;javadoc&apos; from javadoc.destinationDir&#125;task sourceJar(type: Jar) &#123; classifier = &apos;sources&apos; from sourceSets.main.allSource&#125;ext &#123; pomFilePath = &quot;$&#123;project.buildDir.absolutePath&#125;/tmp/pom.xml&quot; pomFile = file(pomFilePath)&#125;configurations &#123; pom&#125;artifacts &#123; archives jar archives sourceJar archives javadocJar if (pomFile.exists()) &#123; pom pomFile &#125;&#125;task signJars(type: Sign, dependsOn: [jar, javadocJar, sourceJar]) &#123; sign configurations.archives&#125;task signPom(type: Sign) &#123; sign configurations.pom&#125;if (project.ext.pomFile.exists()) &#123; task preparePublication(dependsOn: [signJars, signPom])&#125; else &#123; task preparePublication(dependsOn: signJars)&#125;def getSignatureFiles = &#123; def allFiles = project.tasks.signJars.signatureFiles.collect&#123;it&#125; def signedSources = allFiles.find&#123; it.name.contains(&apos;-sources&apos;) &#125; def signedJavadoc = allFiles.find&#123; it.name.contains(&apos;-javadoc&apos;) &#125; def signedJar = (allFiles - [signedSources, signJars])[0] return [ [archive: signedSources, classifier: &apos;sources&apos;, extension: &apos;jar.asc&apos;], [archive: signedJavadoc, classifier: &apos;javadoc&apos;, extension: &apos;jar.asc&apos;], [archive: signedJar, classifier: &apos;null&apos;, extension: &apos;jar.asc&apos;] ]&#125;def getPomSignature = &#123; return project.tasks.signPom.signatureFiles.collect&#123; it &#125;[0]&#125;def siteUrl = &apos;https://github.com/zubao/plugin&apos;def gitUrl = &apos;https://github.com/zubao/plugin.git&apos;def issueUrl = &apos;https://github.com/zubao/plugin/issues&apos;group = &quot;com.pa.plugin&quot;install &#123; repositories.mavenInstaller &#123; pom &#123; project &#123; packaging &apos;jar&apos; name &apos;The official Android SDK Plugin for SkyEye Analytics.&apos; url siteUrl licenses &#123; license &#123; name &apos;The Apache Software License, Version 2.0&apos; url &apos;http://www.apache.org/licenses/LICENSE-2.0.txt&apos; &#125; &#125; developers &#123; developer &#123; id &apos;zubao&apos; name &apos;wang li&apos; email &apos;lipeil4195@gmail.com&apos; &#125; &#125; scm &#123; connection gitUrl developerConnection gitUrl url siteUrl &#125; &#125; &#125; &#125;&#125;Properties properties = new Properties()properties.load(project.rootProject.file(&apos;local.properties&apos;).newDataInputStream())bintray &#123; user = &apos;zubao&apos; key = &apos;xxx api key&apos; println user println key configurations = [&apos;archives&apos;] pkg &#123; userOrg = &apos;zubao&apos; repo = &quot;Maven&quot; name = &quot;myPlugin&quot; desc = &apos;The official Android SDK Plugin for plugin.&apos; websiteUrl = siteUrl vcsUrl = gitUrl issueTrackerUrl = issueUrl licenses = [&quot;Apache-2.0&quot;] labels = &apos;Groovy&apos; publicDownloadNumbers = true publish = true &#125;&#125; 将项目上传到github，jcenter只支持发布开源项目。(疑) 如果上传到bintray失败，多尝试几次 如果上传到bintray之后，进入package 详情，看不到Add to jcenter 的按钮，可以重新注册一个账号试试 使用jcenter仓库，只需要替换上面nexus的url就行。 发布到jcenter流程参考 https://www.jianshu.com/p/a58f8d52448d https://www.jianshu.com/p/47ebb159836c github地址 https://github.com/zubao/PluginTest 编写gradle 插件的3中方式 https://juejin.im/post/5cce895f51882541e27b0cae nexus 使用说明 https://juejin.im/post/5a51e44b518825733e604764 https://blog.csdn.net/doris_d/article/details/88891833]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>plugin</tag>
        <tag>gradle</tag>
        <tag>nexus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 硬件参数默认值]]></title>
    <url>%2Fblog%2F2020%2F03%2F12%2FAndroid%20%E7%A1%AC%E4%BB%B6%E5%8F%82%E6%95%B0%20%E9%BB%98%E8%AE%A4%E5%80%BC%2F</url>
    <content type="text"><![CDATA[- Mac 地址默认值 00：09：4c：11：22：33 如果wifi在本次开机期间从来没有打开过，返回的mac地址就可能是上面那个。 cat /sys/class/net/wlan0/address 02:00:00:00:00:00 android 默认mac地址值]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Adb 远程连接]]></title>
    <url>%2Fblog%2F2020%2F02%2F20%2Fadb%20%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[获取手机IP地址 连接usb线，使用adb shell 进入手机命令行，运行ifconfig命令查询 手机上安装命令行工具，在工具中运行ifconfig查询 通过wifi助手查询 编写程序，Runtime 运行 ifconfig 查询 通过抓包工具查看源IP查询。 adb 无线连接手机 adb usb 重置 adb tcpip 5555设置端口 adb devices 列出当前连接的设备 adb connect 192.168.1.112:5555 连接远程设备 adb disconnect 192.168.1.112:5555 断开连接 adb -s 192.168.1.112:5555 shell 远程进入设备shell]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>adb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android apk代码注入]]></title>
    <url>%2Fblog%2F2020%2F02%2F11%2FAndroid%20APK%20%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[准备工具 apktool https://ibotpeaches.github.io/Apktool/ 去官网下载最新的apktool jar文件 jadx 用来反编译apk文件，查看class、smali文件 创建keystore证书 keytool -genkey -alias zemo -keyalg RSA -validity 20000 -keystore zemo.keystore 开始代码注入 解压缩apk文件 1java -jar apktool_2.4.1.jar d app-release.apk 修改smail文件 重新打包apk文件 1java -jar apktool_2.4.1.jar b app-release/ -o app-release.rb.apk 遇到 No resource identifier found for attribute ‘keyboardNavigationCluster’ in package ‘android’ 1删除 /Users/xxx/Library/apktool/framework/1.apk 文件 重新签名 1jarsigner -verbose -keystore zemo.keystore -signedjar app-release.rb.signed.apk app-release.papd.rb.apk zemo -storepass 123456 -keypass 123456 使用jadx 逆向重新签名的apk，查看修改是否正确。 一般apk会有签名校验，搜索签名相关的关键字，找到签名校验的代码，删除即可。 有时候注入代码过多可能会出现失败，将代码分到其他smali文件夹就好。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android ANR]]></title>
    <url>%2Fblog%2F2020%2F01%2F19%2FAndroid%20ANR%2F</url>
    <content type="text"><![CDATA[ANR类型,出现ANR的一般有以下几种类型： 1:KeyDispatchTimeout（常见） input事件在5S内没有处理完成发生了ANR。 logcat日志关键字：Input event dispatching timed out 2:BroadcastTimeout 前台Broadcast：onReceiver在10S内没有处理完成发生ANR。 后台Broadcast：onReceiver在60s内没有处理完成发生ANR。 logcat日志关键字：Timeout of broadcast BroadcastRecord 3:ServiceTimeout 前台Service：onCreate，onStart，onBind等生命周期在20s内没有处理完成发生ANR。 后台Service：onCreate，onStart，onBind等生命周期在200s内没有处理完成发生ANR logcat日志关键字：Timeout executing service 4：ContentProviderTimeout ContentProvider 在10S内没有处理完成发生ANR。 logcat日志关键字：timeout publishing content providers ANR出现的原因 1:主线程频繁进行耗时的IO操作：如数据库读写 2:多线程操作的死锁，主线程被block； 3:主线程被Binder 对端block； 4:System Server中WatchDog出现ANR； 5:service binder的连接达到上线无法和和System Server通信 6:系统资源已耗尽（管道、CPU、IO） trace信息需要了解几点： traces中都是按照进程去进行的，会有pid提示。 当一个线程占有一个锁的时候，会打印-locked&lt;0xxxxxxx&gt; 当该线程正在等待别的线程释放该锁，会打印waiting to lock &lt;0xxxxxx&gt; 如果代码中有wait()调用的话，首先是locked，然后会打印waiting on &lt;0xxxxxx&gt; 参考文章： https://maoao530.github.io/2017/02/21/anr-analyse/ https://juejin.im/post/5be698d4e51d452acb74ea4c]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>anr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop、Spark相关概念]]></title>
    <url>%2Fblog%2F2020%2F01%2F17%2FHadoop%E3%80%81Spark%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[Hadoop 相关概念 Apache Hadoop是一款支持数据密集型分布式应用程序并以Apache 2.0许可协议发布的开源软件框架。 它支持在商品硬件构建的大型集群上运行的应用程序。Hadoop是根据谷歌公司发表的MapReduce和Google文件系统的论文自行实现而成。所有的Hadoop模块都有一个基本假设，即硬件故障是常见情况，应该由框架自动处理。 https://zh.wikipedia.org/wiki/Apache_Hadoop Apache Hadoop“平台”包括Hadoop内核、MapReduce、Hadoop分布式文件系统（HDFS）以及一些相关项目，有Apache Hive和Apache HBase等等。 MapReduce：分布式计算，是Google提出的一个软件架构，用于大规模数据集（大于1TB）的并行运算。 Map (映射): 一个映射函数就是对一些独立元素组成的列表的每一个元素进行指定的操作。 比如，有人发现所有学生的成绩都被高估了一分，他可以定义一个“减一”的映射函数，用来修正这个错误。事实上，每个元素都是被独立操作的，而原始列表没有被更改，因为这里创建了一个新的列表来保存新的答案。这就是说，Map操作是可以高度并行的，这对高性能要求的应用以及并行计算领域的需求非常有用。 Reduce(归纳): 归纳操作指的是对一个列表的元素进行适当的合并 继续看前面的例子，如果有人想知道班级的平均分该怎么做？他可以定义一个归纳函数，通过让列表中的奇数（odd）或偶数（even）元素跟自己的相邻的元素相加的方式把列表减半，如此递归运算直到列表只剩下一个元素，然后用这个元素除以人数，就得到了平均分。虽然他不如映射函数那么并行，但是因为归纳总是有一个简单的答案，大规模的运算相对独立，所以归纳函数在高度并行环境下也很有用。 HDFS(Hadoop Distributed File System 分布式文件系统):是指被设计成适合运行在通用硬件(commodity hardware)上的分布式文件系统 https://baike.baidu.com/item/HDFS HDFS是一个高度容错性的系统，适合部署在廉价的机器上。HDFS能提供高吞吐量的数据访问，非常适合大规模数据集上的应用。 YARN: 分布式资源管理 https://wiki.jikexueyuan.com/project/hadoop/node-manager.html Spark Hbase(Hadoop database) Hbase是一种在Hadoop之上的NoSQL 的Key/vale数据库 Hbase非常适合用来进行大数据的实时查询 Hive Hive是Hadoop数据仓库，严格来说，不是数据库，主要是让开发人员能够通过SQL来计算和处理HDFS上的结构化数据。 通过元数据来描述Hdfs上的结构化文本数据，通俗点来说，就是定义一张表来描述HDFS上的结构化文本，包括各列数据名称，数据类型是什么等，方便我们处理数据，当前很多SQL ON Hadoop的计算引擎均用的是hive的元数据，如Spark SQL、Impala等； Hive是一种类SQL的引擎，并且运行MapReduce任务 Hive适合用来对一段时间内的数据进行分析查询 参考文章 https://juejin.im/post/5cc3db50f265da03a436d7bd (hive hbase 区别) https://www.cnblogs.com/justinzhang/p/4273470.html]]></content>
      <categories>
        <category>hadoop</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派4Spark环境配置]]></title>
    <url>%2Fblog%2F2020%2F01%2F16%2F%E6%A0%91%E8%8E%93%E6%B4%BE4%20Spark%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Java 环境配置 安装java 12345678910pi@raspberrypi:~ $ sudo apt-get purge openjdk-8-jre-headlesspi@raspberrypi:~ $ sudo apt-get install openjdk-8-jre-headlesspi@raspberrypi:~ $ sudo apt-get install openjdk-8-jrepi@raspberrypi:~ $ java -version # 或者试试这个sudo apt-get install default-jdk# 或者去官网下载https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html Java环境变量配置 1 或者使用SDKMAN 123# 安装sdkman https://sdkman.io/pi@raspberrypi:~ $ curl -s "https://get.sdkman.io" | bash# Scala 环境配置 Mac 或者 树莓派 上安装Scala 1234# Macbrew install scala# Mac 或者其他 平台sdk install scala 12345678910111213141516# 官网下载scala-2.13.1.tgz(可执行文件)； scala-2.13.1.tar.gz(源码)# 如果是树莓派scp scala-2.13.1.tgz pi@192.168.1.1:/home/pi # 解压缩sudo tar -zvxf scala-2.13.1.tgz -C /usr/local/cd /usr/localsudo mv scala-2.13.1 scala# 配置环境变量vim .bash_profile# for scalaSCALA_HOME=/usr/local/scalaPATH=$PATH:$SCALA_HOME/binexport SCALA_HOME PATH# 验证scala -version sbt 安装 安装 sdkman 1pi@raspberrypi:~ $ curl -s "https://get.sdkman.io" | bash 通过sdkman 安装 sbt 1sdk install sbt sbt 安装验证 12345678910111213# 创建工作目录mkdir sbtworkspacecd sbtworkspace# 创建新目录，比较耗时 结束提示输入项目名称，例如hellosbt new scala/hello-world.g8# 进入工程目录 cd hello# 构建项目 (比较耗时)sbt# 运行项目run# 持续运行项目(修改保存之后会自动运行)~run 下载Apache Spark 安装pySpark，如果使用python 可以直接这么安装，否则先下载安装包，手动安装 1pip install pyspark. spark压缩包安装 123sudo tar -zvxf spark-3.0.0-preview2-bin-hadoop2.7.tgz -C /usr/local/cd /usr/localsudo mv spark-3.0.0-preview2-bin-hadoop2.7.tgz spark Spark 环境配置 12345678# .bashrc 或者 .bash_profile 中添加# spark envSPARK_HOME=/usr/local/sparkexport PATH=$PATH:$SPARK_HOME/bin# 配置生效source .bashrc|.bash_profile# 验证是否配置成功spark-shell scala 安装参考文档 https://blog.csdn.net/danlei94/article/details/78082131 scala 官网 https://www.scala-lang.org/download/ sbt 文档 sbt 官方文档 https://www.scala-sbt.org/1.x/docs/Installing-sbt-on-Linux.html sbt 中文文档 https://wiki.jikexueyuan.com/project/sbt-getting-started/running.html spark文档 spark 中文文档 http://doc.codingdict.com/spark/25/ spark 下载地址 http://spark.apache.org/downloads.html (可能需要多尝试几次) 参考文章 https://blog.csdn.net/danlei94/article/details/78082131]]></content>
      <categories>
        <category>Raspberry</category>
      </categories>
      <tags>
        <tag>spark</tag>
        <tag>raspberry</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派开机自动发邮件]]></title>
    <url>%2Fblog%2F2020%2F01%2F14%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E5%BC%80%E5%90%AF%E8%87%AA%E5%8A%A8%E5%8F%91%E9%82%AE%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[安装mutt、msmtp mutt ：是一个linux下的邮件程序，mutt 类似文件管理器，不过它管理的是邮件 msmtp ：是linux 下一个非常简单易用的smtp客户端 1234sudo apt-get install mutt # 如果失败sudo apt-get updatesudo apt-get install msmtp 配置mutt、msmtp环境 配置msmtp，在用户跟目录创建.msmtprc文件 1234567891011vim .msmtprcaccount defaulthost smtp.126.comfrom l5@126.comauth logintls offuser l5password L5 (授权码)logfile ~/.mstmp.log# 申请126 邮箱，去设置获取授权码 host 表示你的游戏的SMTP服务器地址 from 发件人邮箱地址 user 发件人邮箱地址 password 这里是邮箱的明文密码 logfile 这里是日志文件路径，发送邮件后程序会将日志写入这个文件。 测试msmtp 123456# 输入如下命令，测试msmtpmsmtp -d lipeil4195@126.comSubject:title&lt;Hi jack&gt;gogogogoogogogo# 标题、正文输入完之后，输入下面命令发送邮件control + d 配置mutt 123456vim .muttrcset sendmail="/usr/bin/msmtp"set use_from=yesset realname='l5@126.com'set from="l5@126.com"set envelope_from=yes 测试mutt 是否安装配置成功 12sudo chmod 0600 ~/.msmtprcecho &quot;准备的怎样了&quot; | mutt -s &quot;周末出游&quot; 419548550@qq.com 参考文章 https://www.huaijiujia.com/category/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/centos/centos-%E7%89%B9%E6%9C%89%E8%BD%AF%E4%BB%B6/ https://www.cnblogs.com/hjfeng1988/p/4464116.html https://www.jianshu.com/p/893352c61f93 https://blog.csdn.net/betty13006159467/article/details/71172295 https://www.jianshu.com/p/f7faa156087a 发送邮件配置 1234567891011121314151617181920#!/bin/bash# check network availabilitywhile truedoTIMEOUT=5SITE_TO_CHECK="www.baidu.com"RET_CODE=`curl -I -s --connect-timeout $TIMEOUT $SITE_TO_CHECK -w %&#123;http_code&#125; | tail -n1`if [ "x$RET_CODE" = "x200" ]; thenecho "Network OK, will send mail..."breakelseecho "Network not ready, wait..."sleep 1sfidone# 这里如果是网线用eth0, 如果是wifi 用wlan0。ETH0_IP_ADDR=`ifconfig wlan0 | sed -n "2,2p" | awk '&#123;print substr($2,1)&#125;'`echo $ETH0_IP_ADDR# send the Email 这里给qq邮箱发提示失败(原因是垃圾邮件)，换成126自己的地址就可以。然后用QQ邮箱代收。echo "China Current time: `date '+%F %T'`. Good time" | mutt -s "Zubao's IP Address of Raspberry Pi: $ETH0_IP_ADDR" l5@126.com 开机配置 123# 将.msmtprc .msmtp.log .muttrc 文件copy到 /root 目录下面。需要用su进入root权限，sudo不行# 修改 /etc/rc.local 文件，在exit 之前加上bash /root/send_ip_mail.sh]]></content>
      <categories>
        <category>Raspberry</category>
      </categories>
      <tags>
        <tag>raspberry</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Q 2XL Root]]></title>
    <url>%2Fblog%2F2020%2F01%2F13%2FAndroid%20Q%20Pixel%202%20XL%20Root%2F</url>
    <content type="text"><![CDATA[开始之前，在要root或者刷机的手机上，移除google账户。Unlock the Bootloader Before Unlock This will work only on Google Pixel 2 and Pixel 2 XL users. You need Laptop or PC. Working USB Cable. Charge your phone to at least 70% battery. GetDroidTips.com is not responsible for any damage to your phone while installing this Update. Make sure that you have latest USB drivers installed. Download the ADB Fastboot tools. Watch Video on How to Install ADB Fastboot on your PC. Take a complete backup of your phone and then proceed. 打开开发者模式 Enable the Developer Option, Go to your Settings -&gt; About -&gt; Software Information -&gt; More -&gt; Now Tap on the Build Number 7-8 Times until you see a toast message “Developer option enabled“ OEM unlock Settings -&gt; Developer Option and Enable OEM Unlock and USB Debugging 环境配置 主要是配置adb环境，android 开发者可以忽略 Download and Extract the Downloaded ADB fastboot Zip file on your PC. Now connect your phone to Computer using USB Cable. When you connect your Phone to Computer, please wait until all the drivers get installed. 运行 adb deviecs 检查adb 是否安装成功 进入bootloader模式 adb reboot bootloader 运行 fastboot devices， 确认fastboot 驱动安装成功 oem unlock 12fastboot oem unlockfastboot reboot 下载Android 10 镜像文件(Factory Images) https://developers.google.com/android/images 解压文件 1、将刚刚下载的zip文件解压缩 2、从解压出的文件中找到image开头的文件 3、继续解压 4、找到boot.img文件 5、将boot.img文件copy到手机的sdcard/Download目录 Install Canary Magisk Manager 安装 Magisk Manager， https://github.com/topjohnwu/Magisk 修改更新通道（Update Channel） 1、安装Magisk manager 2、Left Menu -》 Settings -》 update Channel -》 Canary Patch the Boot Image Go to the main screen of the Magisk Manager. Tap on Install and hit the Install button to bring up new set of options. From the list, tap on the Select and Patch a file option. Grant all the necessary permissions by tapping Allow. Now under the File Manger, go to the Downloads folder where you have copied the boot.img file. Tap on the boot.img file and Magisk Manager will start patching that file. Once the process is complete, tap the back arrow to finish. Install ADB and Fastboot android 开发者已经有了adb 和 fastboot的环境，如果没有需要自行下载并配置环境变量 Move the Patched boot image 将boot.img 从手机移动到PC上，重命名为magisk_patched.img Boot into the Fastboot Mode 进入 fastboot mode Long press the Power button to shut down your phone. Now hold down the Power + Volume Down button till the Fastboot menu appears. Quickly connect your device to the PC via a USB cable. Leave the phone in that state for the further process. Flash the Patched boot image 命令行刷入 magisk_patched.img Type the below command in the cmd prompt;fastboot flash boot magisk_patched.img Type in the next command;fastboot reboot The above command will automatically reboot your device. Once your device has rebooted you can verify the root status of your device by opening the Magisk Manager app. That’s it! 总结： 1、unlock the BootLoader 不同手机不同版本可能不一样； 2、去官网下载对应机型的Factory Images，解压缩得到image**文件，继续解压得到boot.img文件 3、下载最新的magisk Manager 4、在需要root的手机上安装 Magisk Manager 并修改 更新通道 5、将boot.img文件copy到手机上，例如/sdcard/download 6、Magisk Manager首页 Magisk模块后面选择安装，选择修复***，然后去文件系统里面选择boot.img。会自动下载Magisk模块，并且修改boot.img文件，最后保存为magisk_patched.img文件 7、运行 adb reboot bootloader 进入fastboot mode 8、运行 fastboot boot magisk_patched.img (临时) 或者 fastboot flash boot magisk_patched.img （永久） ​ PS: 前者为临时刷root权限；后者为永久刷root权限，后者刷入后，手动按power键进入系统，进入Magisk Manager 再次安装Magisk，选择直接安装，之后重启，永久root生效。 9、刷临时root会自动重启，进入系统。重新进入Magisk Manager 发现Magisk模块以及安装成功。 10，adb shell ，然后运行su命令，发现root已经成功。 参考文章： 1、https://sspai.com/post/53043 2、https://sspai.com/post/53809 3、https://sspai.com/post/53075 4、https://www.getdroidtips.com/how-to-root-any-pixel-device-running-android-10-q-pixel-2-pixel-3-3a-xl/]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>ROM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins 持续集成，交付]]></title>
    <url>%2Fblog%2F2020%2F01%2F10%2FJenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E4%BA%A4%E4%BB%98%2F</url>
    <content type="text"><![CDATA[Jenkins简介 Jenkins是一款由Java编写的开源的持续集成工具 官网地址 https://jenkins.io/zh/ Jenkins 的卸载 运行命令 ‘/Library/Application Support/Jenkins/Uninstall.command’ 参考文章 https://blog.csdn.net/weixin_40881502/article/details/84748599 Jenkins 命令行安装 brew install jenkins-lts 安装好 Jenkins 之后，直接访问默认的地址：http://localhost:8080/ 就可以启动默认设置页面了。如果访问这个默认地址不能加载 Jenkins 的，我们需要先通过 brew services start jenkins-lts 来启动 Jenkins。 对应的卸载方式 brew uninstall jenkins-lts Homebrew 命令安装的 Jenkins 的目录在：~/.jenkins，而通过 .pkg 包安装的 Jenkins 目录在：/Users/Shared/Jenkins，这个就是为什么 .pkg 安装的 Jenkins 相对于 Homebrew 安装的 Jenkins 问题更多的根本原因！ 2.如果你不想用默认的端口号：8080，或者这个端口号已经被占用，可以通过以下位置的文件来修改默认端口号：/usr/local/Cellar/jenkins-lts/2.138.2/homebrew.mxcl.jenkins-lts.plist，当然这个位置的文件根据你的版本号不同而不同。修改第 18 行的 –httpPort= 后面的值。 然后通过 brew services start jenkins-lts 命令来重启生效。 查看密码 1sudo cat ~/.jenkins/secrets/initialAdminPassword 安装插件 1GitLab、GitLab Hook、XCode integration、Keychains and Provisoning Profiles Management 四个插件 配置 Keychains 和 Provisioning Profiles。(For IOS) 通过刚才安装的 keychains and Provisioning Profiles Management 插件，Jenkins -&gt; Manage Jenkins -&gt; Keychains and Provisioning Profiles Management，来配置 Keychains 和 Provisioning Profiles。 去 macOS 以下地址：/Users/{username}/Library/Keychains。我的路径是：~/Library/Keychains，找到 login.keychain 文件，有的时候你可能看到的是 login.keychain-db 文件，没关系，将 login.keychain-db 文件修改成 login.keychain。然后通过 Upload Keychain or Provisioning Profile File -&gt; Choose File -&gt; Upload 上传： 新建构建项目Android 配置JDK Manage Jenkins -》Global Tool Configuration 模块配置JDK，因为本地有安装JDK，这里只需要提供路径即可。 1echo $JAVA_HOME 配置Gradle 和JDK在同一个位置配置，Gradle 可以选择使用Jenkins自己的，让它自己去下载。不用本地已经有的。 配置git SSH Jenkins &gt; Credentials &gt; System &gt;Global credentials (unrestricted) Git SSH 在左边控制面板下面找到Credentials ，然后安装上面顺序找到 Add Credentials，点击添加。 Git配置有两种，这里我使用的是SSH方式，只需要填入用户名，ssh 私钥即可。私钥地址 .ssh/id_rsa 配置项目地址 Git 如果上面配置的是 ssh方式，这里最好是使用git@github.com:xxx 这种方式，而不是http。 新建项目 1、配置git地址 2、配置构建周期(例如：H/5 * * * *) 3、配置构建脚本invoke Gradle Script， 现在assembleRelease –info Error 403 No valid crumb was included in the request 在jenkins 的Configure Global Security下 , 取消“防止跨站点请求伪造（Prevent Cross Site Request Forgery exploits）”的勾选。 参考文章 https://www.ifeegoo.com/using-jenkins-to-set-up-the-continuous-integration-environment-of-android-and-ios-on-macos.html]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>mac</tag>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Fblog%2F2019%2F12%2F31%2FAndroid%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Mac Python OpenCV 配置]]></title>
    <url>%2Fblog%2F2019%2F12%2F29%2FOpenCV%20Python%20Mac%20%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[安装1234sudo pip3 install numpysudo pip3 install Matplotlibsudo pip3 install opencv_pythonsudo pip3 install pytesseract 模式匹配 在图像中查找指定的模板 https://testerhome.com/topics/12537/show_wechat 比较全面的opencv https://juejin.im/entry/5a7c2622f265da4e7071b54a]]></content>
      <categories>
        <category>opencv</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Gradle配置]]></title>
    <url>%2Fblog%2F2019%2F12%2F27%2FGradle%20%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Android Gradle 插件 与 gradle 版本的映射关系 插件版本 所需的 Gradle 版本 1.0.0 - 1.1.3 2.2.1 - 2.3 1.2.0 - 1.3.1 2.2.1 - 2.9 1.5.0 2.2.1 - 2.13 2.0.0 - 2.1.2 2.10 - 2.13 2.1.3 - 2.2.3 2.14.1+ 2.3.0+ 3.3+ 3.0.0+ 4.1+ 3.1.0+ 4.4+ 3.2.0 - 3.2.1 4.6+ 3.3.0 - 3.3.2 4.10.1+ 3.4.0+ 5.1.1+ https://developer.android.google.cn/studio/releases/gradle-plugin]]></content>
      <categories>
        <category>gradle</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[androidX]]></title>
    <url>%2Fblog%2F2019%2F12%2F27%2FAndroidX%20%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[androidX简介 AndroidX 是 Android 团队用于在 Jetpack 中开发，测试，打包，版本和发布库的开源项目 。 AndroidX 是对原始 Android Support Library的重大改进 。与支持库一样，AndroidX 与 Android 操作系统分开提供，并提供跨 Android 版本的向后兼容性。AndroidX 通过提供功能奇偶校验和新库完全取代了支持库。此外，AndroidX 还包括以下功能： AndroidX 中的所有软件包都以字符串开头，位于一致的命名空间中 androidx。支持库包已映射到相应的 androidx.* 包中。有关所有旧类和构建组件的完整映射到新构件。 与支持库不同，AndroidX 软件包是单独维护和更新的。这些 androidx 包使用从版本 1.0.0 开始的严格语义版本控制。开发者可以单独更新项目中的 AndroidX 库。 所有新的支持库开发都将在 AndroidX 库中进行。这包括维护原始支持库组件和引入新的 Jetpack 组件 https://henleylee.github.io/posts/2018/3e59253e.html https://www.infoq.cn/article/2018/05/androidx-library-alpha androidX 迁移 https://yumibb.cn/2019/12/12/%E4%BB%8B%E7%BB%8D%E4%B8%A4%E6%AC%BEandroidX%E8%BF%81%E7%A7%BB%E5%88%A9%E5%99%A8/ androidX 官方文档 https://developer.android.google.cn/jetpack/androidx/migrate]]></content>
      <categories>
        <category>androidX</category>
      </categories>
      <tags>
        <tag>androidX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 代码检测]]></title>
    <url>%2Fblog%2F2019%2F12%2F27%2FAndroid%20%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[阿里代码检测工具-AS插件 安装方式 在线安装插件 插件名称 Alibaba Java Coding Guidelines plugin support. 检测范围 - 针对代码规范检测。 离线下载地址 - https://plugins.jetbrains.com/plugin/10046-alibaba-java-coding-guidelines/ SpotBugs 静态代码检测工具，针对字节码进行检测。基于FindBugs 安装方式 123456789101112131415161718192021222324252627282930buildscript &#123; repositories &#123; jcenter() maven &#123; url "https://plugins.gradle.org/m2/" // For SpotBugs &#125; maven &#123; url 'https://maven.google.com/' name 'Google' &#125; &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:3.4.2' classpath "gradle.plugin.com.github.spotbugs:spotbugs-gradle-plugin:2.0.0" &#125;&#125;allprojects &#123; repositories &#123; jcenter() maven &#123; url 'https://maven.google.com/' name 'Google' &#125; &#125;&#125;task clean(type: Delete) &#123; delete rootProject.buildDir&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859apply plugin: 'com.android.application'apply plugin: "com.github.spotbugs"android &#123; compileSdkVersion 28 buildToolsVersion "28.0.3" defaultConfig &#123; applicationId "xxx" minSdkVersion 23 targetSdkVersion 28 versionCode 1 versionName "1.0" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro' &#125; &#125; lintOptions &#123; abortOnError false &#125;&#125;sourceSets &#123; main &#123; java.srcDirs = [] &#125;&#125;spotbugs &#123; ignoreFailures = true reportsDir = file("$project.buildDir/SpotBugsReports") effort = "max" reportLevel = "high"&#125;tasks.withType(com.github.spotbugs.SpotBugsTask) &#123; dependsOn 'assembleDebug' classes = files("$project.buildDir/intermediates/javac") // source = fileTree('src/main/java') reports &#123; // Enable HTML report only html.enabled = true xml.enabled = false &#125;&#125;repositories &#123; //引入aar包 flatDir &#123; dirs 'libs' &#125;&#125;dependencies &#123; implementation fileTree(include: ['*.jar'], dir: 'libs') implementation 'com.android.support:appcompat-v7:28.0.0'&#125; 12# 执行方式, 实测可以生成检测报告./gradlew check 环境配置 1、AS 版本为3.5.3 2、gradle tools 版本为 3.4.2 3、gradle 版本为 5.1.1 SpotBugs 官网 https://spotbugs.readthedocs.io/en/latest/gradle.html 其他参考文章 https://juejin.im/post/59c9d14451882579e955588d https://codeday.me/bug/20191108/2010094.html SpotBugs 多Module的配置 spotbugs.gradle配置 12345678910111213141516171819202122232425262728293031323334353637383940414243dependencies &#123; spotbugs configurations.spotbugsPlugins.dependencies spotbugsPlugins 'com.h3xstream.findsecbugs:findsecbugs-plugin:1.8.0'&#125;//def qualityConfigDir = "$project.rootDir/config/quality"def reportsDir = "$project.buildDir/reports"spotbugs &#123;// toolVersion = "$spotbugs_version" toolVersion = '4.0.0-beta4' ignoreFailures = false effort = "min" // This selects what level of bugs to report: low means low priority issues will be reported // (in addition to medium+high), which corresponds to warning about everything. // TODO: boost this to low once low priority issues are fixed. reportLevel = "medium"// excludeFilter = new File("$qualityConfigDir/config/quality/spotbugs/android-exclude-filter.xml")&#125;tasks.register("spotbugs", SpotBugsTask) &#123; dependsOn 'assemble' group = "verification" classes = files("$projectDir.absolutePath/build/intermediates/app_classes/debug") source = fileTree('src/main/java') // Only one report format is supported. Html is easier to read, so let's use that // (xml is the one that's enabled by default). reports &#123; xml.enabled = true xml &#123; destination file("$reportsDir/spotbugs/spotbugs.xml") &#125; html.enabled = true &#125; classpath = files()&#125; 项目build.gradle配置 12345678910111213141516171819202122232425262728293031323334353637383940414243// Top-level build file where you can add configuration options common to all sub-projects/modules.buildscript &#123; repositories &#123; mavenCentral() jcenter() maven &#123; url 'https://maven.fabric.io/public' &#125; maven &#123; url 'https://maven.google.com/' name 'Google' &#125; &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:3.4.2'// classpath "gradle.plugin.com.github.spotbugs:spotbugs-gradle-plugin:2.0.0" // For SpotBugs &#125;&#125;plugins &#123; id "com.github.spotbugs" version "2.0.0"&#125;// Workaround to be able to access SpotBugsTask from external gradle script.// More info: https://discuss.gradle.org/t/buildscript-dependencies-in-external-script/23243project.extensions.extraProperties.set('SpotBugsTask', com.github.spotbugs.SpotBugsTask)apply from: './app/spotbugs.gradle'allprojects &#123; repositories &#123; mavenCentral() jcenter() maven &#123; url 'https://maven.fabric.io/public' &#125; maven &#123; url 'https://maven.google.com/' name 'Google' &#125; &#125;&#125;task clean(type: Delete) &#123; delete rootProject.buildDir&#125;]]></content>
      <categories>
        <category>android studio</category>
      </categories>
      <tags>
        <tag>SpotBugs</tag>
        <tag>阿里编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码检测]]></title>
    <url>%2Fblog%2F2019%2F11%2F21%2F%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[- 美团 https://tech.meituan.com/2019/11/07/android-static-code-canning.html android IDE 代码检测工具介绍]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GC日志分析]]></title>
    <url>%2Fblog%2F2019%2F11%2F19%2FGC%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[一、Dalvik1.1 GC含义Dalvik虚拟机，每一次GC打印内容格式： 12D/dalvikvm: &lt;GC_Reason&gt; &lt;Amount_freed&gt;, &lt;Heap_stats&gt;, &lt;External_memory_stats&gt;, &lt;Pause_time&gt; 对应项： 12D/dalvikvm: &lt;GC触发原因&gt; &lt;GC释放内存大小&gt;, &lt;堆统计信息&gt;, &lt;外部内存统计&gt;, &lt;暂停时间&gt; 含义解析 GC Reason(GC触发原因) GC_CONCURRENT：当已分配内存达到某一值时，触发并发GC； GC_FOR_MALLOC：当尝试在堆上分配内存不足时触发的GC；系统必须停止应用程序并回收内存； GC_HPROF_DUMP_HEAP： 当需要创建HPROF文件来分析堆内存时触发的GC； GC_EXPLICIT：当明确的调用GC时，例如调用System.gc()等； GC_EXTERNAL_ALLOC： 仅在API级别为10或者更低时（新版本分配内存都在Dalvik堆上） Amount freed GC回收的内存大小 Heap stats 堆上的空闲内存百分比 （已用内存）/（堆上总内存） External memory stats API级别为10或者更低：（已分配的内存量）/ （即将发生垃圾的极限） Pause time（暂停时间） 较大的堆将有较大的暂停时间。并发暂停时间显示有两个停顿：一个是垃圾回收的开头和另一接近垃圾回收的结尾。 1.2 实例实例： D/dalvikvm: GC_CONCURRENT freed 2049K, 65% free 3571K/9991K, external 4703K/5261K, paused 2ms+2ms 含义： GC触发原因：GC_CONCURRENT; GC释放内存大小：2049K; 堆统计信息：堆空闲内存为65%，已用内存:3571K， 堆上总内存：9991K; 暂停时间：总共暂时4ms。 1.3 小结根据不断增加的日志信息，观察增加的堆统计信息（在上例中的3571K/9991K值），若该值持续增加，可能有内存泄漏。 二、ARTART的log不同于Dalvik的log机制，正常情况不会打印非明确调用的GCs的log信息。GCs打印出来的log信息都是被认为是执行比较缓慢的信息，更准确地说，就是GC暂停的时间超过5ms或者GC执行的总时间超过100ms。 如果app不处于暂停的感知状态，那么没有GC会被认为是缓慢的。但是明确地调用GCs会记录log信息。 2.1 GC含义ART虚拟机，每一次GC打印内容格式： 12I/art: &lt;GC_Reason&gt; &lt;GC_Name&gt; &lt;Objects_freed&gt;(&lt;Size_freed&gt;) AllocSpace Objects,&lt;Large_objects_freed&gt;(&lt;Large_object_size_freed&gt;) &lt;Heap_stats&gt; LOS objects, &lt;Pause_time(s)&gt; 对应项： 12I/art: &lt;GC触发原因&gt; &lt;GC名称&gt; &lt;释放对象个数&gt;(&lt;释放字节数&gt;) AllocSpace Objects, &lt;释放大对象个数&gt;(&lt;释放大对象字节数&gt;) &lt;堆统计&gt; LOS objects, &lt;暂停时间&gt; 2.2 GC解析2.2.1 GC Reason Concurrent： 并发GC，不会使app线程挂起，该GC是在后台线程运行的，也不会阻止内存分配。 Alloc:当堆内存已满时，app尝试申请内存，会触发该GC。在这种情况下，垃圾回收发生在正在分配内存的线程。 Explicit: 明确的调用垃圾回收，比如gc().与dalvik一样，应尽可能避免明确调用gc。不建议使用，由于程序的GC会阻塞分配线程和不必要的CPU周期，如果其他线程获取抢占资源也可能导致jank。 NativeAlloc: 垃圾回收是由于native内存过重而触发的，例如Bitmaps或者RenderScript分配的对象。 CollectorTransition: 由于堆过渡触发的。收集器转换包括拷贝所有的对象从一个自由列表支持空间到指针空间，也包括反过来拷贝。目前垃圾回收器传输仅发生在低内存设备的app进程状态转移，包含从一个可感知的暂停状态转换到非暂停可感知状态，或者非暂停态到暂停态。 HomogeneousSpaceCompact:齐性空间压缩是指空闲列表到压缩的空闲列表空间，通常发生在当app已经移动到暂停可感知的进程状态。这样做的主要原因是减少了内存使用情况和堆碎片整理。 DisableMovingGc:这并非真实的GC触发原因，只是标记垃圾回收被阻塞，由于并非堆压缩正在发生时使用了GetPrimitiveArrayCritical。由于其对移动收集器的限制，使用GetPrimitiveArrayCritical是强烈不建议。 HeapTrim: 这并非GC触发原因，只是标记垃圾回收被阻塞直到堆整理完成。 2.2.2 GC Name Concurrent mark sweep (CMS): 完整的堆垃圾回收器，能释放除去图片空间之外的所有的垃圾。 Concurrent partial mark sweep: 绝大多数的堆垃圾回收器，能释放除去图片和zygote空间之外的所有的垃圾。 Concurrent sticky mark sweep: 一般性的垃圾回收器，只能释放上一次GC所关联的对象。该垃圾回收器运行得更常用，有更低的暂停时间。 Marksweep + semispace: 非并发gc,复制GC用于堆过渡以及齐性空间压缩（堆碎片整理）。 2.2.3 GC其他参数 Objects_freed： 从非大对象空间回收到的对象数； Size_freed：从非大对象空间回收到的字节数； Large_objects_freed：从大对象空间回收到的对象数； Large_object_size_freed：从大对象空间回收到的字节数； Heap_stats： 堆上的空闲内存百分比 （已用内存）/（堆上总内存）； Pause_time：暂停时间跟GC正在运行时引用对象被改变的对象数成正比。目前，ART的CMD GC仅有一次停顿，出现在GC的结尾附近。移动GC有一个长的暂停时间持续在GC的大多数期间。 2.3 实例I/art : Explicit concurrent mark sweep GC freed 104710(7MB) AllocSpace objects, 21(416KB) LOS objects, 33% free, 25MB/38MB, paused 1.230ms total 67.216ms 含义： GC触发原因：Explicit GC名称：concurrent mark sweep GC 释放对象个数：104710 释放字节数：7MB 释放大对象个数：21 释放大对象字节数：416KB 堆统计：堆空闲内存为33%，已用内存:25MB， 总内存总：38MB 暂停时间：GC暂停时长：1.230ms，GC总时长：67.216ms 2.4 小结 当看到大量的GC log信息在logcat，可查看堆统计(如样例中 5MB/38MB)。如果这个值持续增长，并且一直不见它变小，那可能发生了内存泄露。 如果看到GC触发条件是Alloc，那当前环境已经接近堆内存的上限了，在不久后很快会出现OOM。 参考文章 http://developer.android.com/tools/debugging/debugging-memory.html http://gityuan.com/2015/10/03/Android-GC/]]></content>
      <categories>
        <category>gc</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>gc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[训练网站]]></title>
    <url>%2Fblog%2F2019%2F11%2F18%2F%E8%AE%AD%E7%BB%83%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[在线刷题 https://leetcode-cn.com/ 可以在线刷题，算法、数据库]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>it</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 内存分析]]></title>
    <url>%2Fblog%2F2019%2F11%2F15%2FAndroid%20Memory%20%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[获取内存堆栈文件 dump hprof文件 123456# 生成hprof文件adb shell am dumpheap com.xxx.demo /data/local/tmp/start.hprof# 拉取到电脑adb pull /data/local/tmp/start.hprof .# 格式转换hprof-conv start.hprof st.hprof MAT工具使用参考文章： http://www.lightskystreet.com/2015/09/01/mat_usage/ 命令行分析 查看内存使用情况 1adb shell dumpsys meminfo &lt;package_name&gt; 查看当前activity 1adb shell dumpsys activity top | grep ACTIVITY 查看activity的详细信息 1dumpsys activity top &gt;D:/a.txt 内存相关名称解释 VSS- Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）；VSS表示一个进程可访问的全部内存地址空间的大小。这个大小包括了进程已经申请但尚未使用的内存空间。在实际中很少用这种方式来表示进程占用内存的情况，用它来表示单个进程的内存使用情况是不准确的。 RSS- Resident Set Size 实际使用物理内存（包含共享库占用的内存）。表示一个进程在RAM中实际使用的空间地址大小，包括了全部共享库占用的内存，这种表示进程占用内存的情况也是不准确的。 PSS-Proportional Set Size 实际使用的物理内存（比例分配共享库占用的内存）。表示一个进程在RAM中实际使用的空间地址大小，它按比例包含了共享库占用的内存。假如有3个进程使用同一个共享库，那么每个进程的PSS就包括了1/3大小的共享库内存。这种方式表示进程的内存使用情况较准确，但当只有一个进程使用共享库时，其情况和RSS一模一样。 USS- Unique Set Size 进程独自占用的物理内存（不包含共享库占用的内存）表示一个进程本身占用的内存空间大小，不包含其它任何成分，这是表示进程内存大小的最好方式！可以看到:VSS&gt;=RSS&gt;=PSS&gt;=USS CPU主频：123456adb shell回车cd /sys/devices/system/cpu/cpu0/cpufreq回车cat cpuinfo_cur_freq# top命令查看cpu占用和内存占用adb shell top -m 10 -s cpu | grep packageName 123456789参数含义：PID : progress identification，应用程序IDS : 进程的状态，其中S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值是负数#THR : 程序当前所用的线程数VSS : Virtual Set Size虚拟耗用内存（包含共享库占用的内存）RSS : Resident Set Size实际使用物理内存（包含共享库占用的内存）PCY : 前台(fg)和后台(bg)进程UID : User Identification，用户身份IDName : 应用程序名称 参考文章 https://blog.51cto.com/10250691/1896479 https://testerhome.com/topics/2583]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>memory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派的安装配置]]></title>
    <url>%2Fblog%2F2019%2F11%2F15%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[硬件选购 必须(主板、SDCard、电源线或者USB线-Type-C、读卡器) 可选(显示器、鼠标、键盘、风扇、外壳、各类传感器、HDMI线(一头为HDMI-micro，另一头为HDMI)) 安装系统 下载Raspberry系统镜像 下载地址 https://www.raspberrypi.org/downloads/raspbian/ 下载Etcher https://www.balena.io/etcher/ 使用Etcher 将下载的img镜像文件，写入SDcard。 1、Mac 上用磁盘工具将SDcard 格式化为FAT32格式，即MS-DOS(FAT) 2、使用Etcher刻录，选择img文件，然后选择SDCard，开始刻录。大概30分钟左右。 将刻录好的Sdcard插入主板背面的插口。 启动树莓派 插上数据线，或者接上USB线，即可启动系统 Raspberry 最新的系统默认没有开启SSH，需要先开启SSH服务 SSH登录树莓派 1ssh pi@192.168.xx.xx Raspbian 默认用户名/密码：pi/raspberry 问题 小米路由器禁止了Ping、SSH，需要修改路由器加密方式为WPA2。可以通过小米wifiAPP -&gt; Wi-Fi设置 -&gt; 加密方式 修改。 SSH反向代理 ssh 免密码登陆 12345678910111213141516171819202122232425262728# 第一步在.ssh目录下生成密钥对ssh-keygen -t rsa -P '' -f ~/.ssh/id_rsa# 第二步将公钥copy到树莓派|服务器scp id_rsa.pub pi@host:/user/.ssh# 第三方将公钥copy到.ssh 目录下authorized_keys文件中。如果免密登陆失败，看下公钥是否另起一行。cat id_rsa.pub &gt;&gt; authorized_keys# 第四步在本地.ssh目录下新建config文件Host * ServerAliveInterval 20 ServerAliveCountMax 3 ForwardAgent yes CheckHostIP no Compression yes TCPKeepAlive yes ControlMaster auto ControlPath /tmp/ssh_connection_%h_%p_%r.sockHost ali User root Hostname 树莓派|服务器ip IdentityFile ~/.ssh/id_rsa# 第五步 通过别名 ali 免密登陆ssh ali# 服务器设置防火墙firewall-cmd --zone=public --add-port=33389/tcp --permanentfirewall-cmd --zone=public --add-port=20443/tcp --permanentfirewall-cmd --reload ubuntu 端口操作 ufw enable ufw reload ufw status ufw allow 9000 ufw deny 9000 ufw delete allow 9000 https://www.cnblogs.com/toughlife/p/5475615.html https://blog.csdn.net/jiaochiwuzui/article/details/80907521 kill端口号为xxx的进程 12lsof -ti:5901 | xargs kill -9netstat -tunpl | grep 端口号 ssh反向代理 12345678910111213141516# 树莓派上建立反向代理(内网)ssh -fNR 9333:localhost:22 root@x.x.x.x# VPS上 用9333端口 连接 树莓派；VPS 公网 ；PS这步测试用ssh -p 9333 pi@localhost# VPS 上建立正向代理ssh -fCNL *:10008:localhost:9333 localhost# 开通端口10008iptables -I INPUT -p tcp --dport 10008 -j ACCEPT# PC 上 使用ssh 访问 树莓派；PC(另外一个内网)，ssh -p 10008 pi@x.x.x.x (公网ip)# 端口检查netstat -ale | grep 10008 https://blog.csdn.net/j5856004/article/details/102311180 http://ukonline2000.com/?p=865 goproxy 内网穿透 123456789101112131415161718192021222324252627282930313233# 在vps上安装goproxy https://github.com/snail007/goproxy/blob/master/README_ZH.md# 注意安装最好选择手动安装，选择好对应系统、32|64 bit的安装包。# 去vps管理后台，开通需要用到的端口# 在vps主机上，开通需要用到的端口# vps 上生成证书 proxy.crt proxy.key proxy keygen -C proxy# vps 运行如下命令 proxy bridge -p ":33080" -C proxy.crt -K proxy.key --daemon --forever --log proxy.log # vps 开启服务, 同时映射80、22两个端口proxy server -r ":28080@:80" -r ":29090@:22" --k test -P "127.0.0.1:33080" -C proxy.crt -K proxy.key# 如果要在自己的电脑上通过vps连接树莓派，-p后面 改为vps的ip地址proxy server -r ":28080@:80" -r ":29090@:22" --k test -P "22.22.22.22:33080" -C proxy.crt -K proxy.key# 不同的client 用过 --k后面的 字符串区分# 树莓派 安装 goproxy # 树莓派 将vps 上生成的证书copy下来# 树莓派 开启客户端 proxy client --k test -P "22.22.22.22:33080" -C proxy.crt -K proxy.key# 第二种方法 用户界面。视频教程 https://www.bilibili.com/video/av73727323# 第一步在 vps上安装 proxyadmin 工具 https://github.com/snail007/proxy_admin_free/blob/master/README_ZH.md#%E8%A7%86%E9%A2%91%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B# 第二步 在树莓派上安装 proxyadmin 工具# 第三步 在浏览器访问 vps的 proxyadmin 工具(ip:32080)，在上面重置证书。# 第四步，将生成的证书下载下来，导入树莓派生 上面的 proxyadmin工具# 第五步，在vps上的proxyadmin 进入 内网穿透，启动监听，新增映射。具体参考视频教程# 第六步，在树莓派上的proxyadmin，进入自定义服务，具体参考视频教程# kill proxy 进程ps -aux | grep proxykill -9 pid (第二列) 树莓派定时任务 1234567891011121314151617crontab -lcrontab -e# 命令范式# m h dom mon dow command# m： 表示分钟，范围0到59# h：表示小时，范围0到23# dom：表示日，范围1到31# mon：表示月，范围1到12# dow：表示星期，范围0到7，0和7都是星期日# command：表示命令# 特殊字符含义# *：表示所有的值，如果m字段是星号，这说明每分钟都运行。# ,：表示一个列表，如果m字段是 "1，5，15，58"，这说明在第1分钟，第5分钟，第15分钟和第58分钟会运行# -：表示一个范围，如果m字段是 1-5，这说明第1分钟、第2分钟、第3分钟、第4分钟和第5分钟都会运行# /：表示时间间隔，如果m字段是 */10，这说明每隔10分钟运行 参考资料 https://www.ihubin.com/blog/raspberrypi-mac-install-raspbian/ https://blog.csdn.net/freewebsys/article/details/48980993 https://blog.csdn.net/Winterto1990/article/details/90208724 https://github.com/snail007/proxy_admin_free/blob/master/README_ZH.md#%E8%A7%86%E9%A2%91%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B https://github.com/snail007/goproxy/blob/master/README_ZH.md https://www.cnblogs.com/felixnet/p/7767191.html https://zhuanlan.zhihu.com/p/108624497]]></content>
      <categories>
        <category>Raspberry</category>
      </categories>
      <tags>
        <tag>raspberry</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 使用Monky自动测试]]></title>
    <url>%2Fblog%2F2019%2F11%2F15%2FMonkey%20%E8%87%AA%E5%8A%A8%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[Monkey的用途 Monkey 主要用于Android 的压力测试。自动的一个压力测试小工具， 主要目的就是为了测试app 是否会Crash。 Monkey 参数介绍 -p &lt;允许的包名列表&gt; 用此参数指定一个或多个包。指定包之后，monkey将只允许系统启动指定的app。如果不指定包， monkey将允许系统启动设备中的所有app。 指定一个包：adb shell monkey -p com.xxx.demo 100 指定多个包：adb shell monkey -p com.xxx.demo1 –p com.xxx.demo2 100 -v 指定反馈信息级别（信息级别就是日志的详细程度），总共分3个级别，分别对应的参数如下 表所示： Level 0 : adb shell monkey -p com.xxx.demo -v 100 // 缺省值，仅提供启动提示、测试完成和最终结果等少量信息 Level 1 : adb shell monkey -p com.xxx.demo -v -v 100 // 提供较为详细的日志，包括每个发送到Activity的事件信息 Level 2 : adb shell monkey -p com.xxx.demo -v -v -v 100 // 最详细的日志，包括了测试中选中/未选中的Activity信息 -s（随机数种子） 指定伪随机数生成器的seed值，如果seed相同，则两次Monkey测试所产生的事件序列也相同的。 示例： monkey测试1：adb shell monkey -p com.xxx.demo –s 10 100 monkey测试2：adb shell monkey -p com.xxx.demo –s 10 100 –throttle &lt;毫秒&gt; 用亍指定用户操作（即事件）间的时延，单位是毫秒。 例：adb shell monkey -p com.xxx.demo –throttle 3000 100 –pct-touch 调整触摸事件的百分比 ( 触摸事件是一个 down-up 事件，它发生在屏幕上的某单一位置 ) 。 –pct-motion 调整动作事件的百分比 ( 动作事件由屏幕上某处的一个 down 事件、一系列 的伪随机事件和一个 up 事件组成 ) 。 –pct-trackball 调整轨迹事件的百分比 ( 轨迹事件由一个或几个随机的移动组成，有时还伴随有点击 ) 。 –pct-nav 调整“基本”导航事件的百分比 ( 导航事件由来自方向输入设备的 up/down/left/right 组成 ) 。 –pct-majornav 调整“主要”导航事件的百分比 ( 这些导航事件通常引发图形界面中的动作，如： 5-way 键盘的中间按键、回退按键、菜单按键 ) –pct-syskeys 调整“系统”按键事件的百分比 ( 这些按键通常被保留，由系统使用，如 Home 、 Back 、 Start Call 、 End Call 及音量控制键 ) 。 –pct-appswitch 调整启动 Activity 的百分比。在随机间隔里， Monkey 将执行一个 startActivity () 调用，作为最大程度覆盖包中全部 Activity 的一种方法。 –pct-anyevent 调整其它类型事件的百分比。它包罗了所有其它类型的事件，如：按键、其它不常用的设备按钮、等等。 约束限制 -c 如果用此参数指定了一个或几个类别， Monkey 将只允许系统启动被这些类别中的某个类别列出的 Activity 。如果不指定任何类别， Monkey 将选择下列类别中列出的 Activity ： Intent.CATEGORY_LAUNCHER 或 Intent.CATEGORY_MONKEY 。要指定多个类别，需要使用多个 -c 选项，每个 -c 选项只能用于一个类别。 调试 –dbg-no-events 设置此选项， Monkey 将执行初始启动，进入到一个测试 Activity ，然后不会再进一步生成事件。为了得到最佳结果，把它与 -v 、一个或几个包约束、以及一个保持 Monkey 运行 30 秒或更长时间的非零值联合起来，从而提供一个环境，可以监视应用程序所调用的包之间的转换。 –hprof 设置此选项，将在 Monkey 事件序列之前和之后立即生成 profiling 报告。这将会在 data/misc 中生成大文件 (~5Mb) ，所以要小心使用它。 –ignore-crashes 通常，当应用程序崩溃或发生任何失控异常时， Monkey 将停止运行。如果设置此选项， Monkey 将继续向系统发送事件，直到计数完成。 –ignore-timeouts 通常，当应用程序发生任何超时错误 ( 如“ Application Not Responding ”对话框 ) 时， Monkey 将停止运行。如果设置此选项， Monkey 将继续向系统发送事件，直到计数完成。 –ignore-security-exceptions 通常，当应用程序发生许可错误 ( 如启动一个需要某些许可的 Activity) 时， Monkey 将停止运行。如果设置了此选项， Monkey 将继续向系统发送事件，直到计数完成。 –kill-process-after-error 通常，当 Monkey 由于一个错误而停止时，出错的应用程序将继续处于运行状态。当设置了此选项时，将会通知系统停止发生错误的进程。注意，正常的 ( 成功的 ) 结束，并没有停止启动的进程，设备只是在结束事件之后，简单地保持在最后的状态。 –monitor-native-crashes 监视并报告 Android 系统中本地代码的崩溃事件。如果设置了 –kill-process-after-error ，系统将停止运行。 –wait-dbg 停止执行中的 Monkey ，直到有调试器和它相连接。 实例 1adb shell monkey –p com.xxx.demo –-throttle 100 –-pct-touch 50 –-pct-motion 50 –v –v 1000 &gt;c:\monkey.txt 最后一个数字表示将要自动操作的次数。 将事件记录保存到monkey.txt文件中。 可能问题： 小米手机上需要打开安全设置： 设置 –》 更多设置 –》 开发者选项 –》USB调试（安全设置） 杀掉monkey进程 adb shell ps | grep monky adb kill pid 第一个数值就是pid 参考文章 1、https://www.cnblogs.com/TankXiao/p/4815134.html 2、https://wiki.jikexueyuan.com/project/android-test-course/monkey-commond-tools.html]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>monkey</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 开源组件]]></title>
    <url>%2Fblog%2F2019%2F11%2F08%2FAndroid%20%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[事件分发 EventBus 3.0 https://github.com/greenrobot/EventBus http://greenrobot.org/eventbus/documentation RxBus 依赖RxJava 页面导航 ARouter 用于页面导航、过滤或者权限检查。例如跳转到内容页面的时候检查如果没有登录跳转到登录页面。 https://github.com/alibaba/ARouter 反射简化 JOOR 工具 http://www.jooq.org/products/ https://blog.csdn.net/bibingyan/article/details/56481801 数据库 greenDAO 性能高，内存占用小，库文件小 Realm 性能更高，自有引擎，库文件大 动态权限框架 AndPermission https://github.com/yanzhenjie/AndPermission 资源混淆 AndResGuard 1、重新修改已经打包的apk的resource.arse文件 2、不依赖源码、打包过程 批量打包 AndroidMultiChannelBuildTool 使用python脚本，支持v1签名 调试工具 Stetho 功能： 1、在浏览器上查看手机APP里面的数据库、SP中的数据 2、可以拦截网络请求；针对OKhttp]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle 依赖包下载失败解决方法]]></title>
    <url>%2Fblog%2F2019%2F10%2F31%2FGradle%20%E4%BE%9D%E8%B5%96%E5%8C%85%E4%B8%8B%E8%BD%BD%E5%A4%B1%E8%B4%A5%2F</url>
    <content type="text"><![CDATA[我们在Android studio 升级或者gradle 插件升级的时候经常碰到某个依赖包下载不了，例如：构建错误：Could not download trove4j.jar。可能的原因与解决方法： gradle plugin 版本和 gradle 版本不一致 123456789101112# 项目跟目录build.gradlebuildscript &#123; repositories &#123; jcenter() mavenCentral() google() &#125; dependencies &#123; # 插件版本 classpath 'com.android.tools.build:gradle:3.4.2' &#125;&#125; 1234567#Tue Oct 29 14:49:28 CST 2019distributionBase=GRADLE_USER_HOMEdistributionPath=wrapper/distszipStoreBase=GRADLE_USER_HOMEzipStorePath=wrapper/dists# gradle 版本distributionUrl=https\://services.gradle.org/distributions/gradle-5.1.1-all.zip gradle 插件版本和gradle 版本必须保持一致，具体的对应关系看官网 。 用 jcenter() 替换 mavenCentral(); 添加google()。 下载不了trove4j.jar依赖包的原因可能是因为防火墙的原因，可以试试代理，或者直接换一个代码库。例如： 12maven &#123;url "https://maven.aliyun.com/repository/google"&#125;maven &#123;url "https://maven.aliyun.com/repository/jcenter"&#125; 如果还是解决不了，可以考虑手动下载依赖包 trove4j.jar，然后放置到gradle 缓存目录。 12345678910111213141516 # 依赖包放置路径 /Users/xxx/.gradle/caches/modules-2/files-2.1 # trove4j.jar 的放置路径 /Users/xxx/.gradle/caches/modules-2/files-2.1/org.jetbrains.trove4j/trove4j/20160824/ # 用shasum 对 trove4j 取 hash值，用该hash值创建目录 shasum trove4j.jar mkdir xxx # 将jar包放到该目录中。 # 参考文章 # 如果jar或者pom文件网站上找不到，可以去下面查找 https://bintray.com/jetbrains/trove4j/trove4j#files/org%2Fjetbrains%2Ftrove4j%2Ftrove4j%2F20160824 https://mvnrepository.com/search?q=trove4j https://www.meiwen.com.cn/subject/pekjuctx.html https://www.kaelli.com/26.html https://chinagdg.org/2016/01/picking-your-compilesdkversion-minsdkversion-targetsdkversion/https://developer.android.com/studio/build/dependencies?hl=zh-cn 阿里代码仓库]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>gradle</tag>
        <tag>android studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[证书申请]]></title>
    <url>%2Fblog%2F2019%2F10%2F22%2F%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7%2F</url>
    <content type="text"><![CDATA[CA 机构(Certificate Authority) CA中心又称CA机构，即证书授权中心(Certificate Authority )，或称证书授权机构，作为电子商务交易中受信任的第三方，承担公钥体系中公钥的合法性检验的责任。 全球有两种类型的证书颁发机构，主要分为两个部门：区域供应商和全球供应商。 因为证书验证通常可以通过当地国家的法律法规，但这些证书并不被全球所有浏览器承认，只能在自己国家的浏览器承认，然而持有跨国公司CA机构屈指可数，全球市场上约50个ssl证书颁发机构，中国之前有四家，后来沃通由于滥发证书被取消了CA机构资格，国内目前三家，这些CA机构签发的证书基本被全球所有的浏览器承认。 目前全球主流的CA机构有Comodo、Symantec、GeoTrust、DigiCert、Thawte、GlobalSign、RapidSSL等。 Symantec、GeoTrust都是DigiCert机构的子公司，目前市场上主流的ssl证书品牌是Comodo证书、Symantec证书、GeoTrust证书、Thawte证书和RapidSSL证书，还有一些不知名的证书机构也是可以颁发数字证书的。 CA颁发机构根据申请ssl证书类型可分为：域名验证型DV证书、组织验证型OV证书、扩展增强型EV证书，认证机构在检验过程中，申请人提交的CSR文件必须符合CA的要求，否则申请人需要重新提交文件。 申请SSL证书，首先就是生成CSR证书文件，将CSR文件发送给CA机构，CA机构核实证书的真实性，然后以自身的私钥给证书签名，将签名附加在证书上发回企业。企业将CSR和自己的私钥存储在服务器或本地驱动器上的安全位置。 CA机构在收到证书请求后，他们会对申请者进行验证。申请不同的SSL证书，其验证方式也不一样。其中提供的文件证明申请者的身份和商业注册取决于申请者的证书类型，如果客户提供的文件符合CA的要求，就会颁发证书。 近年来，部分CA机构为了推动ssl证书的使用，或者是为了牟利，推出免费的ssl证书，因为免费安全等级相对较低，某些CA机构并没有严格审核申请人的身份，导致部分钓鱼网站也可申请免费的ssl证书，为了避免类似事件再次发生，有些浏览器纷纷对相关CA机构作出不受信任的决策。 CA 证书 CA 也拥有一个证书（内含公钥和私钥）。网上的公众用户通过验证 CA 的签字从而信任 CA ，任何人都可以得到 CA 的证书（含公钥），用以验证它所签发的证书。CA机构的证书（包含公钥）一般会预置在操作系统或者浏览器。用于对用户证书进行认证。 证书格式 PEM 格式 1、一般是文本格式，可保存证书，可保存私钥。 2、PEM格式通常用于数字证书认证机构（Certificate Authorities，CA），扩展名为.pem, .crt, .cer, and .key。内容为Base64编码的ASCII码文件，有类似”—–BEGIN CERTIFICATE—–” 和 “—–END CERTIFICATE—–”的头尾标记。服务器认证证书，中级认证证书和私钥都可以储存为PEM格式（认证证书其实就是公钥）。Apache和类似的服务器使用PEM格式证书。 DER 格式 1、文件是二进制格式，只保存证书，不保存私钥。 2、DER格式与PEM不同之处在于其使用二进制而不是Base64编码的ASCII。扩展名为.der，但也经常使用.cer用作扩展名，所有类型的认证证书和私钥都可以存储为DER格式。Java使其典型使用平台。 PKCS#7/P7B 格式 1、文件是文本格式，只保存证书，不保存私钥。 2、PKCS#7 或 P7B格式通常以Base64的格式存储，扩展名为.p7b 或 .p7c，有类似BEGIN PKCS7—–” 和 “—–END PKCS7—–”的头尾标记。PKCS#7 或 P7B只能存储认证证书或证书路径中的证书（就是存储认证证书链，本级，上级，到根级都存到一个文件中）。不能存储私钥，Windows和Tomcat都支持这种格式。 PKCS#12/PFX 格式 1、二进制格式，同时包含证书和私钥，一般有密码保护。 2、PKCS#12 或 PFX格式是以加密的二进制形式存储服务器认证证书，中级认证证书和私钥。扩展名为.pfx 和 .p12，PXF通常用于Windows中导入导出认证证书和私钥。 证书格式转换方式 PEM to DER 12&gt; openssl x509 -outform der -in certificate.pem -out certificate.der&gt; PEM to P7B 12&gt; openssl crl2pkcs7 -nocrl -certfile certificate.cer -out certificate.p7b -certfile CACert.cer&gt; PEM to PFX 12&gt; openssl pkcs12 -export -out certificate.pfx -inkey privateKey.key -in certificate.crt -certfile CACert.crt&gt; DER to PEM 12&gt; openssl x509 -inform der -in certificate.cer -out certificate.pem&gt; P7B to PEM 12&gt; openssl pkcs7 -print_certs -in certificate.p7b -out certificate.cer&gt; PFX to PEM 12&gt; openssl pkcs12 -in certificate.pfx -out certificate.cer -nodes&gt; PXF转PEM后certificate.cer文件包含认证证书和私钥，需要把它们分开存储才能使用。 X509公钥证书标准结构 X.509是密码学里公钥证书的格式标准。X.509证书已应用在包括TLS/SSL在内的众多网络协议里，同时它也用在很多非在线应用场景里，比如电子签名服务。 X.509证书里含有公钥、身份信息（比如网络主机名，组织的名称或个体名称等）和签名信息（可以是证书签发机构CA的签名，也可以是自签名）。对于一份经由可信的证书签发机构签名或者可以通过其它方式验证的证书，证书的拥有者就可以用证书及相应的私钥来创建安全的通信，对文档进行数字签名。 另外除了证书本身功能，X.509还附带了证书吊销列表和用于从最终对证书进行签名的证书签发机构直到最终可信点为止的证书合法性验证算法。 X.509是ITU-T标准化部门基于他们之前的ASN.1定义的一套证书标准。 证书组成结构标准用ASN.1（一种标准的语言）来进行描述. X.509 v3 数字证书结构如下： 证书 版本号 序列号 签名算法 颁发者 证书有效期 此日期前无效 此日期后无效 主题 主题公钥信息 公钥算法 主题公钥 颁发者唯一身份信息（可选项） 主题唯一身份信息（可选项） 扩展信息（可选项） … 证书签名算法 数字签名 详细介绍：https://www.cnblogs.com/chnking/archive/2007/08/28/872104.html 申请证书 创建证书，CA机构签名 12345# private key 创建私钥$openssl genrsa -des3 -out server.key 1024 # generate csr 创建证书$openssl req -new -key server.key -out server.csr# 然后将csr文件提交给CA机构，通过CA机构的审核之后，CA机构用自己的私钥给证书签名，发回开发者 创建证书，自己签名 12345678910# MAC 系统 [流程](https://lamjack.github.io/2018/05/17/openssl-localhost-https/)# 创建CA私钥$ openssl genrsa -des3 -out CA.key 2048# 创建CA证书$ openssl req -x509 -new -nodes -key CA.key -sha256 -days 3650 -out CA.pem# 双击CA.pem,打开钥匙链，导入证书。邮件信任证书。# 创建v3.ext，具体配置见lamjack的博客vim v3.ext# 创建服务器SSL证书$ openssl x509 -req -in server.csr -CA CA.pem路径 -CAkey CA.key -CAcreateserial -out server.crt -days 500 -sha256 -extfile v3.ext 证书认证 拿到服务器的证书之后，获取证书的签发CA机构，并从系统或者浏览器获取该CA机构的证书。 用CA机构的公钥对用户证书中签名解密。 将解密内容和用户证书中的信息对比，验证用户证书的身份。 私钥 私钥主要用于签名和解密，由用户自定义，只有用户自己知道； 公钥 公钥用于签名验证和加密，可被多个用户共享。 参考资料 http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html https://segmentfault.com/a/1190000011675421 https://developer.android.com/training/articles/security-ssl?hl=zh-cn https://zh.wikipedia.org/wiki/X.509]]></content>
      <categories>
        <category>ca</category>
      </categories>
      <tags>
        <tag>证书</tag>
        <tag>ca</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 非SDK接口检测]]></title>
    <url>%2Fblog%2F2019%2F10%2F15%2FAndroid%20%E9%9D%9ESDK%20%E6%8E%A5%E5%8F%A3%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[非 SDK 接口限制 非SDK接口限制在Android P中就已提出，但是在Q中，被限制的接口的分类有较大变化。 非SDK接口介绍 为了确保应用稳定性和兼容性，Android 平台开始限制您的应用可在 Android 9（API 级别 28）中使用哪些非 SDK 接口。Android Q 包含更新后的受限非 SDK 接口列表（基于与 Android 开发者之间的协作以及最新的内部测试）。 非SDK接口限制就是某些SDK中的私用方法，如private方法，你通过Java反射等方法**获取并调用了。那么这些调用将在target&gt;=P或target&gt;=Q的设备上被限制使用，当你使用了这些方法后，会报错: 获取方法 报错信息 Dalvik instruction referencing a field NoSuchFieldError thrown Dalvik instruction referencing a method NoSuchMethodError thrown Reflection via Class.getDeclaredField() or Class.getField() NoSuchFieldException thrown Reflection via Class.getDeclaredMethod(), Class.getMethod() NoSuchMethodException thrown Reflection via Class.getDeclaredFields(), Class.getFields() Non-SDK members not in results Reflection via Class.getDeclaredMethods(), Class.getMethods() Non-SDK members not in results JNI via env-&gt;GetFieldID() NULL returned, NoSuchFieldError thrown JNI via env-&gt;GetMethodID() NULL returned, NoSuchMethodError thrown 非SDK接口查找 如果您不确定自己的应用是否使用了非 SDK 接口，则可以测试该应用进行确认 当你调用了非SDK接口时，会有类似Accessing hidden XXX的日志: 12Accessing hidden field Landroid/os/Message;-&gt;flags:I (light greylist, JNI)复制代码 但是一个大项目到底哪里使用了这些方法，靠review代码和看日志肯定是不现实的，谷歌官方也提供了官方检查器veridex用来检测一个apk中哪里使用了非SDK接口。veridex下载。Google地址 其中有windows,linux和mac版本，对应下载即可。下载解压后命令行cd到veridex目录下使用./appcompat.sh --dex-file=Q.apk即可自动扫描。Q.apk为包的绝对路径，如果包与veridex在相同目录下直接输入包文件名即可。 非SDK 介绍官方文档： https://developer.android.com/distribute/best-practices/develop/restrictions-non-sdk-interfaces?hl=zh-CN https://developer.android.google.cn/preview/non-sdk-q]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>veridex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Binder]]></title>
    <url>%2Fblog%2F2019%2F10%2F09%2Fandroid%20Binder%20%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[http://gityuan.com/tags/#binderhttps://blog.csdn.net/universus/article/details/6211589 https://www.cnblogs.com/lipeil/p/4895238.html]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>binder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dalvik 字节码]]></title>
    <url>%2Fblog%2F2019%2F09%2F11%2FDalvik%20optcode%2F</url>
    <content type="text"><![CDATA[Dalvik 字节码 通用设计 机器模型和调用规范旨在大致模仿常见的真实架构和 C 样式的调用规范： 机器基于寄存器，而帧的大小在创建时确定后就固定不变。每一帧由特定数量的寄存器（由相应方法指定）以及执行该方法所需的所有辅助数据构成，例如（但不限于）程序计数器和对包含该方法的 .dex 文件的引用。 当用于位值（例如整数和浮点数）时，寄存器会被视为宽度为 32 位。如果值是 64 位，则使用两个相邻的寄存器。对于寄存器对，没有对齐要求。 当用于对象引用时，寄存器会被视为其宽度能够正好容纳一个此类引用。 对于按位表示，(Object) null == (int) 0。 如果一个方法有 N 个参数，则在该方法的调用帧的最后 N 个寄存器中按顺序传递参数。较宽的参数占用两个寄存器。给实例方法传递一个 this 引用作为其第一个参数。 指令流中的存储单元是 16 位无符号数。某些指令中的某些位会被忽略/必须为 0。 指令并非一定限于特定类型。例如，在不做任何解释的情况下移动 32 位寄存器值的指令不一定非得指定是在移动整数还是浮点数。 对字符串、类型、字段和方法的引用有单独枚举和已编入索引的常量池。 按位字面数据在指令流中内嵌表示。 在实践中，一个方法需要 16 个以上的寄存器不太常见，而需要 8 个以上的寄存器却相当普遍，因此很多指令仅限于寻址前 16 个寄存器。在合理的可能情况下，指令允许引用最多前 256 个寄存器。此外，某些指令还具有允许更多寄存器的变体，包括可寻址 v0 - v65535 范围内的寄存器的一对 catch-all move 指令。如果指令变体不能用于寻址所需的寄存器，寄存器内容会（在运算前）从原始寄存器移动到低位寄存器和/或（在运算后）从低位结果寄存器移动到高位寄存器。 存在几个“伪指令”，用来容纳被常规指令（例如，fill-array-data）引用的可变长度数据有效负荷。在正常的执行流程中绝对不能遇到这类指令。此外，这类指令必须位于偶数字节码偏移（即以 4 字节对齐）上。为了满足这一要求，如果这类指令未对齐，则 dex 生成工具必须发出额外的 nop 指令来进行填充。最后，虽然并非必须这样做，但是大多数工具会选择在方法的末尾发出这些额外的指令，否则可能需要在这些方法周围分布额外的指令。 如果安装到正在运行的系统中，那么在安装过程中，静态链接优化可能会更改某些指令的格式。这样可以在链接已知之后加快执行的速度。有关建议的变体，请参阅相关的指令格式文档。使用“建议”一词是因为并非必须强制实施这些变体。 人类语法和助记符： 对参数进行 Dest-then-source 排序。 一些运算码具有消除歧义的名称后缀，这些后缀用来表明运算类型： 常规类型的 32 位运算码未标记。 常规类型的 64 位运算码以 -wide 为后缀。 特定类型的运算码以其类型（或简单缩写）为后缀，这些类型包括：-boolean、-byte、-char、-short、-int、-long、-float、-double、-object、-string、-class 和 -void。 一些运算码具有消除歧义的后缀，这些后缀用于区分具有不同指令版式或选项的相同运算。这些后缀与主要名称之间以斜杠（“/”）分开，主要目的是使生成和解析可执行文件的代码中存在与静态常量的一对一映射关系（即，降低让代码查看者感到模糊不清的可能性）。 在本文档的说明部分，我们使用 4 位宽的字符来强调值的宽度（例如，表示常量的范围或可能寻址的寄存器的数量）。 例如，在指令“ 1move-wide/from16 vAA, vBBBB ”中： “move”为基础运算码，表示这是基本运算（移动寄存器的值）。 “wide”为名称后缀，表示指令对较宽（64 位）数据进行运算。 “from16”为运算码后缀，表示具有 16 位寄存器引用源的变体。 “vAA”为目标寄存器（隐含在运算中；并且，规定目标参数始终在前），取值范围为 v0 - v255。 “vBBBB”为源寄存器，取值范围为 v0 - v65535。 请参阅指令格式文档，详细了解各种指令格式（在“运算和格式”下列出）以及运算码语法。 请参阅 .dex 文件格式文档，详细了解字节码如何融入整个编码环境。 字节码集合的总结 运算和格式 助记符/语法 参数 说明 00 10x nop 空循环。注意：数据传送伪指令用此运算码来标记，在这种情况下，运算码单元的高阶字节表示数据的性质。请参阅下文的“packed-switch-payload 格式”、“sparse-switch-payload 格式”和“fill-array-data-payload 格式”。 01 12x move vA, vB A: 目标寄存器（4 位） B: 源寄存器（4 位） 将一个非对象寄存器的内容移到另一个非对象寄存器中。 02 22x move/from16 vAA, vBBBB A: 目标寄存器（8 位） B: 源寄存器（16 位） 将一个非对象寄存器的内容移到另一个非对象寄存器中。 03 32x move/16 vAAAA, vBBBB A: 目标寄存器（16 位） B: 源寄存器（16 位） 将一个非对象寄存器的内容移到另一个非对象寄存器中。 04 12x move-wide vA, vB A: 目标寄存器对（4 位） B: 源寄存器对（4 位） 将一个寄存器对的内容移到另一个寄存器对中。注意：可以从 v*N* 移到 v*N-1* 或 v*N+1*，因此必须在执行写入运算之前，为要读取的寄存器对的两部分均安排实现。 05 22x move-wide/from16 vAA, vBBBB A: 目标寄存器对（8 位） B: 源寄存器对（16 位） 将一个寄存器对的内容移到另一个寄存器对中。注意：实现的注意事项与上文的 move-wide 相同。 06 32x move-wide/16 vAAAA, vBBBB A: 目标寄存器对（16 位） B: 源寄存器对（16 位） 将一个寄存器对的内容移到另一个寄存器对中。注意：实现的注意事项与上文的 move-wide 相同。 07 12x move-object vA, vB A: 目标寄存器（4 位） B: 源寄存器（4 位） 将一个对象传送寄存器的内容移到另一个对象传送寄存器中。 08 22x move-object/from16 vAA, vBBBB A: 目标寄存器（8 位） B: 源寄存器（16 位） 将一个对象传送寄存器的内容移到另一个对象传送寄存器中。 09 32x move-object/16 vAAAA, vBBBB A: 目标寄存器（16 位） B: 源寄存器（16 位） 将一个对象传送寄存器的内容移到另一个对象传送寄存器中。 0a 11x move-result vAA A: 目标寄存器（8 位） 将最新的 invoke-*kind* 的单字非对象结果移到指定的寄存器中。该指令必须紧跟在其（单字非对象）结果不会被忽略的 invoke-*kind* 之后执行，否则无效。 0b 11x move-result-wide vAA A: 目标寄存器对（8 位） 将最新的 invoke-*kind* 的双字结果移到指定的寄存器对中。该指令必须紧跟在其（双字）结果不会被忽略的 invoke-*kind* 之后执行，否则无效。 0c 11x move-result-object vAA A: 目标寄存器（8 位） 将最新的 invoke-*kind* 的对象结果移到指定的寄存器中。该指令必须紧跟在其（对象）结果不会被忽略的 invoke-*kind* 或 filled-new-array 之后执行，否则无效。 0d 11x move-exception vAA A: 目标寄存器（8 位） 将刚刚捕获的异常保存到给定寄存器中。该指令必须为捕获的异常不会被忽略的任何异常处理程序的第一条指令，且该指令必须仅作为异常处理程序的第一条指令执行，否则无效。 0e 10x return-void 从 void 方法返回。 0f 11x return vAA A: 返回值寄存器（8 位） 从单字宽度（32 位）非对象值返回方法返回。 10 11x return-wide vAA A: 返回值寄存器对（8 位） 从双字宽度（64 位）值返回方法返回。 11 11x return-object vAA A: 返回值寄存器（8 位） 从对象返回方法返回。 12 11n const/4 vA, #+B A: 目标寄存器（4 位） B: 有符号整数（4 位） 将给定的字面值（符号扩展为 32 位）移到指定的寄存器中。 13 21s const/16 vAA, #+BBBB A: 目标寄存器（8 位） B: 有符号整数（16 位） 将给定的字面值（符号扩展为 32 位）移到指定的寄存器中。 14 31i const vAA, #+BBBBBBBB A: 目标寄存器（8 位） B: 任意 32 位常量 将给定的字面值移到指定的寄存器中。 15 21h const/high16 vAA, #+BBBB0000 A: 目标寄存器（8 位） B: 有符号整数（16 位） 将给定的字面值（右零扩展为 32 位）移到指定的寄存器中。 16 21s const-wide/16 vAA, #+BBBB A: 目标寄存器（8 位） B: 有符号整数（16 位） 将给定的字面值（符号扩展为 64 位）移到指定的寄存器对中。 17 31i const-wide/32 vAA, #+BBBBBBBB A: 目标寄存器（8 位） B: 有符号整数（32 位） 将给定的字面值（符号扩展为 64 位）移到指定的寄存器对中。 18 51l const-wide vAA, #+BBBBBBBBBBBBBBBB A: 目标寄存器（8 位） B: 任意双字宽度（64 位）常量 将给定的字面值移到指定的寄存器对中。 19 21h const-wide/high16 vAA, #+BBBB000000000000 A: 目标寄存器（8 位） B: 有符号整数（16 位） 将给定的字面值（右零扩展为 64 位）移到指定的寄存器对中。 1a 21c const-string vAA, string@BBBB A: 目标寄存器（8 位） B: 字符串索引 将通过给定的索引获取的字符串引用移到指定的寄存器中。 1b 31c const-string/jumbo vAA, string@BBBBBBBB A: 目标寄存器（8 位） B: 字符串索引 将通过给定的索引获取的字符串引用移到指定的寄存器中。 1c 21c const-class vAA, type@BBBB A: 目标寄存器（8 位） B: 类型索引 将通过给定的索引获取的类引用移到指定的寄存器中。如果指定的类型是原始类型，则将存储对原始类型的退化类的引用。 1d 11x monitor-enter vAA A: 引用传送寄存器（8 位） 获取指定对象的监视锁。 1e 11x monitor-exit vAA A: 引用传送寄存器（8 位） 释放指定对象的监视锁。注意：如果该指令需要抛出异常，则必须以 pc 已提前超出该指令的方式抛出。不妨将其想象成，该指令（在一定意义上）已成功执行，并且在该指令之后但又在下一条指令找到机会执行之前抛出异常。这种定义使得某个方法有可能将监视锁清理 catch-all（例如 finally）分块用作分块自身的监视锁清理，以便处理可能由于 Thread.stop() 的既往实现而抛出的任意异常，同时仍尽力维持适当程度的监视锁安全机制。 1f 21c check-cast vAA, type@BBBB A: 引用传送寄存器（8 位） B: 类型索引（16 位） 如果给定寄存器中的引用不能转型为指定的类型，则抛出 ClassCastException。注意：由于 A 必须一律为引用值（而非原始值），因此如果 B 引用原始类型，则必然会在运行时失败（即抛出异常）。 20 22c instance-of vA, vB, type@CCCC A: 目标寄存器（4 位） B: 引用传送寄存器（4 位） C: 类型索引（16 位） 如果指定的引用是给定类型的实例，则为给定目标寄存器赋值 1，否则赋值 0。注意：由于 B 必须一律为引用值（而非原始值），因此如果 C 引用原始类型，则始终赋值 0。 21 12x array-length vA, vB A: 目标寄存器（4 位） B: 数组引用传送寄存器（4 位） 将指定数组的长度（条目个数）赋值给给定目标寄存器 22 21c new-instance vAA, type@BBBB A: 目标寄存器（8 位） B: 类型索引 根据指定的类型构造新实例，并将对该新实例的引用存储到目标寄存器中。该类型必须引用非数组类。 23 22c new-array vA, vB, type@CCCC A: 目标寄存器（4 位） B: 大小寄存器 C: 类型索引 根据指定的类型和大小构造新数组。该类型必须是数组类型。 24 35c filled-new-array {vC, vD, vE, vF, vG}, type@BBBB A: 数组大小和参数字数（4 位） B: 类型索引（16 位） C..G: 参数寄存器（每个寄存器各占 4 位） 根据给定类型和大小构造数组，并使用提供的内容填充该数组。该类型必须是数组类型。数组的内容必须是单字类型（即不接受 long 或 double 类型的数组，但接受引用类型的数组）。构造的实例会存储为一个“结果”，方式与方法调用指令存储其结果的方式相同，因此构造的实例必须移到后面紧跟 move-result-object 指令（如果要使用的话）的寄存器。 25 3rc filled-new-array/range {vCCCC .. vNNNN}, type@BBBB A: 数组大小和参数字数（8 位） B: 类型索引（16 位） C: 第一个参数寄存器（16 位） N = A + C - 1 根据给定类型和大小构造数组，并使用提供的内容填充该数组。相关的说明和限制与上文所述 filled-new-array 的相同。 26 31t fill-array-data vAA, +BBBBBBBB（有关补充数据，请参阅下文的“fill-array-data-payload 格式”） A: 数组引用（8 位） B: 到表格数据伪指令的有符号“分支”偏移量（32 位） 用指定的数据填充给定数组。必须引用原始类型的数组，且数据表格的类型必须与数组匹配；此外，数据表格所包含的元素个数不得超出数组中的元素个数。也就是说，数组可能比表格大；如果是这样，仅设置数组的初始元素，而忽略剩余元素。 27 11x throw vAA A: 异常传送寄存器（8 位） 抛出指定的异常。 28 10t goto +AA A: 有符号分支偏移量（8 位） 无条件地跳转到指定的指令。注意：分支偏移量不得为 0。（自旋循环可以用 goto/32 或通过在分支之前添加 nop 作为目标来正常构造）。 29 20t goto/16 +AAAA A: 有符号分支偏移量（16 位） 无条件地跳转到指定的指令。注意：分支偏移量不得为 0。（自旋循环可以用 goto/32 或通过在分支之前添加 nop 作为目标来正常构造）。 2a 30t goto/32 +AAAAAAAA A: 有符号分支偏移量（32 位） 无条件地跳转到指定的指令。 2b 31t packed-switch vAA, +BBBBBBBB（有关补充数据，请参阅下文的“packed-switch-payload 格式”） A: 要测试的寄存器 B: 到表格数据伪指令的有符号“分支”偏移量（32 位） 通过使用与特定整数范围内的每个值相对应的偏移量表，基于给定寄存器中的值跳转到新指令；如果没有匹配项，则跳转到下一条指令。 2c 31t sparse-switch vAA, +BBBBBBBB（有关补充数据，请参阅下文的“sparse-switch-payload 格式”） A: 要测试的寄存器 B: 到表格数据伪指令的有符号“分支”偏移量（32 位） 通过使用偏移值对的有序表，基于给定寄存器中的值跳转到新指令；如果没有匹配项，则跳转到下一条指令。 2d..31 23x cmpkind vAA, vBB, vCC 2d: cmpl-float (lt bias) 2e: cmpg-float (gt bias) 2f: cmpl-double (lt bias) 30: cmpg-double (gt bias) 31: cmp-long A: 目标寄存器（8 位） B: 第一个源寄存器或寄存器对 C: 第二个源寄存器或寄存器对 执行指定的浮点或 long 比较；如果 b == c，则将 a 设为 0，如果 b &gt; c，则设为 1，或者，如果 b &lt; c，则设为 -1。浮点运算列出的“bias”表示如何处理 NaN 比较：对于 NaN 比较，“gt bias”指令返回 1，而“lt bias”指令返回 -1。例如，建议使用 cmpg-float 来检查浮点数是否满足条件 x &lt; y；如果结果是 -1，则表示测试为 true，其他值则表示测试为 false，原因是当前比较是有效比较但是结果不符合预期或其中一个值是 NaN。 32..37 22t if-test vA, vB, +CCCC 32: if-eq 33: if-ne 34: if-lt 35: if-ge 36: if-gt 37: if-le A: 要测试的第一个寄存器（4 位） B: 要测试的第二个寄存器（4 位） C: 有符号分支偏移量（16 位） 如果两个给定寄存器的值比较结果符合预期，则分支到给定目标寄存器。注意：分支偏移量不得为 0。（自旋循环可以通过围绕后向 goto 进行分支或通过在分支之前添加 nop 作为目标来正常构造。） 38..3d 21t if-testz vAA, +BBBB 38: if-eqz 39: if-nez 3a: if-ltz 3b: if-gez 3c: if-gtz 3d: if-lez A: 要测试的寄存器（8 位） B: 有符号分支偏移量（16 位） 如果给定寄存器的值与 0 的比较结果符合预期，则分支到给定目标寄存器。注意：分支偏移量不得为 0。（自旋循环可以通过围绕后向 goto 进行分支或通过在分支之前添加 nop 作为目标来正常构造。） 3e..43 10x （未使用） （未使用） 44..51 23x arrayop vAA, vBB, vCC 44: aget 45: aget-wide 46: aget-object 47: aget-boolean 48: aget-byte 49: aget-char 4a: aget-short 4b: aput 4c: aput-wide 4d: aput-object 4e: aput-boolean 4f: aput-byte 50: aput-char 51: aput-short A: 值寄存器或寄存器对；可以是源寄存器，也可以是目标寄存器（8 位） B: 数组寄存器（8 位） C: 索引寄存器（8 位） 在给定数组的已标识索引处执行已确定的数组运算，并将结果加载或存储到值寄存器中。 52..5f 22c iinstanceop vA, vB, field@CCCC 52: iget 53: iget-wide 54: iget-object 55: iget-boolean 56: iget-byte 57: iget-char 58: iget-short 59: iput 5a: iput-wide 5b: iput-object 5c: iput-boolean 5d: iput-byte 5e: iput-char 5f: iput-short A: 值寄存器或寄存器对；可以是源寄存器，也可以是目标寄存器（4 位） B: 对象寄存器（4 位） C: 实例字段引用索引（16 位） 对已标识的字段执行已确定的对象实例字段运算，并将结果加载或存储到值寄存器中。注意：这些运算码是静态链接的合理候选项，将字段参数更改为更直接的偏移量。 60..6d 21c sstaticop vAA, field@BBBB 60: sget 61: sget-wide 62: sget-object 63: sget-boolean 64: sget-byte 65: sget-char 66: sget-short 67: sput 68: sput-wide 69: sput-object 6a: sput-boolean 6b: sput-byte 6c: sput-char 6d: sput-short A: 值寄存器或寄存器对；可以是源寄存器，也可以是目标寄存器（8 位） B: 静态字段引用索引（16 位） 对已标识的静态字段执行已确定的对象静态字段运算，并将结果加载或存储到值寄存器中。注意：这些运算码是静态链接的合理候选项，将字段参数更改为更直接的偏移量。 6e..72 35c invoke-kind {vC, vD, vE, vF, vG}, meth@BBBB 6e: invoke-virtual 6f: invoke-super 70: invoke-direct 71: invoke-static 72: invoke-interface A: 参数字数（4 位） B: 方法引用索引（16 位） C..G: 参数寄存器（每个寄存器各占 4 位） 调用指定的方法。所得结果（如果有的话）可能与紧跟其后的相应 move-result* 变体指令一起存储。使用 invoke-virtual 调用正常的虚方法（该方法不是 private、static 或 final，也不是构造函数）。当 method_id 引用非接口类方法时，使用 invoke-super 调用最近超类的虚方法（这与调用类中具有相同 method_id 的方法相反）。invoke-virtual 具有相同的方法限制。在版本 037 或更高版本的 Dex 文件中，如果 method_id 引用接口方法，则使用 invoke-super 来调用在该接口上定义的该方法的最具体、未被覆盖版本。invoke-virtual 具有相同的方法限制。在版本 037 之前的 Dex 文件中，具有接口 method_id 是不当且未定义的。invoke-direct 用于调用非 static 直接方法（也就是说，本质上不可覆盖的实例方法，即 private 实例方法或构造函数）。invoke-static 用于调用 static 方法（该方法始终被视为直接方法）。invoke-interface 用于调用 interface 方法，也就是说，在具体类未知的对象上，使用引用 interface 的 method_id。注意：这些运算码是静态链接的合理候选项，将方法参数更改为更直接的偏移量（或相关的寄存器对）。 73 10x （未使用） （未使用） 74..78 3rc invoke-kind/range {vCCCC .. vNNNN}, meth@BBBB 74: invoke-virtual/range 75: invoke-super/range 76: invoke-direct/range 77: invoke-static/range 78: invoke-interface/range A: 参数字数（8 位） B: 方法引用索引（16 位） C: 第一个参数寄存器（16 位） N = A + C - 1 调用指定的方法。有关详情、注意事项和建议，请参阅上文第一个 invoke-*kind* 说明。 79..7a 10x （未使用） （未使用） 7b..8f 12x unop vA, vB 7b: neg-int 7c: not-int 7d: neg-long 7e: not-long 7f: neg-float 80: neg-double 81: int-to-long 82: int-to-float 83: int-to-double 84: long-to-int 85: long-to-float 86: long-to-double 87: float-to-int 88: float-to-long 89: float-to-double 8a: double-to-int 8b: double-to-long 8c: double-to-float 8d: int-to-byte 8e: int-to-char 8f: int-to-short A: 目标寄存器或寄存器对（4 位） B: 源寄存器或寄存器对（4 位） 对源寄存器执行已确定的一元运算，并将结果存储到目标寄存器中。 90..af 23x binop vAA, vBB, vCC 90: add-int 91: sub-int 92: mul-int 93: div-int 94: rem-int 95: and-int 96: or-int 97: xor-int 98: shl-int 99: shr-int 9a: ushr-int 9b: add-long 9c: sub-long 9d: mul-long 9e: div-long 9f: rem-long a0: and-long a1: or-long a2: xor-long a3: shl-long a4: shr-long a5: ushr-long a6: add-float a7: sub-float a8: mul-float a9: div-float aa: rem-float ab: add-double ac: sub-double ad: mul-double ae: div-double af: rem-double A: 目标寄存器或寄存器对（8 位） B: 第一个源寄存器或寄存器对（8 位） C: 第二个源寄存器或寄存器对（8 位） 对两个源寄存器执行已确定的二元运算，并将结果存储到目标寄存器中。注意：与其他 -long 数学运算（对第一个和第二个源寄存器都采用寄存器对的运算）相反，shl-long、shr-long 和 ushr-long 会对其第一个源寄存器采用寄存器对（存放要移动的值），但会对其第二个源寄存器采用单个寄存器（存放移动的距离）。 b0..cf 12x binop/2addr vA, vB b0: add-int/2addr b1: sub-int/2addr b2: mul-int/2addr b3: div-int/2addr b4: rem-int/2addr b5: and-int/2addr b6: or-int/2addr b7: xor-int/2addr b8: shl-int/2addr b9: shr-int/2addr ba: ushr-int/2addr bb: add-long/2addr bc: sub-long/2addr bd: mul-long/2addr be: div-long/2addr bf: rem-long/2addr c0: and-long/2addr c1: or-long/2addr c2: xor-long/2addr c3: shl-long/2addr c4: shr-long/2addr c5: ushr-long/2addr c6: add-float/2addr c7: sub-float/2addr c8: mul-float/2addr c9: div-float/2addr ca: rem-float/2addr cb: add-double/2addr cc: sub-double/2addr cd: mul-double/2addr ce: div-double/2addr cf: rem-double/2addr A: 目标寄存器和第一个源寄存器或寄存器对（4 位） B: 第二个源寄存器或寄存器对（4 位） 对两个源寄存器执行已确定的二元运算，并将结果存储到第一个源寄存器中。注意：与其他 -long/2addr 数学运算（对其目标寄存器/第一个源寄存器和第二个源寄存器都采用寄存器对的运算）相反，shl-long/2addr、shr-long/2addr 和 ushr-long/2addr 会对其目标寄存器/第一个源寄存器采用寄存器对（存放要移动的值），但会对其第二个源寄存器采用单个寄存器（存放移动的距离）。 d0..d7 22s binop/lit16 vA, vB, #+CCCC d0: add-int/lit16 d1: rsub-int (reverse subtract) d2: mul-int/lit16 d3: div-int/lit16 d4: rem-int/lit16 d5: and-int/lit16 d6: or-int/lit16 d7: xor-int/lit16 A: 目标寄存器（4 位） B: 源寄存器（4 位） C: 有符号整数常量（16 位） 对指定的寄存器（第一个参数）和字面值（第二个参数）执行指定的二元运算，并将结果存储到目标寄存器中。注意：rsub-int 不含后缀，因为此版本是其一系列运算码中的主运算码。另外，有关语义的详细信息，请参阅下文。 d8..e2 22b binop/lit8 vAA, vBB, #+CC d8: add-int/lit8 d9: rsub-int/lit8 da: mul-int/lit8 db: div-int/lit8 dc: rem-int/lit8 dd: and-int/lit8 de: or-int/lit8 df: xor-int/lit8 e0: shl-int/lit8 e1: shr-int/lit8 e2: ushr-int/lit8 A: 目标寄存器（8 位） B: 源寄存器（8 位） C: 有符号整数常量（8 位） 对指定的寄存器（第一个参数）和字面值（第二个参数）执行指定的二元运算，并将结果存储到目标寄存器中。注意：有关 rsub-int 语义的详细信息，请参阅下文。 e3..f9 10x （未使用） （未使用） fa 45cc invoke-polymorphic {vC, vD, vE, vF, vG}, meth@BBBB, proto@HHHH A: 参数字数（4 位） B: 方法引用索引（16 位） C: 接收器（16 位） D..G: 参数寄存器（每个寄存器各占 4 位） H: 原型引用索引（16 位） 调用指定的签名多态方法。所得结果（如果有的话）可能与紧跟其后的相应 move-result* 变体指令一起存储。 方法引用必须针对签名多态方法，比如 java.lang.invoke.MethodHandle.invoke 或 java.lang.invoke.MethodHandle.invokeExact。 接收器必须是一个支持所调用签名多态方法的对象。 原型引用说明了所提供的参数类型和预期的返回类型。 invoke-polymorphic 字节码执行时可能会引发异常。有关这些异常的相关说明，请参阅所调用签名多态方法的 API 文档。 存在于 038 和更高版本的 Dex 文件中。 fb 4rcc invoke-polymorphic/range {vCCCC .. vNNNN}, meth@BBBB, proto@HHHH A: 参数字数（8 位） B: 方法引用索引（16 位） C: 接收器（16 位） H: 原型引用索引（16 位） N = A + C - 1 调用指定的方法句柄。有关详情，请参阅上文的 invoke-polymorphic 说明。 存在于版本 038 及更高版本的 Dex 文件中。 fc 35c invoke-custom {vC, vD, vE, vF, vG}, call_site@BBBB A: 参数字数（4 位） B: 调用点引用索引（16 位） C..G: 参数寄存器（每个寄存器各占 4 位） 解析并调用指定的调用点。调用的结果（如果有的话）可能与紧跟其后的相应 move-result* 变体指令一起存储。 该指令分两个阶段执行：调用点解析和调用点调用。 调用点解析会检查指定的调用点是否有关联的 java.lang.invoke.CallSite 实例。如果没有，则使用 Dex 文件中存在的参数调用指定调用点的引导程序链接器方法（请参阅 call_site_item）。引导程序链接器方法会返回一个 java.lang.invoke.CallSite 实例；如果不存在关联，则该实例将与指定的调用点关联。另一个线程可能已先进行了关联；如果是这种情况，则通过第一个关联的 java.lang.invoke.CallSite 实例继续执行该指令。 对 java.lang.invoke.MethodHandle 目标进行调用点调用，该目标属于所解析的 java.lang.invoke.CallSite 实例。目标的调用就像执行 invoke-polymorphic（如上所述）一样（使用 invoke-custom 指令的方法句柄和参数作为精确方法句柄调用的参数）。 引导程序链接器方法引发的异常会封装在 java.lang.BootstrapMethodError 中。如果出现下列情况，还将引发 BootstrapMethodError：该引导程序链接器方法无法返回 java.lang.invoke.CallSite 实例。返回的 java.lang.invoke.CallSite 具有 null 方法句柄目标。该方法句柄目标不属于所请求的类型。存在于版本 038 及更高版本的 Dex 文件中。 fd 3rc invoke-custom/range {vCCCC .. vNNNN}, call_site@BBBB A: 参数字数（8 位） B: 调用点引用索引（16 位） C: 第一个参数寄存器（16 位） N = A + C - 1 解析并调用一个调用点。有关详情，请参阅上文的 invoke-custom 说明。 存在于版本 038 及更高版本的 Dex 文件中。 fe 21c const-method-handle vAA, method_handle@BBBB A: 目标寄存器（8 位） B: 方法句柄索引（16 位） 将通过特定索引指定的方法句柄的引用移到指定的寄存器中。 存在于版本 039 及更高版本的 Dex 文件中。 ff 21c const-method-type vAA, proto@BBBB A: 目标寄存器（8 位） B: 方法原型引用（16 位） 将通过特定索引指定的方法原型的引用移到指定的寄存器中。 存在于版本 039 及更高版本的 Dex 文件中。 packed-switch-payload 格式 名称 格式 说明 ident ushort = 0x0100 识别伪运算码 size ushort 表格中的条目数 first_key int 第一位（即最低位）switch case 的值 targets int[] 与 size 相对的分支目标的列表。这些目标相对应的是 switch 运算码的地址（而非此表格的地址）。 注意：此表格一个实例的代码单元总数为 (size * 2) + 4。 sparse-switch-payload 格式 名称 格式 说明 ident ushort = 0x0200 识别伪运算码 size ushort 表格中的条目数 keys int[] size 键值列表，从低到高排序 targets int[] 与 size 相对应的分支目标的列表，每一个目标对应相同索引下的键值。这些目标相对应的是 switch 运算码的地址（而非此表格的地址）。 注意：此表格一个实例的代码单元总数为 (size * 4) + 2。 fill-array-data-payload 格式 名称 格式 说明 ident ushort = 0x0300 识别伪运算码 element_width ushort 每个元素的字节数 size uint 表格中的元素数 data ubyte[] 数据值 注意：此表格一个实例的代码单元总数为 (size * element_width + 1) / 2 + 4。 数学运算详情 注意：除非另有说明，否则浮点运算必须遵循 IEEE 754 规则，使用最近舍入和渐进式下溢。 运算码 C 语义 备注 neg-int int32 a; int32 result = -a; 一元二进制补码。 not-int int32 a; int32 result = ~a; 一元反码。 neg-long int64 a; int64 result = -a; 一元二进制补码。 not-long int64 a; int64 result = ~a; 一元反码。 neg-float float a; float result = -a; 浮点否定。 neg-double double a; double result = -a; 浮点否定。 int-to-long int32 a; int64 result = (int64) a; 将 int32 符号扩展为 int64。 int-to-float int32 a; float result = (float) a; 使用最近舍入，将 int32 转换为 float。这会导致某些值不够精准。 int-to-double int32 a; double result = (double) a; 将 int32 转换为 double。 long-to-int int64 a; int32 result = (int32) a; 将 int64 截断为 int32。 long-to-float int64 a; float result = (float) a; 使用最近舍入，将 int64 转换为 float。这会导致某些值不够精准。 long-to-double int64 a; double result = (double) a; 使用最近舍入，将 int64 转换为 double。这会导致某些值不够精准。 float-to-int float a; int32 result = (int32) a; 使用向零舍入，将 float 转换为 int32。NaN 和 -0.0（负零）转换为整数 0。无穷数和因所占幅面过大而无法表示的值根据符号转换为 0x7fffffff 或 -0x80000000。 float-to-long float a; int64 result = (int64) a; 使用向零舍入，将 float 转换为 int64。适用于 float-to-int 的特殊情况规则也适用于此，但超出范围的值除外，这些值根据符号转换为 0x7fffffffffffffff 或 -0x8000000000000000。 float-to-double float a; double result = (double) a; 将 float 转换为 double，值依然精准。 double-to-int double a; int32 result = (int32) a; 使用向零舍入，将 double 转换为 int32。适用于 float-to-int 的特殊情况规则也适用于此。 double-to-long double a; int64 result = (int64) a; 使用向零舍入，将 double 转换为 int64。适用于 float-to-long 的特殊情况规则也适用于此。 double-to-float double a; float result = (float) a; 使用最近舍入，将 double 转换为 float。这会导致某些值不够精准。 int-to-byte int32 a; int32 result = (a &lt;&lt; 24) &gt;&gt; 24; 符号扩展结果，将 int32 截断为 int8。 int-to-char int32 a; int32 result = a &amp; 0xffff; 无需符号扩展，将 int32 截断为 uint16。 int-to-short int32 a; int32 result = (a &lt;&lt; 16) &gt;&gt; 16; 符号扩展结果，将 int32 截断为 int16。 add-int int32 a, b; int32 result = a + b; 二进制补码加法。 sub-int int32 a, b; int32 result = a - b; 二进制补码减法。 rsub-int int32 a, b; int32 result = b - a; 二进制补码反向减法。 mul-int int32 a, b; int32 result = a * b; 二进制补码乘法。 div-int int32 a, b; int32 result = a / b; 二进制补码除法，向零舍入（即截断为整数）。如果 b == 0，则会抛出 ArithmeticException。 rem-int int32 a, b; int32 result = a % b; 二进制补码除后取余数。结果的符号与 a 的符号相同，可更精确地定义为 result == a - (a / b) * b。如果 b == 0，则会抛出 ArithmeticException。 and-int int32 a, b; int32 result = a &amp; b; 按位 AND。 or-int int32 a, b; int32 result = a | b; 按位 OR。 xor-int int32 a, b; int32 result = a ^ b; 按位 XOR。 shl-int int32 a, b; int32 result = a &lt;&lt; (b &amp; 0x1f); 按位左移（带掩码参数）。 shr-int int32 a, b; int32 result = a &gt;&gt; (b &amp; 0x1f); 按位有符号右移（带掩码参数）。 ushr-int uint32 a, b; int32 result = a &gt;&gt; (b &amp; 0x1f); 按位无符号右移（带掩码参数）。 add-long int64 a, b; int64 result = a + b; 二进制补码加法。 sub-long int64 a, b; int64 result = a - b; 二进制补码减法。 mul-long int64 a, b; int64 result = a * b; 二进制补码乘法。 div-long int64 a, b; int64 result = a / b; 二进制补码除法，向零舍入（即截断为整数）。如果 b == 0，则会抛出 ArithmeticException。 rem-long int64 a, b; int64 result = a % b; 二进制补码除后取余数。结果的符号与 a 的符号相同，可更精确地定义为 result == a - (a / b) * b。如果 b == 0，则会抛出 ArithmeticException。 and-long int64 a, b; int64 result = a &amp; b; 按位 AND。 or-long int64 a, b; int64 result = a | b; 按位 OR。 xor-long int64 a, b; int64 result = a ^ b; 按位 XOR。 shl-long int64 a; int32 b; int64 result = a &lt;&lt; (b &amp; 0x3f); 按位左移（带掩码参数）。 shr-long int64 a; int32 b; int64 result = a &gt;&gt; (b &amp; 0x3f); 按位有符号右移（带掩码参数）。 ushr-long uint64 a; int32 b; int64 result = a &gt;&gt; (b &amp; 0x3f); 按位无符号右移（带掩码参数）。 add-float float a, b; float result = a + b; 浮点加法。 sub-float float a, b; float result = a - b; 浮点减法。 mul-float float a, b; float result = a * b; 浮点乘法。 div-float float a, b; float result = a / b; 浮点除法。 rem-float float a, b; float result = a % b; 浮点除后取余数。该函数不同于 IEEE 754 取余，定义为 result == a - roundTowardZero(a / b) * b。 add-double double a, b; double result = a + b; 浮点加法。 sub-double double a, b; double result = a - b; 浮点减法。 mul-double double a, b; double result = a * b; 浮点乘法。 div-double double a, b; double result = a / b; 浮点除法。 rem-double double a, b; double result = a % b; 浮点除后取余数。该函数不同于 IEEE 754 取余，定义为 result == a - roundTowardZero(a / b) * b。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>dalvik</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 动态调试无源码的APK]]></title>
    <url>%2Fblog%2F2019%2F09%2F11%2FAndroid%20Studio%20%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E6%97%A0%E6%BA%90%E7%A0%81APK%2F</url>
    <content type="text"><![CDATA[安装Android Studio 插件 smalidea-0.05.zip 插件源码地址 ： https://github.com/JesusFreke/smali Android Studio 尽量升级到最新版本 确保APK可调试 1、root 手机，然后刷mprop 将手机刷为可以调试。推荐 2、使用模拟器，模拟器一般都是可以调试的。 3、apktool 逆向 apk，修改AndroidManifest debuggable属性，然后重新打包安装。 apktools d test.apk 逆向apk apktools https://ibotpeaches.github.io/Apktool/ Android Studio 导入 上一步得到的文件夹 然后右键工程主目录：Mark Directory As -&gt; Sources Root 项目目录–&gt;右键–&gt;Open ModuleSettings：设置sdk，最后和测试手机的系统版本一致 接下来配置：Run/Debug Configurations里面的配置文件，打开后我们点击左上角的+，然后选择Remote，添加一个远程调试。端口配置为8700，和DDMS 中进程调试端口号保持一致。PS：默认为5005. 手机上启动APP，打开DDMS 即Android/sdk/tools/monitor。选中app对应的进程，后面会显示8700字样。另外如果手机可以调试，最上面设备行末尾会显示debug字样。 在Android studio 上面设置断点 点击右上角的调试按钮，然后点击手机上的APP内按钮。即可以进入调试状态。 参考文章 https://www.jianshu.com/p/1a28e6439c6a]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac IDA Android Dex 模拟器、真机 动态调试]]></title>
    <url>%2Fblog%2F2019%2F09%2F11%2FAndroid%20Dex%20%E7%9C%9F%E6%9C%BA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[JDWP(Java Debug Wire Protocol) JDWP（Java Debug Wire Protocol）是一个为 Java 调试而设计的一个通讯交互协议，它定义了调试器和被调试程序之间传递的信息的格式。在 JPDA 体系中，作为前端（front-end）的调试者（debugger）进程和后端（back-end）的被调试程序（debuggee）进程之间的交互数据的格式就是由 JDWP 来描述的，它详细完整地定义了请求命令、回应数据和错误代码，保证了前端和后端的 JVMTI 和 JDI 的通信通畅。比如在 Sun 公司提供的实现中，它提供了一个名为 jdwp.dll（jdwp.so）的动态链接库文件，这个动态库文件实现了一个 Agent，它会负责解析前端发出的请求或者命令，并将其转化为 JVMTI 调用，然后将 JVMTI 函数的返回值封装成 JDWP 数据发还给后端。 参考 https://qsli.github.io/2018/08/12/jdwp/ https://www.ibm.com/developerworks/cn/java/j-lo-jpda3/index.html JDB(Java Debugger) Java™ 调试器 (JDB) 包含在 SDK 中。 该调试器通过 jdb 命令启动；它使用 JPDA 连接到 JVM。 https://www.ibm.com/developerworks/cn/java/joy-jdb/index.html https://www.ibm.com/support/knowledgecenter/zh/SSYKE2_7.0.0/com.ibm.java.win.70.doc/user/jdb.html 动态调试，参考 https://bbs.pediy.com/thread-217612.htm 端口可以使用23946，使用IDA的时候需要关掉DDMS、AS等。如果出现异常可能是APK做了反逆向。 如果真机碰到问题，可以先试试用模拟器]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>IDA</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac IDA Pro逆向 android]]></title>
    <url>%2Fblog%2F2019%2F09%2F09%2FMac%20%2B%20IDA%20Pro%207.0%2F</url>
    <content type="text"><![CDATA[硬件设备 MAC PRO 10.14 nexus 5s, android 6.0 Mac 下载IDA Pro 7.0 IDA 7.0 Mac 下载地址 https://xclient.info/s/hex-rays-ida-pro.html#versions IDA 在Mac 10.14上出现崩溃的解决方案 https://github.com/fjh658/IDA7.0_SP PS: 安装的时候需要输入密码，密码在网站上有 IDA 调试环境配置 1234567cd /Applications/IDA Pro 7.0/dbgsrvadb push android_server /data #将文件拷贝到手机data目录adb shellcd /datachmod 755 android_server #更改权限，赋予可执行权限./android_server #运行root@Che1:/data # ./android_server 出现 bind: Address already in use 错误 12ps | grep android_server kill -s 9 端口转发 1adb forward tcp:23946 tcp:23946 以debug模式启动APP 1adb shell am start -D -n com.pa.test.devicetest/.MainActivity 启动IDA，Debugger-&gt;attach-&gt;Remote ARMLinux/Android debugger 参考：https://blog.csdn.net/daide2012/article/details/75675210 JDB 连接, 端口号可以通过DDMS 查看当前运行进程和端口号 1jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700 java.net.ConnectException: Connection refused 出现如上异常的原因是app 不可以debugable，解决方案： 1、如果是自己的app，可以在AndroidManifest.xml 中 application节点上加上 debugable = true 2、如果是别人的app，可以解压之后修改AndroidManifest.xml文件，然后重新打包签名 3、修改系统属性，将defalut.prop中ro.debugable设置为1，然后刷机进去； 4、通过mprop 工具修改 内存中的ro.debugable值 https://www.bodkin.ren/index.php/archives/533/ 5、通过基于Xposed的 BDOpener 工具修改程序的 debugable 值 https://security.tencent.com/index.php/opensource/detail/17 mprop修改ro.debugable 12345678910111213141516171819# 下载 mprop https://github.com/wpvsyou/mpropgit clone git@github.com:wpvsyou/mprop.git# 将mprop 推到手机adb push mprop /data/local/tmpadb shell # 查看 硬盘中的 属性cat default.prop | grep debug # 查看 内存中的属性getprop ro.debuggablesucd /data/local/tmp# 修改内存中属性./mprop ro.debuggable 1# 重启adbd 生效stop;start# 查看 硬盘中的 属性cat default.prop | grep debug # 查看 内存中的属性getprop ro.debuggable DDMS 最新版本的AS IDE删掉了DDMS入口，需要去tools里面用shell启动。 1cd ~/Library/Android/sdk/tools/monitor 启动IDA，attach android进程之后，需要去找到需要的so文件，快捷键control+F 12Android 4.4版本之前 系统函数在libdvm.soAndroid 5.0之后 系统函数在libart.so 选中so文件之后，需要查找对应的方法，快捷键control+F。然后右键添加断点。 12libdvm.so 对应的是 dvmDexFileOpenPartial方法libart.so 对应的是 Openmemory 方法 点击左上角的绿色三角形按钮，运行到断点 在General Registers 可以看到 dex 在内存中的起始地址和大小。我这边是X0，X1 在 Hex View 面板右键选择x0，可以定位到X0寄存器保存地址所在位置，即dex文件所在位置。可以看到dex.035字样 File -&gt; Script Command 自定义脚本导出dex文件 12345678910111213static main(void)&#123; auto fp, begin, end, dexbyte; //打开或创建一个文件 fp = fopen("/Users/xxx/128dump.dex", "wb"); //dex基址，即X0的值 begin = 0x7f962c5000; //dex基址 + dex文件大小 即X1大小 end = begin + 0xc204; for ( dexbyte = begin; dexbyte &lt; end; dexbyte ++ )&#123; //按字节将其dump到本地文件中 fputc(Byte(dexbyte), fp); &#125;&#125; 用jadx 工具反编译dex文件。 总结 dump dex 流程 1、刷mprop 属性 2、启动android_server 3、端口映射 4、启动app 5、启动monitor 6、启动IDA，绑定调试app进程，设置断点 7、执行jdb命令 8、运行到断点 9、执行脚本，dump dex； 参考文章 125.0以上系统 https://bbs.ichunqiu.com/thread-35905-1-1.html4.x系统 https://blog.csdn.net/daide2012/article/details/75675210]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>IDA</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 蓝牙通讯]]></title>
    <url>%2Fblog%2F2019%2F08%2F30%2Fandroid%20%E8%93%9D%E7%89%99%E9%80%9A%E8%AE%AF%2F</url>
    <content type="text"><![CDATA[配置权限 1234 &lt;uses-permission android:name="android.permission.BLUETOOTH" /&gt;&lt;uses-permission android:name="android.permission.BLUETOOTH_ADMIN" /&gt;&lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/&gt; 蓝牙设备扫描 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 private void startDiscovery()&#123; // 设备扫描方式1 BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter(); adapter.startDiscovery(); mBuletoothDeviceList.clear(); mHashMap.clear(); mTxScanDevices.setText(""); sb.delete(0, sb.length()); // 方式二，这个api可以拿到信号强度，官方不推荐使用了// final StringBuilder sb = new StringBuilder();// adapter.startLeScan(new BluetoothAdapter.LeScanCallback() &#123;// @Override// public void onLeScan(BluetoothDevice bluetoothDevice, int i, byte[] bytes) &#123;// BluetoothDevice device = bluetoothDevice;// String deviceName = device.getName();// String deviceHardwareAddress = device.getAddress(); // MAC address//// mBuletoothDeviceList.add(device);// sb.append(""+mBuletoothDeviceList.size()).append(deviceHardwareAddress)// .append("--")// .append(deviceName)// .append("--")// .append(device.getType())// .append("--")// .append(device.getBondState())// .append("--")// .append(i)// .append("\n");// mTxScanDevices.setText(mTxScanDevices.getText().toString() + sb.toString());// &#125;// &#125;); &#125; // 使用方式1，通过广播接收扫描到的设备信息 // Create a BroadcastReceiver for ACTION_FOUND. private final BroadcastReceiver receiver = new BroadcastReceiver() &#123; public void onReceive(Context context, Intent intent) &#123; Log.d("TAG", "onReceive"); String action = intent.getAction(); if (BluetoothDevice.ACTION_FOUND.equals(action)) &#123; // Discovery has found a device. Get the BluetoothDevice // object and its info from the Intent. BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE); String deviceName = device.getName(); String deviceHardwareAddress = device.getAddress(); // MAC address if(TextUtils.isEmpty(deviceName) == false &amp;&amp; !mHashMap.containsKey(deviceHardwareAddress))&#123; mBuletoothDeviceList.add(device); mHashMap.put(deviceHardwareAddress, deviceName); sb.append(mBuletoothDeviceList.size()+"、") .append(deviceHardwareAddress) .append("--") .append(deviceName) .append("--") .append(device.getType()) .append("\n"); mTxScanDevices.setText(sb.toString()); &#125; &#125;else if(BluetoothAdapter.ACTION_DISCOVERY_FINISHED.equals(action))&#123; Log.d("TAG", "onReceive finish"); &#125;else if(BluetoothAdapter.ACTION_DISCOVERY_STARTED.equals(action))&#123; Log.d("TAG", "onReceive start"); &#125; &#125; &#125;;&#125; 蓝牙客户端实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class BluetoothClient extends Thread&#123; private final BluetoothSocket mmSocket; private final BluetoothDevice mmDevice; private final String TAG = "BluetoothTest"; private final BluetoothAdapter bluetoothAdapter; private final Handler mHandler; private ConnectedThread mConnectedThread; public BluetoothClient(BluetoothDevice device, Handler handler) &#123; // Use a temporary object that is later assigned to mmSocket // because mmSocket is final. BluetoothSocket tmp = null; mmDevice = device; bluetoothAdapter = BluetoothAdapter.getDefaultAdapter(); try &#123; // Get a BluetoothSocket to connect with the given BluetoothDevice. // MY_UUID is the app's UUID string, also used in the server code. tmp = device.createRfcommSocketToServiceRecord(UUID.fromString(Config.UUID)); &#125; catch (IOException e) &#123; Log.e(TAG, "Socket's create() method failed", e); &#125; mmSocket = tmp; mHandler = handler; &#125; public void run() &#123; // Cancel discovery because it otherwise slows down the connection. Log.i(TAG, "start connect..."); bluetoothAdapter.cancelDiscovery(); Message writtenMsg = mHandler.obtainMessage(Config.MESSAGE_STATE, -1, -1, "客户端发起连接..."); writtenMsg.sendToTarget(); try &#123; // Connect to the remote device through the socket. This call blocks // until it succeeds or throws an exception. mmSocket.connect(); &#125; catch (IOException connectException) &#123; // Unable to connect; close the socket and return. try &#123; mmSocket.close(); &#125; catch (IOException closeException) &#123; Log.e(TAG, "Could not close the client socket", closeException); &#125; writtenMsg = mHandler.obtainMessage(Config.MESSAGE_STATE, -1, -1, "连接失败！"); writtenMsg.sendToTarget(); Log.i(TAG, "connect failed"); return; &#125; Log.i(TAG, "connect success"); writtenMsg = mHandler.obtainMessage(Config.MESSAGE_STATE, -1, -1, "连接成功！"); writtenMsg.sendToTarget(); // The connection attempt succeeded. Perform work associated with // the connection in a separate thread. manageMyConnectedSocket(mmSocket); &#125; public void sendData(String data)&#123; if(mConnectedThread != null)&#123; mConnectedThread.write(data.getBytes()); &#125; &#125; void manageMyConnectedSocket(BluetoothSocket socket)&#123; mConnectedThread = new ConnectedThread(socket, mHandler); mConnectedThread.start(); &#125; // Closes the client socket and causes the thread to finish. public void cancel() &#123; try &#123; mmSocket.close(); &#125; catch (IOException e) &#123; Log.e(TAG, "Could not close the client socket", e); &#125; &#125;&#125; 蓝牙服务器实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class BluetoothService extends Thread &#123; private final BluetoothServerSocket mmServerSocket; private final BluetoothAdapter bluetoothAdapter; private final String TAG = "BluetoothTest"; private final Handler mHandler; private ConnectedThread mConnectedThread; public BluetoothService(Handler handler) &#123; BluetoothServerSocket tmp = null; bluetoothAdapter = BluetoothAdapter.getDefaultAdapter(); try &#123; tmp = bluetoothAdapter.listenUsingRfcommWithServiceRecord("bluetooth_test", UUID.fromString(Config.UUID)); &#125; catch (IOException e) &#123; Log.e(TAG, "Socket's listen() method failed", e); &#125; mmServerSocket = tmp; mHandler = handler; &#125; public void run() &#123; BluetoothSocket socket = null; // Keep listening until exception occurs or a socket is returned. while (true) &#123; Log.i(TAG, "service start wait connect..."); Message writtenMsg = mHandler.obtainMessage(Config.MESSAGE_STATE, -1, -1, "服务端等待连接..."); writtenMsg.sendToTarget(); try &#123; socket = mmServerSocket.accept(); &#125; catch (IOException e) &#123; Log.e(TAG, "Socket's accept() method failed", e); writtenMsg = mHandler.obtainMessage(Config.MESSAGE_STATE, -1, -1, "服务端异常！"); writtenMsg.sendToTarget(); Log.i(TAG, "service connect failed"); break; &#125; if (socket != null) &#123; // A connection was accepted. Perform work associated with // the connection in a separate thread. Log.i(TAG, "connect success "); writtenMsg = mHandler.obtainMessage(Config.MESSAGE_STATE, -1, -1, "服务端连接成功！"); writtenMsg.sendToTarget(); manageMyConnectedSocket(socket); try &#123; mmServerSocket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; break; &#125; &#125; &#125; public void sendData(String data)&#123; if(mConnectedThread != null)&#123; mConnectedThread.write(data.getBytes()); &#125; &#125; void manageMyConnectedSocket(BluetoothSocket socket)&#123; mConnectedThread = new ConnectedThread(socket, mHandler); mConnectedThread.start(); &#125; // Closes the connect socket and causes the thread to finish. public void cancel() &#123; try &#123; mmServerSocket.close(); &#125; catch (IOException e) &#123; Log.e(TAG, "Could not close the connect socket", e); &#125; &#125;&#125; 读写流管理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class ConnectedThread extends Thread &#123; private static final String TAG = "ConnectedThread"; private final BluetoothSocket mmSocket; private final InputStream mmInStream; private final OutputStream mmOutStream; private final Handler handler; private byte[] mmBuffer; // mmBuffer store for the stream public ConnectedThread(BluetoothSocket socket, Handler h) &#123; mmSocket = socket; InputStream tmpIn = null; OutputStream tmpOut = null; handler = h; // Get the input and output streams; using temp objects because // member streams are final. try &#123; tmpIn = socket.getInputStream(); &#125; catch (IOException e) &#123; Log.e(TAG, "Error occurred when creating input stream", e); &#125; try &#123; tmpOut = socket.getOutputStream(); &#125; catch (IOException e) &#123; Log.e(TAG, "Error occurred when creating output stream", e); &#125; mmInStream = tmpIn; mmOutStream = tmpOut; &#125; public void run() &#123; mmBuffer = new byte[1024]; int numBytes; // bytes returned from read() // Keep listening to the InputStream until an exception occurs. while (true) &#123; try &#123; // Read from the InputStream. numBytes = mmInStream.read(mmBuffer); // Send the obtained bytes to the UI activity. String data = new String(mmBuffer, 0, numBytes); Message readMsg = handler.obtainMessage( Config.MESSAGE_READ, numBytes, -1, data); readMsg.sendToTarget(); &#125; catch (IOException e) &#123; Log.d(TAG, "Input stream was disconnected", e); break; &#125; &#125; &#125; // Call this from the main activity to send data to the remote device. public void write(byte[] bytes) &#123; try &#123; mmOutStream.write(bytes); // Share the sent message with the UI activity. Message writtenMsg = handler.obtainMessage( Config.MESSAGE_WRITE, -1, -1, new String(bytes)); writtenMsg.sendToTarget(); &#125; catch (IOException e) &#123; Log.e(TAG, "Error occurred when sending data", e); // Send a failure message back to the activity. Message writeErrorMsg = handler.obtainMessage(Config.MESSAGE_TOAST); Bundle bundle = new Bundle(); bundle.putString("toast","Couldn't send data to the other device"); writeErrorMsg.setData(bundle); handler.sendMessage(writeErrorMsg); &#125; &#125; // Call this method from the main activity to shut down the connection. public void cancel() &#123; try &#123; mmSocket.close(); &#125; catch (IOException e) &#123; Log.e(TAG, "Could not close the connect socket", e); &#125; &#125;&#125; github 项目地址 https://github.com/zubao/BluetoothTest 蓝牙官方文档 https://developer.android.com/guide/topics/connectivity/bluetooth?hl=zh-CN#FindDevices]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>bluetooth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 逆向]]></title>
    <url>%2Fblog%2F2019%2F08%2F29%2FAndroid%E9%80%86%E5%90%91%2F</url>
    <content type="text"><![CDATA[apktool 用于解密xml文件 apktool d test.apk 官方网站： https://ibotpeaches.github.io/Apktool/ dex2jar 用于将dex转换为jar sh d2j-dex2jar.sh test.dex 源码地址： https://github.com/pxb1988/dex2jar 工具地址： https://raw.githubusercontent.com/13046434521/-/master/%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E5%8C%85.zip jd-compiler 用于将jar|class文件 转换为 java 官方网站 http://java-decompiler.github.io/ jadx 用于逆向jar 文件 源码下载地址：https://github.com/skylot/jadx jadx 相比JD-GUI 更加优秀，逆向出来的源码可读性更强，更准确。 IDA 用于逆向分析SO文件 IDA 7.0 Mac 下载地址 https://xclient.info/s/hex-rays-ida-pro.html#versions Mac 10.14上会出现崩溃，解决方案 https://github.com/fjh658/IDA7.0_SP 夜神模拟器 夜神模拟器下载 https://www.yeshen.com/ VirtualXposed Xposed 框架 运行的虚拟环境，降低了xposed使用的门槛。 介绍文章 https://sspai.com/post/44447 github https://github.com/android-hacker/VirtualXposed EdXposed 框架 支持 ART https://github.com/ElderDrivers/EdXposed Xposed 框架 http://dl-xda.xposed.info/framework/ XposedInstaller.apk 配合 xposed 框架使用 https://forum.xda-developers.com/showthread.php?t=3034811 太极框架 支持android 5.0~Q github https://github.com/taichi-framework/TaiChi Vim // 打开二进制文件 vim -b filename // 转换为16进制查看 :%!xxd // 转换为正常格式 :%!xxd -r 参考：https://www.cnblogs.com/meibenjin/archive/2012/12/06/2806396.html 动态调试 xPosed, Android-InLine_Hook https://github.com/smartdone/Frida-Scripts/tree/master/unpack dexdump 12345678910111213adb shell dexdump -f /data/app/com.xxx.xxx/base.apk &gt; ~/test.txtdexdump: [-c] [-d] [-f] [-h] [-i] [-l layout] [-m] [-t tempfile]dexfile…-c : verify checksum and exit-d : disassemble code sections-f : display summary information from file header-h : display file header details-i : ignore checksum failures-l : output layout, either ‘plain’ or ‘xml’-m : dump register maps (and nothing else)-t : temp file name (defaults to /sdcard/dex-temp-*) cmdline /proc/%d/cmdline 动态导出内存中的 Java Class 文件 https://blog.csdn.net/dotalee/article/details/78272499 https://blog.csdn.net/hengyunabc/article/details/51106980 https://search.maven.org/search?q=dumpclass android逆向方法总结的很全面的文章 https://book.crifan.com/books/android_app_security_crack/website/android_background/related_info/dex_file.html https://juejin.im/post/5a5b25d0f265da3e2e6273a5 https://bbs.pediy.com/thread-191395.htm PC Java 查看类的工具 123sudo java -classpath &quot;$JAVA_HOME/lib/sa-jdi.jar&quot; sun.jvm.hotspot.HSDB // 一个java的可视化工具，可以dump内存中的java类，启动之后通过attach PID 获取虚拟机中加载的类信息。// 并且在tools 中可以看到直方图等其他信息。 [更新]讨论android加固防内存dump的技术及vmp壳的防护强度https://bbs.pediy.com/thread-206293.htm 移动调试工具：UPX memdump 导出 so文件，需要拼装 https://cloud.tencent.com/info/fd6d7ab6e1d277bc71829125a94cf3d4.html https://github.com/gnaixx/MemDump dump 内存最优方案，修改源码，加上dump class 逻辑，然后自己编译android 源码， https://blog.csdn.net/tabactivity/article/details/79359736]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac PHP + Redis]]></title>
    <url>%2Fblog%2F2019%2F08%2F26%2FMac%20PHP%20%2B%20Redis%2F</url>
    <content type="text"><![CDATA[首先需要安装Redis、PHP、PHP-FPM、nginx PHP需要安装Redis的扩展 1234567# https://github.com/phpredis/phpredis/releases 下载最新的 phpredis# 将下载安装包解压到 /usr/local # 将目录名称重命名为 phprediscd phpredissudo phpize # php安装后的路径sudo ./configure --with-php-config=/usr/local/php/bin/php-configsudo make &amp;&amp; make install 执行 sudo phpsize 的时候会报错 1234567891011grep: /usr/include/php/main/php.h: No such file or directorygrep: /usr/include/php/Zend/zend_modules.h: No such file or directorygrep: /usr/include/php/Zend/zend_extensions.h: No such file or directoryConfiguring for:PHP Api Version: Zend Module Api No: Zend Extension Api No: # 解决方法是：sudo ln -s/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk/usr/include/ /usr/include 修改php.ini文件，启用phpredis扩展 123456# 初次安装可能没有php.ini,需要自己copy一份sudo cp php.ini.default php.ini# 打开 php.ini 添加扩展sudo vim php.iniextension_dir = "/usr/lib/php/extensions/no-debug-non-zts-20160303"extension=redis.so 重启Nginx PHP-FPM 123sudo nginx -s reload# /usr/local/var/run/php-fmp.pid 文件中有对应的PIDsudo kill -USR2 php-fpm.pid Redis Demo 编写 1234567$redis = new Redis();// ps aux | grep redis 默认端口是6379 可以退通过命令查询到$redis-&gt;connect("127.0.0.1", "6379");echo "&lt;h5&gt;".($redis-&gt;get("foo"))."&lt;/h5&gt;";$redis-&gt;set("date", date('Y-m-d H:i:s'));echo "&lt;h5&gt;".($redis-&gt;get("date"))."&lt;/h5&gt;"; 参考文章 http://www.runoob.com/redis/redis-php.html https://segmentfault.com/q/1010000003882420]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手机大厂官方文档地址]]></title>
    <url>%2Fblog%2F2019%2F08%2F23%2F%E5%9B%BD%E5%86%85%E6%89%8B%E6%9C%BA%E5%A4%A7%E5%8E%82%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[华为 https://developer.huawei.com/consumer/cn/devservice/doc/50127 小米 https://dev.mi.com/console/doc/detail?pId=1351 OPPO https://open.oppomobile.com/wiki/doc#id=10432 VIVO https://dev.vivo.com.cn/documentCenter/doc/235]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac Nginx + PHP 环境搭建]]></title>
    <url>%2Fblog%2F2019%2F08%2F22%2FMac%20Nginx%20%2B%20PHP%20%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[安装Nginx 1brew install nginx 12345678910#测试nginx配置是否有语法错误nginx -t#打开 nginxsudo nginx#重新加载配置|重启|停止|退出 nginxnginx -s reload|reopen|stop|quit#也可以使用Mac的launchctl来启动|停止 nginxlaunchctl unload ~/Library/LaunchAgents/homebrew.mxcl.nginx.plistlaunchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.nginx.plist# 浏览器打开 http://127.0.0.1:8080/ 验证ng是否正常启动 配置NG 配置nginx,让它监听php-fpm的进程，这样当用户打开浏览器访问的时候，身为反向代理的nignx就能把东西让php去执行了。我们要配置nginx.conf文件，创建一个php-fpm文件（监听php-fpm）, 还要约定下将nginx.pid文件，log日志，以及以后我们要配置的站点.conf的路径，我们的路径约定还是按照brew默认的目录来设置,如下： 1234567891011121314151617# nginx.conf,已经被创建好了，我们一会要更改下/usr/local/etc/nginx/nginx.conf# php-fpm,这个我们就放在和nginx.conf一样的路径下吧，这个要我们自己创建/usr/local/etc/nginx/php-fpm# 日志文件放在/usr/local/var/log/nginx中，默认已经有了access.log和error.log文件了/usr/local/var/log/nginx/# nginx.pid文件,放在/usr/local/var/run/下面，和php-fpm.pid放一堆/usr/local/var/run/# 以后要配置的站点.conf, 我们就放在/usr/local/etc/nginx/servers/下面，这个servers文件夹本身就存在的/usr/local/etc/nginx/servers/# 站点的根目录,也就用brew给我们设置的吧/usr/local/var/www/ 配置 vim /usr/local/etc/nginx/nginx.conf 1234567891011121314151617181920212223242526worker_processes 1;error_log /usr/local/var/log/nginx/error.log debug;# 指定pidpid /usr/local/var/run/nginx.pid;events &#123; worker_connections 256;&#125;http &#123; include mime.types; default_type application/octet-stream; # 这个必须在前面 log_format main '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; # main 指的是上面的 main access_log /usr/local/var/log/nginx/access.log main; sendfile on; keepalive_timeout 65; port_in_redirect off; include /usr/local/etc/nginx/servers/*;&#125; 配置php-fpm 需要自己创建 vim /usr/local/etc/nginx/php-fpm 12345678location ~ \.php$ &#123; try_files $uri = 404; # 端口号默认是9000，如果被占用可以修改 fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_intercept_errors on; include /usr/local/etc/nginx/fastcgi.conf; &#125; 新建配置php站点服务自己的配置文件 vim /usr/local/etc/nginx/services/php-demo.conf 1234567891011121314151617181920212223242526server &#123; listen 80; server_name www.xxx.com; # 指定php工程地址 root /usr/local/var/www/demo; access_log /usr/local/var/log/nginx/default.access.log main; location / &#123; try_files $uri $uri/ /index.php?$query_string; index index.html index.htm index.php; autoindex on; include /usr/local/etc/nginx/php-fpm; &#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 location ~ \.php$ &#123; try_files $uri = 404;cd fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125; error_page 404 /404.html; error_page 403 /403.html;&#125; 重启nginx 1sudo nginx -s reload 安装Postgre 数据库 下载CI框架 第一个nginx + PHP + PostgreSQL demo 12345678910111213141516171819202122// 创建数据库的部分自己手动在命令行做了$dsn = "pgsql:port=5432;host=127.0.0.1;dbname=nosql";$username = "jack";$password = "123456";try &#123; $pdo = new PDO($dsn, $username, $password); if(!$pdo)&#123; echo "&lt;h5&gt;PG:PDO连接失败&lt;/h5&gt;"; &#125;else&#123; echo "&lt;h5&gt;PG:PDO连接成功&lt;/h5&gt;"; &#125;&#125;catch(Exception $e)&#123; print_r($e-&gt;getMessage());&#125;// 插入数据库字段需要用单引号$sql = "select * from user_tbl;";$result = $pdo-&gt;query($sql);foreach($result as $row) &#123; print_r($row['name']); print_r($row['signup_date']);&#125; 参考文章 https://cloud.tencent.com/developer/article/1335520]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 自带PHP 启动]]></title>
    <url>%2Fblog%2F2019%2F08%2F22%2FMac%20PHP%20%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[Mac 自带 php-fpm，在终端执行 php-fpm，会报如下错误： 123ERROR: failed to open configuration file '/private/etc/php-fpm.conf': No such file or directory (2)ERROR: failed to load configuration file '/private/etc/php-fpm.conf'ERROR: FPM initialization failed 错误信息显示，不能打开配置文件，cd /private/etc，发现没有 php-fpm.conf 文件，但是有 php-fpm.conf.default 文件。这个文件是默认配置，我们可以复制一份，改名为 php-fpm.conf，然后再根据需要改动配置。 1sudo cp /private/etc/php-fpm.conf.default /private/etc/php-fpm.conf 执行 php-fpm，再次报错： 1234[22-Aug-2019 16:50:55] WARNING: Nothing matches the include pattern '/private/etc/php-fpm.d/*.conf' from /private/etc/php-fpm.conf at line 125.[22-Aug-2019 16:50:55] ERROR: failed to open error_log (/usr/var/log/php-fpm.log): No such file or directory (2)[22-Aug-2019 16:50:55] ERROR: failed to post process the configuration[22-Aug-2019 16:50:55] ERROR: FPM initialization failed 错误信息显示，不能打开错误日志文件。cd /usr/var/log 发现根本没有这个目录，甚至连 var 目录都没有，加上为了避免权限问题，干脆配置到 /usr/local/var/log 目录。 123sudo vim php-fpm.conf# 记得将前面的';'去掉error_log = /usr/local/var/log/php-fpm.log 执行 php-fpm，再次报错： 1234[22-Aug-2019 16:54:36] WARNING: Nothing matches the include pattern &apos;/private/etc/php-fpm.d/*.conf&apos; from /private/etc/php-fpm.conf at line 125.[22-Aug-2019 16:54:36] ERROR: No pool defined. at least one pool section must be specified in config file[22-Aug-2019 16:54:36] ERROR: failed to post process the configuration[22-Aug-2019 16:54:36] ERROR: FPM initialization failed 解决方法是： 进入PHP安装目录/etc/php-fpm.d 1sudo cp www.conf.default www.conf 执行 php-fpm，再次报错： 12[22-Aug-2019 16:58:23] NOTICE: [pool www] 'user' directive is ignored when FPM is not running as root[22-Aug-2019 16:58:23] NOTICE: [pool www] 'group' directive is ignored when FPM is not running as root 12# 解决方法sudo php-fpm 执行 sudo php-fpm，再次报错： 12345No log handling enabled - using stderr loggingCreated directory: /var/db/net-snmpCreated directory: /var/db/net-snmp/mib_indexes[22-Aug-2019 16:58:54] ERROR: unable to bind listening socket for address '127.0.0.1:9000': Address already in use (48)[22-Aug-2019 16:58:54] ERROR: FPM initialization failed 1234# 问题的原因是端口被占用，换一个端口就可以了。# 解决方法cd /etc/php-fpm.d/www.conflisten = 127.0.0.1:9999 执行 sudo php-fpm，再次报错： 12[23-Aug-2019 10:27:21] ERROR: Unable to create the PID file (/usr/var/run/php-fpm.pid).: No such file or directory (2)[23-Aug-2019 10:27:21] ERROR: FPM initialization failed 12# 原因是php-fpm.conf 文件中配置的 PID 路径没有权限；修复方法如下pid = /usr/local/var/run/php-fpm.pid PHP-FPM 重启方法 1234567891011# 启动sudo php-fpm# 终止 php-fpm.pid 需要在 php-fpm.conf中配置sudo kill -INT 'cat /usr/local/var/run/php-fpm.pid'# 重启sudo kill -USR2 'cat /usr/local/var/run/php-fpm.pid'# 平滑终止sudo kill -QUIT 'cat /usr/local/var/run/php-fpm.pid'# 如果没有php-fpm.pid 文件ps aux | grep phpsudo kill -INT|USR2 pid 参考文章 https://blog.csdn.net/zrainload/article/details/78962062 https://blog.csdn.net/gb4215287/article/details/75247335]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hive 简介]]></title>
    <url>%2Fblog%2F2019%2F08%2F22%2FHive%20%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Hive简介 Apache Hive起初由Facebook开发 Apache Hive是一个建立在Hadoop架构之上的数据仓库。 可以将结构化的数据文件映射为一张数据库表 Hive 定义了简单的类 SQL 查询语言，称为 HQL，它允许熟悉 SQL 的用户查询数据。 底层数据是存储在 HDFS (Hadoop Distributed File System)上 Hive的本质是将 SQL 语句转换为 MapReduce 任务运行 使不熟悉 MapReduce 的用户很方便地利用 HQL 处理和计算 HDFS 上的结构化的数据。 Hive优缺点： 直接使用 MapReduce 所面临的问题： 1、人员学习成本太高 2、项目周期要求太短 3、MapReduce实现复杂查询逻辑开发难度太大 为什么要使用 Hive： 1、更友好的接口：操作接口采用类 SQL 的语法，提供快速开发的能力 2、更低的学习成本：避免了写 MapReduce，减少开发人员的学习成本 3、更好的扩展性：可自由扩展集群规模而无需重启服务，还支持用户自定义函数 Hive的特点 优点： 1、可扩展性,横向扩展，Hive 可以自由的扩展集群的规模，一般情况下不需要重启服务 横向扩展：通过分担压力的方式扩展集群的规模 纵向扩展：一台服务器cpu i7-6700k 4核心8线程，8核心16线程，内存64G =&gt; 128G 2、延展性，Hive 支持自定义函数，用户可以根据自己的需求来实现自己的函数 3、良好的容错性，可以保障即使有节点出现问题，SQL 语句仍可完成执行 缺点： 1、Hive 不支持记录级别的增删改操作，但是用户可以通过查询生成新表或者将查询结 果导入到文件中（当前选择的 hive-2.3.2 的版本支持记录级别的插入操作） 2、Hive 的查询延时很严重，因为 MapReduce Job 的启动过程消耗很长时间，所以不能 用在交互查询系统中。 3、Hive 不支持事务（因为不没有增删改，所以主要用来做 OLAP（联机分析处理），而 不是 OLTP（联机事务处理），这就是数据处理的两大级别）。 Hive的用户接口 CLI，Shell 终端命令行（Command Line Interface），采用交互形式使用 Hive 命令行与 Hive 进行交互，最常用（学习，调试，生产） JDBC/ODBC，是 Hive 的基于 JDBC 操作提供的客户端，用户（开发员，运维人员）通过 这连接至 Hive server 服务 Web UI，通过浏览器访问 Hive Hive的跨语言服务 Thrift 是 Facebook 开发的一个软件框架，可以用来进行可扩展且跨语言的服务的开发， Hive 集成了该服务，能让不同的编程语言调用 Hive 的接口 底层驱动 Driver 组件完成 HQL 查询语句从词法分析，语法分析，编译，优化，以及生成逻辑执行 计划的生成。生成的逻辑执行计划存储在 HDFS 中，并随后由 MapReduce 调用执行 Hive 的核心是驱动引擎， 驱动引擎由四部分组成： (1) 解释器：解释器的作用是将 HiveSQL 语句转换为抽象语法树（AST） (2) 编译器：编译器是将语法树编译为逻辑执行计划 (3) 优化器：优化器是对逻辑执行计划进行优化 (4) 执行器：执行器是调用底层的运行框架执行逻辑执行计划 数据库存储系统 元数据，通俗的讲，就是存储在 Hive 中的数据的描述信息。 Hive 中的元数据通常包括：表的名字，表的列和分区及其属性，表的属性（内部表和 外部表），表的数据所在目录 Metastore 默认存在自带的 Derby 数据库中。缺点就是不适合多用户操作，并且数据存 储目录不固定。数据库跟着 Hive 走，极度不方便管理 解决方案：通常存我们自己创建的 MySQL 库（本地 或 远程） Hive 和 MySQL 之间通过 MetaStore 服务交互 执行流程 HiveQL 通过命令行或者客户端提交，经过 Compiler 编译器，运用 MetaStore 中的元数 据进行类型检测和语法分析，生成一个逻辑方案(Logical Plan)，然后通过的优化处理，产生 一个 MapReduce 任务。 参考文章 https://www.cnblogs.com/qingyunzong/p/8707885.html https://www.cnblogs.com/qingyunzong/category/1191578.html]]></content>
      <categories>
        <category>hive</category>
      </categories>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CI架构]]></title>
    <url>%2Fblog%2F2019%2F08%2F22%2FCI%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[CI架构简介 CI架构全拼Codeigniter，相比之下另外一个更加活跃的PHP架构是Laravel。 CodeIgniter 是一套给 PHP 网站开发者使用的应用程序开发框架和工具包。它的特点包括且不局限于： 小巧但性能出色 广泛兼容各种 PHP 版本 几乎零配置且不需使用命令行 CI下载 https://www.codeigniter.com/ index.php 是所有 CI 程序的入口 设置.htaccess 文件 打开.htaccess 文件并添加以下四行代码，保存并退出 12&gt; `RewriteEngine on``RewriteCond %&#123;REQUEST_FILENAME&#125; !-f``RewriteCond %&#123;REQUEST_FILENAME&#125; !-d``RewriteRule ^(.*)$ /index.php/$1 [L]`&gt; 让我们看一下上面每行代码的作用： RewriteEngine on 用于打开 Apache 的 URL 重写 RewriteCond %{REQUEST_FILENAME} !-f 代表如果请求的文件存在，则直接访问该文件；如果文件不存在，则进行至下一步 RewriteCond %{REQUEST_FILENAME} !-d 代表如果目录存在则直接访问目录；如果目录不存在，则进行至下一步 RewriteRule ^(.*)$ /index.php/$1 [L] 如果所请求的路径不是存在的文件也不是存在的目录，则在路径前追加/index.php/ 这样，我们在访问任何 CI 的 URL 时，就不需要指定任何 php 路径了。因为 index.php 是所有 CI 程序的入口。 定义路由 对于URL Home - http://abc.om/en 当 CI 接收到一个用户请求的 URL 时，首先去路由表中查询该 URL 对应的控制器。我们首先为 Home 定义一个路由。路由文件的位置是 config/routes.php。打开路由定义，添加如下代码： $route[‘en’] = ‘en/home’; 控制器与视图入门 控制器 12345678910111213141516171819202122232425清单 1.controllelrs/en/home.php&lt;?php class Home extends CI_Controller &#123; //Home 控制器的构造函数 public function __construct() &#123; parent::__construct(); &#125; //Home 控制器的默认入口 index()方法 public function index() &#123; //加载 views 目录下的/en/header.php 视图 $this-&gt;load-&gt;view('/en/header'); //加载 views 目录下的/en/home.php 视图 $this-&gt;load-&gt;view('/en/home'); //加载 views 目录下的/en/footer.php 视图 $this-&gt;load-&gt;view('/en/footer'); &#125; &#125; 在 controllers 目录下，创建目录 en，在 en 目录下创建 home.php，这将是我们的第一个控制器。在 home.php 中添加如下代码： 视图 12345678清单 2.views/en/header.php&lt;H1&gt;ABC.com - Header&lt;/H1&gt;清单 3.views/en/home.php&lt;H2&gt;Welcome to ABC.com! - Body&lt;/H2&gt;清单 4.views/en/footer.php&lt;H3&gt;Copyright - Footer&lt;/H3&gt; 控制器如视图进阶 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051清单 5.controllers/en/home.php&lt;?php class Home extends CI_Controller &#123; //定义 Header 数据数组$headerdataprotected $headerdata = array( //定义页面标题数据 'title' =&gt; 'ABC - Home', //定义页面导航栏数据 'nav' =&gt; array( 'Home' =&gt; array( 'url' =&gt; '/en', 'active' =&gt; TRUE ), 'Solutions' =&gt; array( 'url' =&gt; '/en/solutions', 'active' =&gt; FALSE ), 'Services' =&gt; array( 'url' =&gt; '/en/services', 'active' =&gt; FALSE ), 'Products' =&gt; array( 'url' =&gt; '/en/products', 'active' =&gt; FALSE ), 'Support' =&gt; array( 'url' =&gt; '/en/support', 'active' =&gt; FALSE ) ),);//Home 控制器的构造函数public function __construct() &#123;parent::__construct();&#125;//Home 控制器的默认入口 index()方法public function index() &#123; //加载 views 目录下的/en/header.php 视图并将$headerdata 中的导航栏数据传递给 header 视图$this-&gt;load-&gt;view('/en/header', $this-&gt;headerdata); //加载 views 目录下的/en/home.php 视图$this-&gt;load-&gt;view('/en/home');//加载 views 目录下的/en/footer.php 视图$this-&gt;load-&gt;view('/en/footer');&#125;&#125; 这段代码介绍了如何将数据从控制器传入视图。 视图 12345678910111213141516171819202122232425清单 6.views/en/header.php&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;?php echo $title ?&gt;&lt;/title&gt; &lt;/head&gt;&lt;body&gt;&lt;?php //遍历$nav 数组 foreach ($nav as $name =&gt; $value) &#123; //如果当前元素为’active’状态，则显示(Active) if ($value['active']) &#123; echo "$name(Active)"; &#125; else &#123; //如果当前元素为非’active’状态，则显示该页面名称，并附有该页面的链接 echo '&lt;a href="' . $value['url'] . '"&gt;'; echo $name; echo '&lt;/a&gt;'; &#125; echo ' | '; &#125;?&gt;&lt;/body&gt; 我们在 home 控制器中将$headerdata 传递给 header 视图，header 视图就可以直接访问$headerdata 的内部数据，无需指定数组名称。我们可以在 header.php 中，直接使用$title 来访问 home.php 中的$headerdata[‘title’]；同样我们可以在 header.php 中，直接使用$nav 来访问 home.php 中的$headerdata[‘nav’]。 URI 传参及模型-控制器-视图 - 完整流程 URI 解析 根据CI 的 URI 路由特性，我们采用下面的 URL 来显示 products 的 issue001 页面 http://abc.com/en/support/products/issue001 此 URL 的定义如下 第一段 abc.com 代表域名 第二段 en 代表控制器的目录 第三段 support 代表控制器的名称 第四段 products 代表控制器的函数名 第五段 issue001 代表传递给控制器的参数 控制器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172清单 7.controllers/en/support.php&lt;?phpclass Support extends CI_Controller &#123; //为 Support 控制器定义 Header 数据protected $headerdata = array( //定义 Support 页面标题 'title' =&gt; 'ABC - Support', //定义 Support 页面导航栏 'nav' =&gt; array( 'Home' =&gt; array( 'url' =&gt; '/en', 'active' =&gt; FALSE ), 'Solutions' =&gt; array( 'url' =&gt; '/en/solutions', 'active' =&gt; FALSE ), 'Services' =&gt; array( 'url' =&gt; '/en/services', 'active' =&gt; FALSE ), 'Products' =&gt; array( 'url' =&gt; '/en/products', 'active' =&gt; FALSE ), 'Support' =&gt; array( 'url' =&gt; '/en/support', 'active' =&gt; TRUE ) ),);//定义 Support 页面的数据元素protected $supportdata = array( 'type' =&gt; '', 'issue' =&gt; '', 'info' =&gt; '');//Home 控制器的构造函数public function __construct() &#123; //构造函数 parent::__construct(); //加载 Support 的数据模型 $this-&gt;load-&gt;model("support_model");&#125; //Support 控制器的默认入口public function index() &#123; //加载 header 视图并将 header 数据传递给视图 $this-&gt;load-&gt;view('/en/header', $this-&gt;headerdata); //加载 footer 视图 $this-&gt;load-&gt;view('/en/footer');&#125; //Support 控制器的 products 入口public function products($issue) &#123; //定义 support 的数据为 Products 类型，存入$supportdata $this-&gt;supportdata['type'] = 'Products'; //将 URL 传过来的$issue 参数存入$supportdata $this-&gt;supportdata['issue'] = $issue; //从 Support 模型中取出$issue 数据并存入$supportdata $this-&gt;supportdata['info'] = $this-&gt;support_model-&gt;get_product($issue); //加载 header 视图并将 header 数据传递给视图 $this-&gt;load-&gt;view('/en/header', $this-&gt;headerdata); //加载 support 视图并将 supportdata 数据传递给视图 $this-&gt;load-&gt;view('/en/support', $this-&gt;supportdata); //加载 footer 视图 $this-&gt;load-&gt;view('/en/footer');&#125;&#125; 模型 123456789101112131415清单 8.models/support_model.php&lt;?phpclass Support_model extends CI_Model &#123; //Support 模型的构造函数 public function __construct() &#123; parent::__construct(); &#125; //Support 模型的 get_product 方法，用于返回$issue 所代表的数据 public function get_product($issue) &#123; //返回$issue 的 support 信息 return "This is the support information for $issue"; &#125;&#125; 视图 1234567清单 9.views/en/support.php&lt;H2&gt;Support - Body&lt;/H2&gt;&lt;?phpecho "Type: $type&lt;br&gt;";echo "Issue: $issue&lt;br&gt;";echo "Information: $info&lt;br&gt;"; 参考文档 https://www.ibm.com/developerworks/cn/web/1508_lizhi_phpci/index.html]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>ci</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PG数据库 简介]]></title>
    <url>%2Fblog%2F2019%2F08%2F21%2FPG%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[简介 PG 数据库全称 PostgreSQL 自由的对象-关系型数据库服务器（数据库管理系统），在BSD许可证下发行。 历史 该项目最初开始于在加利福尼亚大学伯克利分校的Ingres计划。 1982年这个计划的领导者迈克尔·斯通布雷克离开加利福尼亚大学伯克利分校去推进Ingres的商业化，但最后还是返回了学术界。 1985年返回伯克利之后，斯通布雷克开始了post-Ingres计划，致力于解决在1980年代早期所出现一些数据库系统存在的问题。Postgres和Ingres的代码库开始（并保持）完全分离。 从1986年开始，该项目组发表了一些描述这一系统基本原理的论文 1988年实现并运行了一个Demo版本。 1989年六月向少数用户发行了版本1.0 1990年6月发行了带有全新规则系统的版本2.0 1991年的版本3.0再次重写了规则系统，并增加了对多个存储管理器的支持与改进的查询引擎。 1993年开始拥有大量用户，这些用户提供了大量的功能与优化建议。但是在发行了作为细节修正的版本4.0之后，Postgres计划就终止了。 1994年，两个加利福尼亚大学伯克利分校的研究生 Andrew Yu和Jolly Chen 增加了一个SQL语言解释器来替代早先的基于Ingres的QUEL系统，创建了Postgres95。 1996年被重命名为PostgreSQL以便突出该数据库全新的SQL查询语言。 2005年1月19日，PostgreSQL发行了版本8.0。 目前最新的版本已经到了11.5。 安装 PostgreSQL 客户端安装 12&gt; brew install postgresql&gt; 初始化数据库 12&gt; initdb /usr/local/var/postgres&gt; 启动服务 1234567&gt; pg_ctl -D /usr/local/var/postgres -l /usr/local/var/postgres/server.log start&gt; # 开始或者停止pg&gt; pg_ctl start|stop&gt; # 查询pg监听端口&gt; netstat -a | grep PGSQ&gt; # 修改端口 postgresql.conf &gt; 参考文档 http://www.ruanyifeng.com/blog/2013/12/getting_started_with_postgresql.html https://www.jianshu.com/p/10ced5145d39 创建 创建数据库，进入控制台 12345&gt; createdb&gt; # 进入PostgreSQL 控制台&gt; psql&gt; # \l 查看数据库；\q离开控制台&gt; 创建用户 jack 12# 创建角色Jack ，密码123456CREATE USER jack WITH PASSWORD '123456'; 创建属于jack的数据库nosql 1CREATE DATABASE nosql OWNER jack; 将nosql数据库所有权限赋予jack用户 1GRANT ALL PRIVILEGES ON DATABASE nosql to jack; 给jack用户添加创建数据库的属性 1ALTER ROLE jack CREATEDB; 进入nosql 数据库 1psql -U jack -d nosql -h [host] -p [port]； 使用sql 语句创建表 12345678# 创建新表 CREATE TABLE user_tbl(name VARCHAR(20), signup_date DATE);# 插入数据 INSERT INTO user_tbl(name, signup_date) VALUES('张三', '2013-12-22');# 选择记录 SELECT * FROM user_tbl; 控制台常用命令 123456789101112\password：设置当前登录用户的密码\h：查看SQL命令的解释，比如\h select。\?：查看psql命令列表。\l：列出所有数据库。\c [database_name]：连接其他数据库。\d：列出当前数据库的所有表格。\d [table_name]：列出某一张表格的结构。\du：列出所有用户。\e：打开文本编辑器。\conninfo：列出当前数据库和连接的信息。\password [user]: 修改用户密码\q：退出]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 简介]]></title>
    <url>%2Fblog%2F2019%2F08%2F21%2FRedis%20%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Redis 简介 Remote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。 Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 从2015年6月开始，Redis的开发由Redis Labs赞助，而2013年5月至2015年6月期间，其开发由Pivotal赞助。[3]在2013年5月之前，其开发由VMware赞助。[4][5]根据月度排行网站DB-Engines.com的数据，Redis是最流行的键值对存储数据库。 数据模型 Redis的外围由一个键、值映射的字典构成。与其他非关系型数据库主要不同在于：Redis中值的类型不仅限于字符串，还支持如下抽象数据类型： 字符串列表 无序不重复的字符串集合 有序不重复的字符串集合 键、值都为字符串的哈希表 值的类型决定了值本身支持的操作。Redis支持不同无序、有序的列表，无序、有序的集合间的交集、并集等高级服务器端原子操作。 持久化 Redis通常将全部的数据存储在内存中。2.4版本后可配置为使用虚拟内存，[9]一部分数据集存储在硬盘上，但这个特性废弃了。 当前通过两种方式实现持久化： 使用快照，一种半持久耐用模式。不时的将数据集以异步方式从内存以RDB格式写入硬盘。 RDB文件是Redis持久化的一种方式，Redis通过制定好的策略，按期将内存中的数据以镜像的形式转存到RDB文件中。 https://ningyu1.github.io/site/post/34-redis-rdb/ https://redisbook.readthedocs.io/en/latest/internal/rdb.html 1.1版本开始使用更安全的AOF格式替代，一种只能追加的日志类型。将数据集修改操作记录起来。Redis能够在后台对只可追加的记录作修改来避免无限增长的日志。 AOF 则以协议文本的方式，将所有对数据库进行过写入的命令（及其参数）记录到 AOF 文件，以此达到记录数据库状态的目的。 https://redisbook.readthedocs.io/en/latest/internal/aof.html 同步 Redis支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得Redis可执行单层树复制。从盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助。 性能 当数据依赖不再需要，Redis这种基于内存的性质，与在执行一个事务时将每个变化都写入硬盘的数据库系统相比就显得执行效率非常高。[11]写与读操作速度没有明显差别。 接口介绍 http://www.runoob.com/redis/redis-data-types.html 安装 Mac 上安装redis 命令 brew install redis 验证是否安装成功 brew services start redis 启动客户端 cd /usr/local/bin/ redis-cli]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 获取 WIDEVINE_UUID]]></title>
    <url>%2Fblog%2F2019%2F08%2F20%2FWIDEVINE_UUID%20%E8%8E%B7%E5%8F%96%2F</url>
    <content type="text"><![CDATA[anroid 通过 MediaDrm 获取uuid 1、App 内唯一 2、App 之间不唯一 3、App卸载重装唯一 12345678910111213UUID WIDEVINE_UUID = new UUID(-0x121074568629b532L, -0x5c37d8232ae2de13L);MediaDrm wvDrm = null; try &#123; wvDrm = new MediaDrm(WIDEVINE_UUID); &#125; catch (UnsupportedSchemeException e) &#123; e.printStackTrace(); &#125; byte[] data = wvDrm.getPropertyByteArray(MediaDrm.PROPERTY_DEVICE_UNIQUE_ID); String ID = Base64.getEncoder().encodeToString(data).trim(); Log.i("MAIN", "UUID: "+ ID);wvDrm.close();]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPv6详解]]></title>
    <url>%2Fblog%2F2019%2F08%2F13%2FIPv6%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[#####]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>IPv6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Q 非SDK检查]]></title>
    <url>%2Fblog%2F2019%2F08%2F06%2FAndroid%20Q%20%E9%9D%9ESDK%20%E6%A3%80%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[SDK 限制等级 greylist 本系统标记为不支持调用。但是无限制，可以正常使用 Blacklist 无论targetVersion如何，使用这些api，系统将会抛出错误 greylist-max-o 受限制的灰名单。targetVersion &lt;= 27 可以正常访问 greylist-max-p 受限制的灰名单。targetVersion &lt;= 28 可以正常访问 检查工具 工具地址 下载下来，将veridex-mac.zip解压出来进行下面操作进行check检查。 Mac 平台 运行如下命令： 1./appcompat.sh --dex-file=test.apk]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android hook]]></title>
    <url>%2Fblog%2F2019%2F08%2F06%2FAndroid%20Hook%2F</url>
    <content type="text"><![CDATA[通过hook方式拦截startActivity 针对android 8以前 12345678910111213141516171819202122232425public void hookAms()&#123; try&#123; Class&lt;?&gt; ActivityManagerNativeClss = Class.forName("android.app.ActivityManagerNative"); Field defaultFiled = ActivityManagerNativeClss.getDeclaredField("gDefault"); defaultFiled.setAccessible(true); Object defaultValue = defaultFiled.get(null); Class&lt;?&gt; SingletonClass = Class.forName("android.util.Singleton"); Field mInstance = SingletonClass.getDeclaredField("mInstance"); mInstance.setAccessible(true); Object iActivityManagerObject = mInstance.get(defaultValue); Class&lt;?&gt; IActivityManagerIntercept = Class.forName("android.app.IActivityManager"); AmsInvocationHandler handler = new AmsInvocationHandler(iActivityManagerObject); Object proxy = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class&lt;?&gt;[]&#123;IActivityManagerIntercept&#125;, handler); mInstance.set(defaultValue, proxy); &#125;catch (Throwable e)&#123; e.printStackTrace(); &#125; &#125; 针对android 8 以后 123456789101112131415161718192021222324public void hookAMSAfter26() throws Exception &#123; // 第一步：获取 IActivityManagerSingleton Class&lt;?&gt; aClass = Class.forName("android.app.ActivityManager"); Field declaredField = aClass.getDeclaredField("IActivityManagerSingleton"); declaredField.setAccessible(true); Object value = declaredField.get(null); Class&lt;?&gt; singletonClz = Class.forName("android.util.Singleton"); Field instanceField = singletonClz.getDeclaredField("mInstance"); instanceField.setAccessible(true); Object iActivityManagerObject = instanceField.get(value); // 第二步：获取我们的代理对象，这里因为 IActivityManager 是接口，我们使用动态代理的方式 Class&lt;?&gt; iActivity = Class.forName("android.app.IActivityManager"); InvocationHandler handler = new AmsInvocationHandler(iActivityManagerObject); Object proxy = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class&lt;?&gt;[]&#123;iActivity&#125;, handler); // 第三步：偷梁换柱，将我们的 proxy 替换原来的对象 instanceField.set(value, proxy); &#125; 动态代理 实现 123456789101112131415161718192021222324package com.pa.test.test;import android.util.Log;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class AmsInvocationHandler implements InvocationHandler &#123; private Object iActivityManagerObject; AmsInvocationHandler(Object iamo)&#123; this.iActivityManagerObject = iamo; &#125; @Override public Object invoke(Object o, Method method, Object[] objects) throws Throwable &#123; Log.i("HookUtil", method.getName()); if("startActivity".contains(method.getName()))&#123; Log.i("HookUtil", "HookUtil Success "); &#125; return method.invoke(iActivityManagerObject, objects); &#125;&#125; 本质上都是通过反射 + 动态代理的方式，拦截指定方法。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>hook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 动态代理]]></title>
    <url>%2Fblog%2F2019%2F08%2F05%2FJava%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[动态代理 代理模式分为动态代理、静态代理（略）。它的定义： 当无法直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，所访问的真实对象与代理对象需要实现相同的接口。 代理模式是设计模式中的一种,而且在实际的开发中使用的频率非常高 ,比如spring AOP,mybatis代理都是我们经常使用的. 动态代理的优势： 1、降低各个功能模块之间的耦合度，提高开发的效率和方便程序的维护度。 2、减少代码量。 3、不关注目标的具体实现。 Java实现分为4个步骤，如下：需要代理的接口、类： 首先要创建文件夹 proxy 12mkdir proxymkdir com/sun/proxy // 后续输出 $proxy用 12345package proxy;public interface IAction&#123; void sayHello();&#125; 123456789package proxy;import proxy.IAction;public class Person implements IAction&#123; public void sayHello()&#123; System.out.println("hello world"); &#125;&#125; 实现 InvocationHandler 接口 创建 PIHandler.java 类 12345678910111213141516package proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import proxy.Person;public class PIHandler implements InvocationHandler&#123; private Person person; public PIHandler(Person person)&#123; this.person = person; &#125; public Object invoke(Object obj, Method method, Object[] objs) throws Throwable&#123; return method.invoke(this.person, objs); &#125;&#125; 创建代理Demo 创建Main.java类 123456789101112131415161718package proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.*;import proxy.*;public class Main&#123; public static void main(String[] args)throws Throwable&#123; // 从源码中得知，设置这个值，可以把生成的代理类，输出出来。 System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles", "true"); System.out.println(Proxy.getProxyClass(IAction.class.getClassLoader(), IAction.class)); PIHandler ph = new PIHandler(new Person()); IAction ac = (IAction) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class&lt;?&gt;[] &#123;IAction.class&#125;, ph); ac.sayHello(); &#125;&#125; 会将生成的$Proxy0.class 类输出到和proxy 目录同级的com/sun/proxy目录下面。 $Proxy0.class 查看 编译java文件 1javac proxy/Main.java 执行java文件 1java proxy.Main $proxy0.class 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107package com.sun.proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;import proxy.IAction;public final class $Proxy0 extends Proxy implements IAction&#123; private static Method m1; private static Method m3; private static Method m2; private static Method m0; public $Proxy0(InvocationHandler paramInvocationHandler) &#123; super(paramInvocationHandler); &#125; public final boolean equals(Object paramObject) &#123; try &#123; return ((Boolean)this.h.invoke(this, m1, new Object[] &#123; paramObject &#125;)).booleanValue(); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final void sayHello() &#123; try &#123; this.h.invoke(this, m3, null); return; &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final String toString() &#123; try &#123; return (String)this.h.invoke(this, m2, null); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final int hashCode() &#123; try &#123; return ((Integer)this.h.invoke(this, m0, null)).intValue(); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; static &#123; try &#123; m1 = Class.forName("java.lang.Object").getMethod("equals", new Class[] &#123; Class.forName("java.lang.Object") &#125;); m3 = Class.forName("proxy.IAction").getMethod("sayHello", new Class[0]); m2 = Class.forName("java.lang.Object").getMethod("toString", new Class[0]); m0 = Class.forName("java.lang.Object").getMethod("hashCode", new Class[0]); return; &#125; catch (NoSuchMethodException localNoSuchMethodException) &#123; throw new NoSuchMethodError(localNoSuchMethodException.getMessage()); &#125; catch (ClassNotFoundException localClassNotFoundException) &#123; throw new NoClassDefFoundError(localClassNotFoundException.getMessage()); &#125; &#125;&#125; 参考文章： https://www.cnblogs.com/MOBIN/p/5597215.html https://juejin.im/entry/5a4af4116fb9a045104ad95b https://my.oschina.net/daijunjian/blog/1549753 https://www.jianshu.com/p/d5d9215bf8ad]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[懒加载的单例模式]]></title>
    <url>%2Fblog%2F2019%2F08%2F05%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[辅助类 Singleton1234567891011121314public abstract class Singleton&lt;T&gt; &#123; private T mInstance; protected abstract T create(); public final T get() &#123; synchronized (this) &#123; if (mInstance == null) &#123; mInstance = create(); &#125; return mInstance; &#125; &#125;&#125; 创建单例：123456789private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton = new Singleton&lt;IActivityManager&gt;() &#123; @Override protected IActivityManager create() &#123; final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE); final IActivityManager am = IActivityManager.Stub.asInterface(b); return am; &#125; &#125;; 1、优点是，提高加载速度。类初始化的时候，没有立即初始化开销大的对象A，而是先初始化了一个接口类。等到实际使用的时候再去初始化对象A。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 源码目录结构]]></title>
    <url>%2Fblog%2F2019%2F08%2F05%2FAndroid%20%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[一级目录： art - Android Runtime，一种app运行模式，区别去传统的Dalvik虚拟机，目的是提高android系统的流畅性。 bionic - 集成C库源代码，android改造的c/c++库。 bootable - android程序启动引导，适合各种bootloader的通用代码。包括一个recovery目录。 build - 存放系统编译规则以及generic等基础开发包配置。 compatibility - android 兼容计划。 cts - android兼容性测试标准。 dalvik - android dalvik虚拟机相关内容。 developers - 开发者参考文档。 development - android 应用开发基础设施相关。 device - android 支持的各种设备及相关配置。 external - android 中使用的各种外部开源库。 frameworks - 应用层框架，android系统的核心部分，又java、c++实现。 hardware - 硬件适配接口。 kernel - linux 内核，android 默认不提供，只有一个tests目录，需要另外下载。 libcore - android java 核心类库。 libnativehelper - android 动态库，实现jni的基础。 packages - 应用程序包。 pdk - Plug development kit，本地开发套件。 plaform_testing - android 平台测试程序。 prebuilds - x86 和 arm 架构下预编译的一些资源。 sdk - android java层SDK。 system - android底层文件系统库，应用、组件。 test - android Vendor测试框架。 toolchain - android 工具链文件。 tools - android 工具文件。 Android.bp - android 7.0 开始代替 android.mk 文件， 它告诉ndk将jni编译为动态库的脚本。 Makefile - 全局Makefile文件，用来定义编译规则。 framework 二级目录 ： av - 多媒体框架。 base - android 源码的主要核心目录。 compile - 编译相关。 ex - 文件解析器。 hardware - 硬件适配接口。 layoutlib - 布局相关。 minikin - android 原生字体，连体字效果。 ml - 机器学习。 multidex - 多dex 加载器。 native - native 实现。 opt - 一些软件。 rs - Render Script ，创建3D接口。 support - framework 支持文件。 wilhelm - 基于 Khronos 的OpenGL ES/ OpenGLMax AL audio/multi media实现。 base 三级目录： apct-test - 性能优化测试。 api - android应用框架层声明类、属性、资源。 cmds - android 系统启动时用到的commands。 core - framwork的核心框架组件。 data - android系统下的资源(声音、视屏、字体、软盘等)。 docs - android 项目说明文档。 drm - 实现权限管理，数字内容解密等模块的工作。 graphics - 图像渲染模块。 keystore - 密钥库。 libs - 库信息(界面、存储、USB) location - 位置信息。 media - 手机媒体管理。 native - 本地方法实现（传感器、输入、界面、窗体）。 nfc-extras - 近场通讯。 obex - 蓝牙。 opengl - 2D、3D图形绘制。 pacakges - 框架床的实现(界面、服务、存储)。 proto - 协议框架。 rs - 资源框架。 samples - 例子程序。 sax - xml 解析器。 Services - 各种服务程序。 telecomm - telecomm 通信框架。 telephony - 电话通信框架。 tests - 各种测试。 vr - 虚拟现实相关。 wifi - wifi模块。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>aosp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 优化构建速度]]></title>
    <url>%2Fblog%2F2019%2F08%2F01%2Fandroid%20%E4%BC%98%E5%8C%96%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[Apply plugin 的几种常见定义： apply plugin: ‘com.android.application’ 实际对应的原型是：com.android.build.gradle.AppExtension，表示此项目模块类型为Android App Module，对应构建生成的文件为.apk类型文件。 apply plugin: ‘com.android.library’ 实际对应的原型是：com.android.build.gradle.LibraryExtension，表示此项目模块类型为Android Library Module，对应构建生成的文件为.arr类型的文件。 apply plugin: ‘com.android.test’ 实际对应的原型是：com.android.build.gradle.TestExtension，表示此项目模块类型为Android test Module，可以在单个模块内通过targetProjectPath指定项目，用于对应项目的单元测试。 apply plugin: ‘com.android.feature’ 实际对应的原型是：com.android.build.gradle.FeatureExtension，表示此项目模块类型为Android feature Module，主要用于单个模块内实现特性，以支持Android Instant Apps。 Gradle 配置 defaultConfig 字段解释优化构建速度，参考 官方文档 1、开启离线模式，避免每次更新第三方库文件 2、用静态的版本依赖，避免更新 3、加大JVM 4、开启热启动；PS：第一次还是很慢，第二次会快很多 5、开启并发构建、启用缓存、开启守护进程 等 android Gradle 构建总结 参考Instant Run 工作原理和方法 参考]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置ABI的两种方式]]></title>
    <url>%2Fblog%2F2019%2F08%2F01%2F%E9%85%8D%E7%BD%AEABI%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[通过abiFilter字段配置： 一个是通过设置ndk的abiFilters字段，使apk能够兼容多种abi，但是这样会使得apk体积增大，所以，这种方式只适合配置主流的abi，使apk能在市场上的大部分手机成功安装使用。 123456789101112131415161718android &#123; ... // 其它配置 defaultConfig &#123; ... // 默认配置 ndk &#123; //选择要添加的对应cpu类型的.so库。 abiFilters &apos;armeabi&apos;, &apos;armeabi-v7a&apos; // 还可以添加 // &apos;arm64-v8a&apos;, 64 bit ARM architecture,it can use v7 version // unless you are too much concerned about performance // mips,mips64, There are no devices with MIPS // x86_64, No android devices and anyway it can use X86 version // armeabi, very old architecture. Unsupported after Android 4.4 // &apos;x86&apos;, Intel based devices &#125; &#125; ... // 其它配置&#125; 通过splits字段配置 splits的abi属性下面，定义好支持的abi，然后打包的时候，会根据不同的架构，打不同的包，每个包支持一种架构，这样能让不同架构的设备上安装最合适的apk，但是因为一个apk仅支持一种架构，所以互不兼容。 1234567891011android &#123; ... // 其它配置 splits &#123; abi &#123; reset() enable true // 设为true，才能在打包时根据架构生成不同的apk文件 universalApk false // If true, also generate a universal APK include &quot;armeabi-v7a&quot;, &quot;x86&quot; // 设置所有要支持的abi类型 &#125; &#125;&#125;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jar加固]]></title>
    <url>%2Fblog%2F2019%2F07%2F25%2FJar%E5%8A%A0%E5%9B%BA%2F</url>
    <content type="text"><![CDATA[#####]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Q 线刷]]></title>
    <url>%2Fblog%2F2019%2F07%2F25%2FAndroid%20Q%20%E7%BA%BF%E5%88%B7%2F</url>
    <content type="text"><![CDATA[android Q 升级的两种方式：加入android测试版记录 官方网站：https://www.google.com/android/beta 1、优点是炒作简单 2、缺点是需要FQ，SS工具可能无法做到全局代理。如果在境外，或者有可以FQ的路由器应该没问题。 下载zip包，刷入手机 官方网站： https://developers.google.com/android/images 下载对应手机的zip文件，解压到指定目录。 更新 platform-tools到最新版本 手机打开开发者模式，去开发者选项中启动允许OEM解锁。 刷机之前，千万记得退出账号。 adb reboot bootloader 进入到 bootloader模式； fastboot flashing unlock 解锁手机 以pixel 2xl 为例，如果bootloader version 低于 TMZ20a（例如8.0系统），需要执行 fastboot flashing unlock 、fastboot flashing unlock_critical 两条命令解锁。高于TMZ20a的则只需要 fastboot flashing unlock即可。 如果出现 FAILED (remote: ‘Flashing Unlock is not allowed），可以先执行fastboot flashing lock 锁定 OEM，重启手机，然后再次去开发者选项中打开运行OEM解锁，进入 BootLoader模式，然后执行上面两条命令解锁。 执行 flash-all.sh 脚本 刷入ROM 执行 fastboot flashing lock 锁定OEM 我再刷入Android Q之后，在开机连接wifi阶段卡住了，一直通过不了； 尝试过： 1、PC FQ，手机通过wifi代理到PC FQ连接Google服务器，依然无法通过。 2、小米手机4G+FQ，pixel 2xl 通过小米共享的热点FQ，也不行。 3、然后试图刷低版本(8.0)尝试绕过，还是不行。 4、最终通过购买香港一日流量卡解决问题。PS：流量卡需要先激活，我是小米用流量卡，共享热点给Pixel 2XL 连接上的google。流量卡需要用可以正常使用的手机先激活。 5、应该是我的PC、小米 FQ 都没有做到全局代理，导致google的请求没有走代理连接不上服务器。如果有路由器能FQ最好。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>ROM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android SDK 自动化测试]]></title>
    <url>%2Fblog%2F2019%2F07%2F24%2FAndroid%20SDK%20%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[名词解释 JUnit - JUnit 是一个 Java 编程语言的单元测试框架。文档 JUnit 3 - JUnit 3 是JUnit的3.x版本 在JUnit3中，如果某个类是测试类，必须将其继承类TestCase；如果某个方法是测试方法，必须让这个方法以testXX开头；如果希望指定某个测试方法运行之前运行某个初始化方法，这个方法的名称必须是setUp；如果希望在某个测试方法运行之后运行某个释放资源的方法，这个方法的名称必须是tearDown JUnit 4 - 是JUnit的 4.x版本 JUnit 4是与JUnit3完全不同的API，它基于Java 5.0中的注解、静态导入等构建而成。JUnit 4更简单、更丰富、更易于使用，并引入了更为灵活的初始化和清理工作，还有限时的和参数化测试用例。 在junit4中，一个POJO类就是一个测试类； 1、测试方法通过@Test来标识； 2、初始化方法通过@Before来标识； 3、释放资源的方法通过@After来标识； 4、为了让junit4的测试类在junit3中也可以使用，习惯于把初始化方法命名为setUp，释放资源的方法命名为tearDown。 5、Test中的测试方法一般以Test来开始。其中标识为Before注解的方法，每次运行测试类，都会执行标识为@After与@Before的方法。 Instrumentation - Instrumentation是Android Java API层的一个类. 通过阅读源码可以发现，平时我们在用Application、Activity的时候，实际上Application的创建、Activity的实例化、生命周期里onCreate等方法的调用，都是通过Instrumentation实现的。不仅如此，通过Instrumentation还可以向APP发送用户点击、按钮事件等。获取到了权限足够的Instrumentation，几乎就可以完全控制APP甚至手机了。 AndroidJUnit4 - 继承于Runner抽象类，不负责具体实现。采用了委托模式，由继承于Runner的另一内部对象 AndroidJUnit4ClassRunner 负责具体实现。采用了JUnit4实现。 12345678@RunWith(AndroidJUnit4.class)public class ExampleInstrumentedTest &#123; // @Rule // public ActivityTestRule activityTestRule = new ActivityTestRule(MainActivity.class); @Test public void useAppContext() &#123; &#125;&#125; AndroidJUnitRunner - 用于build.gradle配置文件 123456android &#123; defaultConfig &#123; // ... testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" &#125;&#125; Instrumentation Test Runner - 可以支持 JUnit Test测试和Instrmentation Unit Tests测试。均只支持JUnit3 Android JUnit Test Runner - 支持JUnit4，对Instumentation Test Runner 的替代。 Local Unit Tests - 基于JVM的，只支持JUnit测试，其测试代码直接在电脑上的JVM中运行。测试类应该放在src/test/java目录下。只能测试纯java代码。 Robolectric 使用教程 ：https://blog.csdn.net/shensky711/article/details/53561172 Robolectric 给 Unit Tests 提供 android框架支持。 Mock 模仿android 依赖, https://www.jianshu.com/p/00ab03f3d394 Instrmentation Unit Tests - 测试类放在src/androidTest/java目录。可以在模拟器、真机上测试，支持和android 框架相关的代码部分测试。 参考文章： http://www.paincker.com/android-test-1 https://developer.android.com/training/testing/?hl=zh-cn 测试Demo Android JUnit Demo 创建。 优点是：直接在JVM上运行，速度快。 1234567891011// 创建Java 类，不涉及android框架相关。public class Cal &#123; public int add(int a, int b) &#123; return a + b; &#125; public int multiply(int a, int b) &#123; return a * b; &#125;&#125;// 自动创建测试样例：在这个类中，右键-&gt; Go to -&gt; Test -&gt; Create New Test -&gt; 选择 src/test/java 目录保存 // 手动创建测试样例：http://www.paincker.com/android-test-2 12345678910111213141516171819202122232425// 右键运行 Run CalTestpublic class CalTest &#123; private Cal mCal; @Before public void setUp() throws Exception &#123; mCal = new Cal(); &#125; @After public void tearDown() throws Exception &#123; mCal = null; &#125; @Test public void add() &#123; assertEquals(mCal.add(2, 3), 5); &#125; @Test public void multiply() &#123; assertEquals(mCal.multiply(2, 3), 6); &#125;&#125; Android Instrumented Tests Demo 创建 优点是：运行在模拟器或者真机上，贴合场景。 对于同一个Java类，可以生成两个测试用例一个Android JUnit， 一个Android Instrumented； 生成方式类似，用例保存地址不同。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android自动化测试]]></title>
    <url>%2Fblog%2F2019%2F07%2F24%2FAndroid%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[android 自动化测试工具介绍：Monkey 是Android SDK自带的测试工具，在测试过程中会向系统发送伪随机的用户事件流，如按键输入、触摸屏输入、手势输入等)，实现对正在开发的应用程序进行压力测试，也有日志输出。实际上该工具只能做程序做一些压力测试，由于测试事件和数据都是随机的，不能自定义，所以有很大的局限性。 参考链接：https://blog.csdn.net/hebbely/article/details/78901466 介绍了Monkey 及相关参数的用法。 MonkeyRunner 也是Android SDK提供的测试工具。严格意义上来说MonkeyRunner其实是一个Api工具包，比Monkey强大，可以编写测试脚本来自定义数据、事件。缺点是脚本用Python来写，对测试人员来说要求较高，有比较大的学习成本。 Instrumentation 是早期Google提供的Android自动化测试工具类，虽然在那时候JUnit也可以对Android进行测试，但是Instrumentation允许你对应用程序做更为复杂的测试，甚至是框架层面的。通过Instrumentation你可以模拟按键按下、抬起、屏幕点击、滚动等事件。Instrumentation是通过将主程序和测试程序运行在同一个进程来实现这些功能，你可以把Instrumentation看成一个类似Activity或者Service并且不带界面的组件，在程序运行期间监控你的主程序。缺点是对测试人员来说编写代码能力要求较高，需要对Android相关知识有一定了解，还需要配置AndroidManifest.xml文件，不能跨多个App。 UiAutomator 也是Android提供的自动化测试框架，基本上支持所有的Android事件操作，对比Instrumentation它不需要测试人员了解代码实现细节（可以用UiAutomatorviewer抓去App页面上的控件属性而不看源码）。基于Java，测试代码结构简单、编写容易、学习成本，一次编译，所有设备或模拟器都能运行测试，能跨App（比如：很多App有选择相册、打开相机拍照，这就是跨App测试）。缺点是只支持SDK 16（Android 4.1）及以上，不支持Hybird App、WebApp。 参考链接： https://blog.csdn.net/eclipsexys/article/details/45622813 Espresso 是Google的开源自动化测试框架。相对于Robotium和UIAutomator，它的特点是规模更小、更简洁，API更加精确，编写测试代码简单，容易快速上手。因为是基于Instrumentation的，所以不能跨App。 官方文档：https://developer.android.com/training/testing/espresso Selendroid 也是基于Instrumentation的测试框架，可以测试Native App、Hybird App、Web App，但是网上资料较少，社区活跃度也不大。 Robotium 也是基于Instrumentation的测试框架，目前国内外用的比较多，资料比较多，社区也比较活跃。缺点是对测试人员来说要有一定的Java基础，了解Android基本组件，不能跨App。 Athrun 是淘宝出的一个移动测试框架/平台，同时支持iOS和Android。Android部分也是基于Instrumentation，在Android原有的ActivityInstrumentationTestCase2类基础上进行了扩展，提供一整套面向对象的API。这里有详细介绍。 CSDN：https://blog.csdn.net/xiaobai20131118/article/details/43762527 官方文档没有找到，可能是已经关闭了。 Appium 是最近比较热门的框架，社区也很活跃。Appium是一个跨平台工具，它允许测试人员使用同样的接口、基于不同的平台写自动化测试代码，大大增加了测试套件间代码的复用性。android部分是基于UiAutomator和Selendroid。 官方文档：https://github.com/appium/appium/tree/master/docs/cn Macaca macaca 是阿里的提供的解决方案,android部分也是基于uiautomator，和AutomatorX很类似，集成了多个工具集。1.功能与AutomatorX基本相同，除了可以用wifi 2.网页的测试更好. 依赖过多，安装复杂。 官方文档：https://macacajs.github.io/zh/ AutomatorX AutomatorX是网易给出的一套解决方案，是集合了各个测试框架之后给的一个方案，所以目前看来功能点是最全的。支持夸平台。 官方文档：https://github.com/NetEaseGame/ATX]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 注解]]></title>
    <url>%2Fblog%2F2019%2F07%2F22%2FJava%20%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Java 注解 Java 注解定义： Java 注解又称标注，Java 5.0 开始支持，是一种特殊的语法元数据。 Java 语言中的包、类、方法、参数、变量都可以被标注。和Javadoc不同，标注可以通过反射或者标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java虚拟机可以保留标注内容，在运行时可以获取到标注内容。当然也支持自定义的标注。 Annotation Processing tool 即 apt tool，提供了一个补充性的编译时注解操作接口。 Java 内置的注解有： 作用在代码的注解： @override - 检查该方法是否是重载方法。如果发现其父类或者是引用的接口中并没有改方法时，会报编译错误。 @Deprecated - 标记过时方法。如果使用该方法，会报编译警告。 @SuppressWarnings - 指示编译器去忽略注解中声明的警告。 作用于其他注解的注解（或者说元注解）： @Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。 @Ducumented - 标记这个注解是否包含在用户文档中。 @Target - 标记这个注解应该是那种Java成员。 @Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类) 从Java 7 额外添加了3个注解： @SafeVarargs - Java 7 支持，忽略任何使用参数为泛型变量的方法或构造函数的调用产生的警告。 @FunctionalInterface - Java 8 开始支持，标识一个匿名函数或者函数式接口。 @Repeatable - Java 8 开始支持， 标识某注解可以在同一个声明是使用多次。 android 内置注解 @Nullable - 指示变量、参数、返回值可以为null。 @NonNull - 指示变量、参数、返回值不可以为null。 资源注解： @StringRes - 字符串标注，参数只接受R.string.tips， R.color.tips报错。虽然都是整形。 @DrawableRes - 以下都同上。 @DimenRes - @ColorRes - @InterpolatorRes - @LayoutRes - 线程注解：用于检测某个方法是否从指定类型的线程中调用。 @MainThread - @UIThread - @WorkerThread - @BinderThread - @AnyThread - 值约束注解： @IntRange - 验证传递参数的值的取值范围 @FloatRange - 同上 @Size - 验证传递参数的值（例如：数组等）的长度。 权限注解： @RequiresPermission - 验证方法调用方的权限。 返回值注解： @CheckResult - 验证调用方是否有对方法的返回值进行处理。 超类注解： @CallSuper - 验证子类重新父类的方法，是否有调用父类的实现，没有则报警告。 枚举注解： @Typedef - 可以确保特定的参数、返回值、字段引用特定的常量集。 代码可访问性注解： @Keep - 标注的类或者方法在混淆的时候不被混淆。 其他常见注解： @TargetApi - 用于屏蔽IDE对API版本的限制。即相当于告诉编译器标记的代码在指定的api上面运行。 @SuppressLint - 类似@TargetApi，屏蔽IDE对API版本的一切限制。 @Widget - 标记该类是自定义的Widget类。 测试可见注解： @VisibleForTesting - 标注是否对测试可见。 android 注解的特性： 1、依赖注入； 2、简化线程操作； 3、事件绑定； 4、No Magic，只是在编译的时候生成了子类，可以检查代码看是如何运行的。 5、体积小，无反射，没有运行时影响。不会影响性能。 运行时动态注解实现：参考 运行时注解一般和反射机制配合使用，相比编译时注解性能比较低，但灵活性好，实现起来比较简单。 创建注解，创建一个可以字符串相加的注解。 123456789101112package com.pa.test.test;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Retention(RetentionPolicy.RUNTIME)@Target(value = ElementType.FIELD)public @interface Append&#123; String str1() default "hello"; String str2() default "world";&#125; 用反射实现注解处理： 123456789101112131415161718192021222324252627package com.pa.test.test;import java.lang.reflect.Field;//importpublic class Inject &#123; public static void inject(final Object object)&#123; Field[] fields = object.getClass().getDeclaredFields(); for(Field field: fields)&#123; Append append = field.getAnnotation(Append.class); if(append != null)&#123; if(object instanceof MainActivity)&#123; String str = append.str1() + append.str2(); field.setAccessible(true); try &#123; field.set(object, str); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;&#125; 注解使用Demo 123456789101112131415161718@Append(str1 = "how", str2 = "are you")public String tips;@Appendpublic String names;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Inject.inject(this); // 控制台输出：howare you helloworld Log.i("TAG", tips + " "+ names);&#125; 编译时注解实现： 编译时注解通过注解处理器实现。注解处理器是（Annotation Processor）是javac的一个工具，用来在编译时扫描和编译和处理注解（Annotation）。 注解处理器以Java代码或者（编译过的字节码）作为输入，生成文件（通常是java文件）。这些生成的java文件不能修改，并且会同其手动编写的java代码一样会被javac编译。 创建注解 使用 Java Module - lib_annotations，用于在编译时，生成XXX_SUFFIX.java 文件，代码如下： 12345678910111213package com.pa.test.lib_annotations;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Retention(RetentionPolicy.RUNTIME)@Target(value = ElementType.FIELD)public @interface EAppend &#123; String str1() default "hello"; String str2() default "world";&#125; 创建注解解析器 使用 Java Module - lib_compiler, 依赖上面 Module，代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.pa.test.lib_compiler;import com.pa.test.lib_annotations.EAppend;import javax.lang.model.element.Element;import javax.lang.model.element.Name;import javax.lang.model.element.TypeElement;import javax.lang.model.type.TypeMirror;import javax.lang.model.util.Elements;// public class AnnotatedClass &#123; private final String value1; private final String value2; public Element mClassElement; /** * 元素相关的辅助类 */ public Elements mElementUtils; public TypeMirror elementType; public Name elementName; public AnnotatedClass(Element classElement) &#123; this.mClassElement = classElement; this.elementType = classElement.asType(); this.elementName = classElement.getSimpleName(); value1 = mClassElement.getAnnotation(EAppend.class).str1(); value2 = mClassElement.getAnnotation(EAppend.class).str2(); &#125; Name getElementName() &#123; return elementName; &#125; TypeMirror getElementType()&#123; return elementType; &#125; String getTotal()&#123; return "\""+ (value1 + value2) + "\""; &#125; /** * 包名 */ public String getPackageName(TypeElement type) &#123; return mElementUtils.getPackageOf(type).getQualifiedName().toString(); &#125; /** * 类名 */ private static String getClassName(TypeElement type, String packageName) &#123; int packageLen = packageName.length() + 1; return type.getQualifiedName().toString().substring(packageLen).replace('.', '$'); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152package com.pa.test.lib_compiler;import com.google.auto.service.AutoService;import com.pa.test.lib_annotations.EAppend;import com.squareup.javapoet.JavaFile;import com.squareup.javapoet.MethodSpec;import com.squareup.javapoet.TypeName;import com.squareup.javapoet.TypeSpec;import java.io.IOException;import java.util.ArrayList;import java.util.LinkedHashMap;import java.util.LinkedHashSet;import java.util.List;import java.util.Map;import java.util.Set;import javax.annotation.processing.AbstractProcessor;import javax.annotation.processing.Filer;import javax.annotation.processing.Messager;import javax.annotation.processing.ProcessingEnvironment;import javax.annotation.processing.Processor;import javax.annotation.processing.RoundEnvironment;import javax.lang.model.SourceVersion;import javax.lang.model.element.Element;import javax.lang.model.element.ElementKind;import javax.lang.model.element.Modifier;import javax.lang.model.element.TypeElement;import javax.lang.model.util.Elements;import javax.lang.model.util.Types;import javax.tools.Diagnostic;@AutoService(Processor.class)public class EAppendProcessor extends AbstractProcessor &#123; private static final String EAPPEND_SUFFIX = "_EAppend"; private static final String TARGET_STATEMENT_FORMAT = "target.%1$s = %2$s"; private static final String CONST_PARAM_TARGET_NAME = "target"; private static final char CHAR_DOT = '.'; private Messager messager; private Types typesUtil; private Elements elementsUtil; private Filer filer; /** * 解析的目标注解集合，一个类里可以包含多个注解，所以是Map&lt;String, List&lt;AnnotatedClass&gt;&gt; */ Map&lt;String, List&lt;AnnotatedClass&gt;&gt; annotatedElementMap = new LinkedHashMap&lt;&gt;(); @Override public synchronized void init(ProcessingEnvironment processingEnvironment) &#123; super.init(processingEnvironment); messager = processingEnv.getMessager(); typesUtil = processingEnv.getTypeUtils(); filer = processingEnv.getFiler(); elementsUtil = processingEnv.getElementUtils(); &#125; @Override public SourceVersion getSupportedSourceVersion() &#123; return SourceVersion.latestSupported(); &#125; @Override public Set&lt;String&gt; getSupportedAnnotationTypes() &#123; Set&lt;String&gt; annotataions = new LinkedHashSet&lt;String&gt;(); annotataions.add(EAppend.class.getCanonicalName()); return annotataions; &#125; @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123; // 因为该方法可能会执行多次，所以每次进来必须clear annotatedElementMap.clear(); //1.遍历每个有Add注解的Element， //2.然后把它加入Map里面,一个类里可以包含多个注解，所以是Map&lt;String, List&lt;AnnotatedClass&gt;&gt;， //3.赋予它工作任务，告诉他你该做什么， //4.然后生成Java文件 for (Element element : roundEnv.getElementsAnnotatedWith(EAppend.class)) &#123; //判断被注解的类型是否符合要求 if (element.getKind() != ElementKind.FIELD) &#123; messager.printMessage(Diagnostic.Kind.ERROR, "Only FIELD can be annotated with @%s"); &#125; TypeElement encloseElement = (TypeElement) element.getEnclosingElement(); String fullClassName = encloseElement.getQualifiedName().toString(); AnnotatedClass annotatedClass = new AnnotatedClass(element); //把类名和该类里面的所有关于Add注解的注解放到Map里面 if(annotatedElementMap.get(fullClassName) == null)&#123; annotatedElementMap.put(fullClassName, new ArrayList&lt;AnnotatedClass&gt;()); &#125; annotatedElementMap.get(fullClassName).add(annotatedClass); &#125; //因为该方法会执行多次，所以size=0时返回true结束 if (annotatedElementMap.size() == 0) &#123; return true; &#125; //用javapoet生成类文件 try &#123; for (Map.Entry&lt;String, List&lt;AnnotatedClass&gt;&gt; entry : annotatedElementMap.entrySet()) &#123; MethodSpec constructor = createConstructor(entry.getValue()); TypeSpec binder = createClass(getClassName(entry.getKey()), constructor); JavaFile javaFile = JavaFile.builder(getPackage(entry.getKey()), binder).build(); javaFile.writeTo(filer); &#125; &#125; catch (IOException e) &#123; messager.printMessage(Diagnostic.Kind.ERROR, "Error on creating java file"); &#125; return true; &#125; //以下是javapoet创建各种方法的实现方式 private MethodSpec createConstructor(List&lt;AnnotatedClass&gt; randomElements) &#123; AnnotatedClass firstElement = randomElements.get(0); MethodSpec.Builder builder = MethodSpec.constructorBuilder() .addModifiers(Modifier.PUBLIC) .addParameter(TypeName.get(firstElement.mClassElement.getEnclosingElement().asType()), CONST_PARAM_TARGET_NAME); for (int i = 0; i &lt; randomElements.size(); i++) &#123; addStatement(builder, randomElements.get(i)); &#125; return builder.build(); &#125; private void addStatement(MethodSpec.Builder builder, AnnotatedClass randomElement) &#123; builder.addStatement(String.format( TARGET_STATEMENT_FORMAT, randomElement.getElementName().toString(), randomElement.getTotal()) ); &#125; private TypeSpec createClass(String className, MethodSpec constructor) &#123; return TypeSpec.classBuilder(className + EAPPEND_SUFFIX) .addModifiers(Modifier.PUBLIC, Modifier.FINAL) .addMethod(constructor) .build(); &#125; private String getPackage(String qualifier) &#123; return qualifier.substring(0, qualifier.lastIndexOf(CHAR_DOT)); &#125; private String getClassName(String qualifier) &#123; return qualifier.substring(qualifier.lastIndexOf(CHAR_DOT) + 1); &#125;&#125; 123456789101112apply plugin: 'java-library'dependencies &#123; implementation fileTree(dir: 'libs', include: ['*.jar']) compile 'com.squareup:javapoet:1.9.0' compile 'com.google.auto.service:auto-service:1.0-rc4' implementation project(':lib_annotations')&#125;sourceCompatibility = "7"targetCompatibility = "7" AutoService 主要的作用是注解 processor 类，并对其生成 META-INF 的配置信息。 JavaPoet 这个库的主要作用就是帮助我们通过类调用的形式来生成代码。 参考：https://juejin.im/entry/58fefebf8d6d810058a610de 参考：https://juejin.im/post/584d4b5b0ce463005c5dc444 创建辅助模块 使用存Java Module - lib_api ，用于将类A.java 与 编译时生成的A_SUFFIX.java 关联，非必须的。也可以在 Demo中手动关联。 1234567891011121314151617181920212223242526272829303132package com.pa.test.lib_api;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;public class Utils &#123; private static final String EAppend_SUFFIX = "_EAppend"; private Utils() &#123; &#125; public static void inject(Object object) &#123; try &#123; Class bindingClass = Class.forName(object.getClass().getCanonicalName() + EAppend_SUFFIX); Constructor constructor = bindingClass.getConstructor(object.getClass()); constructor.newInstance(object); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 创建demo 123456789101112131415161718192021222324252627282930 @Append(str1 = "how", str2 = "are you")public String tips; @Appendpublic String names; @EAppend(str1 = "hi ", str2 = "annotations")public String ann; @EAppendpublic String ant; @Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Inject.inject(this); // howare you helloworld Log.i("TAG", tips + " "+ names); Utils.inject(this); // hi annotations helloworld Log.i("TAG", ann + " "+ ant); &#125; 1234567891011121314151617181920212223242526272829303132apply plugin: &apos;com.android.application&apos;android &#123; compileSdkVersion 29 defaultConfig &#123; applicationId &quot;com.pa.test.test&quot; minSdkVersion 26 targetSdkVersion 29 versionCode 1 versionName &quot;1.0&quot; testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot; &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125; &#125;&#125;dependencies &#123; implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) implementation &apos;com.android.support:appcompat-v7:28.+&apos; implementation &apos;com.android.support.constraint:constraint-layout:1.1.3&apos; testImplementation &apos;junit:junit:4.12&apos; androidTestImplementation &apos;com.android.support.test:runner:1.0.2&apos; androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.2&apos; api project(&apos;:lib_annotations&apos;) api project(&apos;:lib_api&apos;) annotationProcessor project(&apos;:lib_compiler&apos;)&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>java</tag>
        <tag>annotation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + github 搭建静态博客]]></title>
    <url>%2Fblog%2F2019%2F07%2F19%2FHexo%20%2B%20github%20%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Hexo + github 搭建静态博客 注册github，创建项目; 参考文章 安装git、curl、brew、node.js等 安装hexo 相关; 参考文章 12$ npm install -g hexo-cli$ npm install hexo-deployer-git --save 初始化hexo项目 1hexo init 进入hexo 项目的根目录，获取next 主题 1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 修改hexo 项目更目录下面的_config.yml文件 123456789101112title: noteauthor: lpllanguage: zh-Hansurl: https://zubao.github.io/blogroot: /blog/deploy: type: git repo: git@github.com:zubao/blog.git branch: master message: message hexo 命令介绍; hexo 文档 hexo g 生成静态文件 hexo d 发布到github hexo s 启动本地静态服务器 ls -i tcp:4000 查找端口为4000的进程 kill -9 PID 杀掉进程 hexo clean 清除缓存 next 主题文档介绍: 官方文档]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AOSP 编译文档]]></title>
    <url>%2Fblog%2F2019%2F07%2F19%2FAOSP%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[准备工作： Mac Pro 10.14版本，16G内存，256G SSD； 外接移动硬盘1T，使用自带的磁盘工具分区；A区不分大小写，用于时间机器备份电脑；B区(Mac OS扩展，区分大小写)用于AOSP项目。 参考官网配置环境 去清华镜像下载AOSP初始包；使用curl -C - -O 命令，迅雷需要会员不然下载不了。文件47.8GB，需要使用支持断点续传的工具下载。 官网下载文档 下载md5文件 验证aosp-latest.tar文件的md5值，判断是否下载完整。 1brew install md5sha1sum 验证md5 1md5sum aosp-latest.tar 将初始包下载到移动硬盘分区中，并解压： 1tar xf aosp-latest.tar 运行命令同步项目： 1repo sync 如果命令repo没有，参考清华文档 下载配置。 查看远程分支，切换分支： 查看可切换的分支 ，切换分支，并同步代码： 123456cd .repo/manifests git branch -a 切换到9.0分支repo init -b android-9.0.0_r34同步代码repo sync （可选）切换命令行运行的shell版本 123ps -p $$ // 查看当前运行的shell版本chsh -s /bin/bash // 切换到b shellchsh -s /bin/zsh // 切换到 z shell 初始化环境, 必须在bash环境运行。 12cd aospsource build/envsetup.sh (可选)查看cpu内核数，用于编译时选择线程数。我的是4核 1sysctl -n machdep.cpu.core_count 通过lunch 命令选择要编译的源码架构, 需要输入对应的序号。ps：lunch可能会花几分钟。 编译源码，x=cpu核心数*2+2。如果没有lunch，默认编译第一个。 1make -jx 清理编译产生的文件 1make clobber AOSP目录详解 解释每个目录、子目录的用途，编译宏观上理解android。 刷机文档 错误a 1internal error: could not open symlink hardware/qcom/sdm710/Android.bp 方法1：删除sdm710目录；(采用，验证可以通过这个错误) 方法2：重新解压，重新同步不同的分支。 网上说法是，遗漏了某些文件，或者是上一个分支的问题没有移除；参考 错误b 1internal error: Could not find a supported mac sdk: [&quot;10.10&quot; &quot;10.11&quot; &quot;10.12&quot; &quot;10.13&quot;] 解决方法：参考 123456789vim build/soong/cc/config/x86_darwin_host.godarwinSupportedSdkVersions = []string&#123; &quot;10.10&quot;, &quot;10.11&quot;, &quot;10.12&quot;, &quot;10.13&quot;, &quot;10.14&quot;,&#125;因为我的系统版本，xcode版本是10.14，这里也添加 10.14 添加10.14后，可能报错误 ，解决方法是下载MacOSX10.13.SDK 放到 目录： 1/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs 这里要注意的是10.13SDK网上有些版本是有bug的，部分文件的符号引用在文件夹移动之后失效。上面下载地址中github上修正了这个bug。 编译成功提示 1#### build completed successfully (05:58:17 (hh:mm:ss)) #### 运行emulator 运行模拟器。 1emulator -partition-size 3000 运行模拟器报错 1emulator: command not found 原因是 直接使用make编译的项目。 解决方法： 使用lunch 选择 aosp_x86_64-eng 重新编译，就可以正常启动模拟器。参见 使用IntelliJ 阅读源码 1、使用命令，生成android.ipr, android.iml文件 12&gt; make idegen &amp;&amp; development/tools/idegen/idegen.sh&gt; 2、修改IntelliJ 配置，扩大虚拟机使用内存，文件大小写敏感。方法：打开IntelliJ包内容，bin目录下找到 idea.vmoptions 和 idea.properties 这两个文件。具体参考：https://www.jianshu.com/p/1d1b8d0de1ed]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>AOSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机阅读]]></title>
    <url>%2Fblog%2F2019%2F07%2F15%2FJava%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[Java 虚拟机阅读 KVM (Kilobyte VM) KVM 中的 K 是“Kilobyte”的意思，它强调简单，轻量，高度可移植，但是运行速度比较慢。在 Androd、iOS 等智能手机操作系统出现前曾经在手机平台上得到非常广泛应用。 优点：包含JVM最核心的组件；实现方式与JVM规范描述的抽象的JVM相近 缺点：是Java ME CLDC VM，而不是Java SE VM；未实现反射、浮点计算等功能。 注意：KVM(kernel-base VM) 是一款基于linux内核的虚拟机 QEMU+KVM KVM 介绍 宋宝华KVM介绍 Java 虚拟机家族考 Squawk VM Squawk VM 是由 Sun 开发，运行于 Sun SPOT（Sun Small Programmable Object Technology，一种手持的 Wifi 设备），也曾经运用于 Java Card。这是一个 Java 代码比重很高的嵌入式虚拟机实现，其中诸如类加载器、字节码验证器、垃圾收集器、解释器、编译器和线程调度都是 Java 语言本身所完成的，仅仅靠 C 语言来编写设备 I/O 和必要的本地代码。 JavaInJava JavaInJava 是 Sun 公司 1997 年～1998 年间所研发的一个实验室性质的虚拟机，从名字就可以看出，它试图以 Java 语言来实现 Java 语言本身的运行环境，既所谓的“元循环”（Meta-Circular，是指使用语言自身来实现其运行环境）。它必须运行在另外一个宿主虚拟机之上，内部没有 JIT 编译器，代码只能以解释模式执行。在上世纪末主流 Java 虚拟机都未能很好解决性能问题的时代，开发这种项目，其执行速度大家可想而知。 Maxine VM Maxine VM 和上面的 JavaInJava 非常相似，它也是一个几乎全部以 Java 代码实现（只有用于启动 JVM 的加载器使用 C 语言编写）的元循环 Java 虚拟机。这个项目于 2005 年开始，到现在仍然在发展之中，比起 JavaInJava，Maxine VM 就显得“靠谱”很多，它有先进的 JIT 编译器和垃圾收集器（但没有解释器），可在宿主模式或独立模式下执行，其执行效率已经接近了 HotSpot Client VM 的水平 JRockit VM 曾经号称“世界上速度最快的 Java 虚拟机”（广告词，貌似 J9 VM 也这样说过），它是 BEA 公司在 2002 年从 Appeal Virtual Machines 公司收购获得的虚拟机。BEA 将其发展为一款专门为服务器硬件和服务端应用场景高度优化的虚拟机，由于专注于服务端应用，它可以不太关注于程序启动速度，因此 JRockit 内部不包含解析器实现，全部代码都靠即时编译器编译后执行。除此之外，JRockit 的垃圾收集器和 MissionControl 服务套件等部分的实现，在众多 Java 虚拟机中也一直处于领先水平。 IBM J9 VM 并不是 IBM 公司唯一的 Java 虚拟机，不过是目前 IBM 主力发展的 Java 虚拟机，J9 原本是内部开发代号，正式名称是“IBM Technology for Java Virtual Machine”，简称 IT4J，只是这个名字太拗口了一点，普及程度不如 J9。J9 VM 最初是由 IBM Ottawa 实验室一个 SmallTalk 的虚拟机扩展而来的，当时这个虚拟机有一个 bug 是因为 8k 值定义错误引起，工程师们花了很长时间终于发现并解决了这个错误，此后这个版本的虚拟机就被称为 K8 了，后来扩展出支持 Java 的虚拟机就被称为 J9 了。与 BEA JRockit 专注于服务端应用不同，IBM J9 的市场定位与 Sun HotSpot 比较接近，它是一款设计上从服务端到桌面应用再到嵌入式都全面考虑的多用途虚拟机，J9 的开发目的是作为 IBM 公司各种 Java 产品的执行平台，它的主要市场在和 IBM 产品（如 IBM WebSphere 等）搭配以及在 IBM AIX 和 z/OS 这些平台上部署 Java 应用。 Apache Harmony 是一个 Apache 软件基金会旗下以 Apache License 协议开源的实际兼容于 JDK 1.5 和 JDK 1.6 的 Java 程序运行平台，这个介绍相当拗口。它包含自己的虚拟机和 Java 库，用户可以在上面运行 Eclipse、Tomcat、Maven 等常见的 Java 程序，但是……它没有通过 TCK 认证，所以我们不得不用那么一长串拗口的语言来介绍它，而不能用一句“Apache 的 JDK”来说明。如果一个公司要宣布自己的运行平台“兼容于 Java 语言”，那就必须要通过 TCK（Technology Compatibility Kit）的兼容性测试，Apache 基金会曾要求 Sun 公司提供 TCK 的使用授权，但是一直遭到拒绝，直到 Oracle 收购了 Sun 公司之后，双方关系越闹越僵，最终导致 Apache 愤然退出 JCP（Java Community Process）组织，这是近代 Java 社区最严重的一次分裂。 Dalvik VM 是 Android 平台的核心组成部分之一，它名字来源于冰岛一个名为 Dalvik 的小渔村。Dalvik VM 并不是一个 Java 虚拟机，它没有遵循 Java 虚拟机规范，不能直接执行 Java 的 class 文件，使用寄存器架构而不是 JVM 中常见的栈架构。但是它与 Java 却又有着千丝万缕的联系，它执行 dex（Dalvik Executable）文件可以通过 class 文件转化而来，使用 Java 语法编写应用程序，可以直接使用大部分的 Java API 等等。目前 Dalvik VM 随着 Android 一起处于迅猛发展阶段，在 Android 2.2 中已提供即时编译器实现，执行性能有了很大的提高。 参考文章 https://hllvm-group.iteye.com/group/topic/26998 https://www.zhihu.com/people/wang-xian-sheng-78-39/posts?page=1 https://blog.csdn.net/weixin_37477523/category_8698256.html https://hunterzhao.io/tags/hotspot/ https://cloud.tencent.com/developer/information/JVMTI https://zhuanlan.zhihu.com/p/137836206]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java JNI 调用 C 实现]]></title>
    <url>%2Fblog%2F2019%2F07%2F15%2FJava%20JNI%20%E8%B0%83%E7%94%A8%20C%20%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[Java JNI 调用 C 实现 创建目录hook 创建Test.java文件 12345678910111213141516171819 package hook; 2 public class Test&#123; 3 static&#123; 4 System.loadLibrary("test"); 5 &#125; 6 7 public native int nativeAdd(int x, int y); 8 9 public int add(int x, int y)&#123;10 return x + y;11 &#125;1213 public static void main(String[] args)&#123;14 Test test = new Test();15 System.out.println(System.getProperty("java.library.path"));16 System.out.println(test.add(3, 5));17 System.out.println(test.nativeAdd(3, 5));18 &#125;19 &#125; 编译java文件. 1javac hook/Test.java 创建 jni 头文件 1234567891011121314151617181920212223javah -jni hook.Test 1 /* DO NOT EDIT THIS FILE - it is machine generated */ 2 #include &lt;jni.h&gt; 3 /* Header for class hook_Test */ 4 5 #ifndef _Included_hook_Test 6 #define _Included_hook_Test 7 #ifdef __cplusplus 8 extern "C" &#123; 9 #endif 10 /* 11 * Class: hook_Test 12 * Method: nativeAdd 13 * Signature: (II)I 14 */ 15 JNIEXPORT jint JNICALL Java_hook_Test_nativeAdd 16 (JNIEnv *, jobject, jint, jint); 17 18 #ifdef __cplusplus 19 &#125; 20 #endif 21 #endif 编写Test.c 文件，和hook 同一级目录。 1234561 #include "hook_Test.h"23 JNIEXPORT jint JNICALL Java_hook_Test_nativeAdd4 (JNIEnv * env, jobject obj, jint x, jint y)&#123;5 return x + y ;6 &#125; 生成动态链接库，命令如下 1gcc -dynamiclib -o libtest.jnilib Test.c -framework JavaVM -I $JAVA_HOME/include -I $JAVA_HOME/include/darwin 说明： -o：指定动态链接库编译后生成的路径及文件名 -dynamiclib：表示编译成动态链接库 -framework JavaVM -I：编译JNI需要用到JVM的头文件(jni.h)，第一个目录是平台无关的，第二个目录是与操作系统平台相关的头文件 mac 上和linux上命令有少许差异，linux 上是生成so文件，mac上是生成jnilib文件 参考文件linux,[参考文件多平台]([http://blog.0613.me/2017/05/14/20170514%20-%20Java-%E9%80%9A%E8%BF%87-JNI-%E8%B0%83%E7%94%A8-so-jnilib-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/](http://blog.0613.me/2017/05/14/20170514 - Java-通过-JNI-调用-so-jnilib-动态链接库/)) 执行验证结果 1java -Djava.library.path=. hook.Test 需要加上 -Djava.library.path=. 指明从当前目录加载动态链接库文件，否则会出现找不到库文件的异常。 查看class 文件命令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134javap -verbose hook.TestClassfile /Users/lipeilong/note/java/vm/hook/Test.class Last modified 2019-7-15; size 747 bytes MD5 checksum 223fad605354553a14ee9dd1adaae086 Compiled from "Test.java"public class hook.Test minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #13.#26 // java/lang/Object."&lt;init&gt;":()V #2 = Class #27 // hook/Test #3 = Methodref #2.#26 // hook/Test."&lt;init&gt;":()V #4 = Fieldref #28.#29 // java/lang/System.out:Ljava/io/PrintStream; #5 = String #30 // java.library.path #6 = Methodref #28.#31 // java/lang/System.getProperty:(Ljava/lang/String;)Ljava/lang/String; #7 = Methodref #32.#33 // java/io/PrintStream.println:(Ljava/lang/String;)V #8 = Methodref #2.#34 // hook/Test.add:(II)I #9 = Methodref #32.#35 // java/io/PrintStream.println:(I)V #10 = Methodref #2.#36 // hook/Test.nativeAdd:(II)I #11 = String #37 // test #12 = Methodref #28.#38 // java/lang/System.loadLibrary:(Ljava/lang/String;)V #13 = Class #39 // java/lang/Object #14 = Utf8 &lt;init&gt; #15 = Utf8 ()V #16 = Utf8 Code #17 = Utf8 LineNumberTable #18 = Utf8 nativeAdd #19 = Utf8 (II)I #20 = Utf8 add #21 = Utf8 main #22 = Utf8 ([Ljava/lang/String;)V #23 = Utf8 &lt;clinit&gt; #24 = Utf8 SourceFile #25 = Utf8 Test.java #26 = NameAndType #14:#15 // "&lt;init&gt;":()V #27 = Utf8 hook/Test #28 = Class #40 // java/lang/System #29 = NameAndType #41:#42 // out:Ljava/io/PrintStream; #30 = Utf8 java.library.path #31 = NameAndType #43:#44 // getProperty:(Ljava/lang/String;)Ljava/lang/String; #32 = Class #45 // java/io/PrintStream #33 = NameAndType #46:#47 // println:(Ljava/lang/String;)V #34 = NameAndType #20:#19 // add:(II)I #35 = NameAndType #46:#48 // println:(I)V #36 = NameAndType #18:#19 // nativeAdd:(II)I #37 = Utf8 test #38 = NameAndType #49:#47 // loadLibrary:(Ljava/lang/String;)V #39 = Utf8 java/lang/Object #40 = Utf8 java/lang/System #41 = Utf8 out #42 = Utf8 Ljava/io/PrintStream; #43 = Utf8 getProperty #44 = Utf8 (Ljava/lang/String;)Ljava/lang/String; #45 = Utf8 java/io/PrintStream #46 = Utf8 println #47 = Utf8 (Ljava/lang/String;)V #48 = Utf8 (I)V #49 = Utf8 loadLibrary&#123; public hook.Test(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return LineNumberTable: line 2: 0 public native int nativeAdd(int, int); descriptor: (II)I flags: ACC_PUBLIC, ACC_NATIVE public int add(int, int); descriptor: (II)I flags: ACC_PUBLIC Code: stack=2, locals=3, args_size=3 0: iload_1 1: iload_2 2: iadd 3: ireturn LineNumberTable: line 10: 0 public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=4, locals=2, args_size=1 0: new #2 // class hook/Test 3: dup 4: invokespecial #3 // Method "&lt;init&gt;":()V 7: astore_1 8: getstatic #4 // Field java/lang/System.out:Ljava/io/PrintStream; 11: ldc #5 // String java.library.path 13: invokestatic #6 // Method java/lang/System.getProperty:(Ljava/lang/String;)Ljava/lang/String; 16: invokevirtual #7 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 19: getstatic #4 // Field java/lang/System.out:Ljava/io/PrintStream; 22: aload_1 23: iconst_3 24: iconst_5 25: invokevirtual #8 // Method add:(II)I 28: invokevirtual #9 // Method java/io/PrintStream.println:(I)V 31: getstatic #4 // Field java/lang/System.out:Ljava/io/PrintStream; 34: aload_1 35: iconst_3 36: iconst_5 37: invokevirtual #10 // Method nativeAdd:(II)I 40: invokevirtual #9 // Method java/io/PrintStream.println:(I)V 43: return LineNumberTable: line 14: 0 line 15: 8 line 16: 19 line 17: 31 line 18: 43 static &#123;&#125;; descriptor: ()V flags: ACC_STATIC Code: stack=1, locals=0, args_size=0 0: ldc #11 // String test 2: invokestatic #12 // Method java/lang/System.loadLibrary:(Ljava/lang/String;)V 5: return LineNumberTable: line 4: 0 line 5: 5&#125;SourceFile: "Test.java"]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jni</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取设备名称]]></title>
    <url>%2Fblog%2F2019%2F06%2F28%2Fandroid%E8%AE%BE%E5%A4%87%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[获取设备名称 1234BluetoothAdapter.getDefaultAdapter().getName()静态权限：android.permission.BLUETOOTH PS：小米手机配对后可以获取真实值、努比亚需要开蓝牙才可以获取真实值。Pixel 2XL可以。 android 6.0开始。WifiInfo.getMacAddress() 方法和 BluetoothAdapter.getAddress() 方法现在会返回常量值 02:00:00:00:00:00。 android 6.0 引入运行时权限 6.0 引入低功耗模式：当用户设备未插接电源、处于静止状态且屏幕关闭时，该模式会推迟 CPU 和网络活动，从而延长电池寿命。定时短期恢复正常工作。7.0对低功耗模式进行优化，不处于静止状态也可以进入低功耗模式(例如：放在口袋)。低功耗模式第一步：关闭网络、停止同步、作业；静止一段时间进入第二步：关闭gps、闹钟，wifi扫描等。 6.0引入待机模式：一段时间不触摸手机，进入待机模式。 6.0 移除了 对 apache http支持，请使用HttpUrlConnection 6.0USB传输数据，必须显示启用 7.0 targetSDK为7.0的后台服务器不在收到网络变化的广播。所有7.0系统的手机上后台新建图片和视频的广播 7.0 tragetSDK为7.0+，开发者不能放宽私有文件访问权限，分享私有文件的方法为FileProvider 7.0 设备所有者，可以通过使用DevicePolicyManager.getWifiMacAddress访问mac地址，如果wifi没有启用过返回null 8.0 进一步限制清单注册的隐式广播 8.0 降低后台应用接收位置信息的频率 8.0 以前用户请求一权限组中的某一权限是，系统自动授予了权限组的其他权限。8.0后系统修复了这一bug，改为，请求那一具体权限，授予这一具体权限，但是下次请求这一具体权限所在权限组的其他权限是，系统默认授予，而不是提示用户。 在 Android 8.0 之前，如果应用在运行时请求权限并且被授予该权限，系统会错误地将属于同一权限组并且在清单中注册的其他权限也一起授予应用。 对于针对 Android 8.0 的应用，此行为已被纠正。系统只会授予应用明确请求的权限。然而，一旦用户为应用授予某个权限，则所有后续对该权限组中权限的请求都将被自动批准。 例如，假设某个应用在其清单中列出 READ_EXTERNAL_STORAGE 和 WRITE_EXTERNAL_STORAGE。应用请求 READ_EXTERNAL_STORAGE，并且用户授予了该权限。如果该应用针对的是 API 级别 24 或更低级别，系统还会同时授予 WRITE_EXTERNAL_STORAGE，因为该权限也属于同一 STORAGE 权限组并且也在清单中注册过。如果该应用针对的是 Android 8.0，则系统此时仅会授予 READ_EXTERNAL_STORAGE；不过，如果该应用后来又请求 WRITE_EXTERNAL_STORAGE，则系统会立即授予该权限，而不会提示用户。 android 8.0 后 androidID，不同app、相同证书获取的ID相同；不同app、不同证书获取到的ID不同；相同APP，不同证书、卸载重装之后或者重启手机之后获取到的ID不同。 android 8.0 以后获取设备账号接口不可直接使用；需要用户授予权限GET_ACCOUNTS，然后： 123Intent googlePicker = AccountManager.newChooseAccountIntent(null, null, new String[] &#123; "com.google"&#125;, true, null, null, null, null);startActivityForResult(googlePicker, PICK_ACCOUNT_REQUEST); 8.0 Build.SERIAL 已弃用。需要知道硬件序列号的应用应改为使用新的 Build.getSerial() 函数，该函数要求具有 READ_PHONE_STATE 权限。 9.0 电源管理： Android 9 引入了一项新的电池管理功能，即应用待机群组。 应用待机群组可以基于应用最近使用时间和使用频率，帮助系统排定应用请求资源的优先级。 根据使用模式，每个应用都会归类到五个优先级群组之一中。 系统将根据应用所属的群组限制每个应用可以访问的设备资源。 五个群组按照以下特性将应用分组： 活跃 如果用户当前正在使用应用，应用将被归到“活跃”群组中，例如：应用已启动一个 Activity应用正在运行前台服务应用的同步适配器与某个前台应用使用的 content provider 关联用户在应用中点击了某个通知如果应用处于“活跃”群组，系统不会对应用的作业、报警或 FCM 消息施加任何限制。 工作集 如果应用经常运行，但当前未处于活跃状态，它将被归到“工作集”群组中。 例如，用户在大部分时间都启动的某个社交媒体应用可能就属于“工作集”群组。 如果应用被间接使用，它们也会被升级到“工作集”群组中 。如果应用处于“工作集”群组，系统会对它运行作业和触发报警的能力施加轻度限制。 如需了解详细信息，请参阅电源管理限制。 常用 如果应用会定期使用，但不是每天都必须使用，它将被归到“常用”群组中。 例如，用户在健身房运行的某个锻炼跟踪应用可能就属于“常用”群组。如果应用处于“常用”群组，系统将对它运行作业和触发报警的能力施加较强的限制，也会对高优先级 FCM 消息的数量设定限制。 如需了解详细信息，请参阅电源管理限制。 极少使用 如果应用不经常使用，那么它属于“极少使用”群组。 例如，用户仅在入住酒店期间运行的酒店应用就可能属于“极少使用”群组。 如果应用处于“极少使用”群组，系统将对它运行作业、触发警报和接收高优先级 FCM 消息的能力施加严格限制。系统还会限制应用连接到网络的能力。 如需了解详细信息，请参阅电源管理限制。 从未使用 安装但是从未运行过的应用会被归到“从未使用”群组中。 系统会对这些应用施加极强的限制。 系统会动态地将每个应用归类到某个优先级群组，并根据需要重新归类。 系统可能会依靠某个使用机器学习的预加载应用确定每个应用的使用可能性，并将应用归类到合适的群组。 如果设备上不存在系统应用，系统默认将基于应用的最近使用时间对它们进行排序。 更为活跃的应用将被归类到为应用提供更高优先级的群组，从而让应用可以使用更多系统资源。 具体而言，群组决定应用运行作业的频率，应用可以触发报警的频率，以及应用可以接收高优先级 Firebase 云信息传递 (FCM) 消息的频率。 这些限制仅在设备使用电池电量时适用，如果设备正在充电，系统不会对应用施加这些限制。 每个制造商都可以设定自己的标准来归类非活跃应用。 您不应当尝试影响应用所属的群组。 相反，您应当将精力放在确保应用在所属的群组内良好运行上。 您的应用可以通过调用新函数 UsageStatsManager.getAppStandbyBucket() 查找当前属于哪个群组。 注：位于 低电耗模式白名单中的应用不适用基于应用待机群组的限制。 9.0 省电模式： Android 9 对省电模式进行了多处改进。 设备制造商可以决定施加的确切限制。 例如，在 AOSP 构建中，系统会应用以下限制： 系统会更积极地将应用置于应用待机模式，而不是等待应用空闲。 后台执行限制适用于所有应用，无论它们的目标 API 级别如何。 当屏幕关闭时，位置服务可能会被停用。 后台应用没有网络访问权限。 9.0 限制后台对传感器的访问 Android 9 限制后台应用访问用户输入和传感器数据的能力。 如果您的应用在运行 Android 9 设备的后台运行，系统将对您的应用采取以下限制： 您的应用不能访问麦克风或摄像头。 使用连续报告模式的传感器（例如加速度计和陀螺仪）不会接收事件。 使用变化或一次性报告模式的传感器不会接收事件。 如果您的应用需要在运行 Android 9 的设备上检测传感器事件，请使用前台服务。 9.0 限制 访问通话记录 Android 9 引入 CALL_LOG 权限组并将 READ_CALL_LOG、WRITE_CALL_LOG 和 PROCESS_OUTGOING_CALLS 权限移入该组。 在之前的 Android 版本中，这些权限位于 PHONE 权限组。 对于需要访问通话敏感信息（如读取通话记录和识别电话号码）的应用，该 CALL_LOG 权限组为用户提供了更好的控制和可见性。 如果您的应用需要访问通话记录或者需要处理去电，则您必须向 CALL_LOG 权限组明确请求这些权限。 否则会发生 SecurityException。 9.0 限制访问电话号码 在未首先获得 READ_CALL_LOG 权限的情况下，除了应用的用例需要的其他权限之外，运行于 Android 9 上的应用无法读取电话号码或手机状态。 与来电和去电关联的电话号码可在手机状态广播（比如来电和去电的手机状态广播）中看到，并可通过 PhoneStateListener 类访问。 但是，如果没有 READ_CALL_LOG 权限，则 PHONE_STATE_CHANGED 广播和 PhoneStateListener 提供的电话号码字段为空。 要从手机状态中读取电话号码，请根据您的用例更新应用以请求必要的权限： 要通过 PHONE_STATE Intent 操作读取电话号码，同时需要 READ_CALL_LOG 权限和 READ_PHONE_STATE 权限。 要从 onCallStateChanged() 中读取电话号码，只需要 READ_CALL_LOG 权限。 不需要 READ_PHONE_STATE 权限。 9.0 限制访问wifi位置和连接信息。简单说，9.0以前扫描wifi只需要2个权限，并且前台扫描无限制，后台扫描每个APP30分钟可以扫描一次；9.0以后，除了权限还需要开启位置服务，前台2分钟扫描4次，后台所有app30分钟扫描一次。 在 Android 9 中，应用进行 Wi-Fi 扫描的权限要求比之前的版本更严格。 详情请参阅 Wi-Fi 扫描限制。 类似的限制也适用于 getConnectionInfo() 函数，该函数返回描述当前 Wi-Fi 连接的 WifiInfo 对象。 如果调用应用具有以下权限，则只能使用该对象的函数来检索 SSID 和 BSSID 值： ACCESS_FINE_LOCATION 或 ACCESS_COARSE_LOCATION ACCESS_WIFI_STATE 检索 SSID 或 BSSID 还需要在设备上启用位置服务（在 Settings &gt; Location 下）。 9.0 wifi服务中移出了部分信息 在 Android 9 中，下列事件和广播不接收用户位置或个人可识别数据方面的信息： WifiManager 中的 getScanResults() 和 getConnectionInfo() 函数。 WifiP2pManager 中的 [discoverServices()](https://developer.android.com/reference/android/net/wifi/p2p/WifiP2pManager.html?hl=zh-cn#discoverServices(android.net.wifi.p2p.WifiP2pManager.Channel, android.net.wifi.p2p.WifiP2pManager.ActionListener)) 和 [addServiceRequest()](https://developer.android.com/reference/android/net/wifi/p2p/WifiP2pManager.html?hl=zh-cn#addServiceRequest(android.net.wifi.p2p.WifiP2pManager.Channel, android.net.wifi.p2p.nsd.WifiP2pServiceRequest, android.net.wifi.p2p.WifiP2pManager.ActionListener)) 函数。 NETWORK_STATE_CHANGED_ACTION 广播。 Wi-Fi 的 NETWORK_STATE_CHANGED_ACTION系统广播不再包含 SSID（之前为 EXTRA_SSID）、BSSID（之前为 EXTRA_BSSID）或连接信息（之前为 EXTRA_NETWORK_INFO）。 如果应用需要此信息，请改为调用getConnectionInfo()。 9.0 电话信息现在依赖设备位置设置 getAllCellInfo() [listen()](https://developer.android.com/reference/android/telephony/TelephonyManager.html?hl=zh-cn#listen(android.telephony.PhoneStateListener, int)) getCellLocation() getNeighboringCellInfo() 9.0 加密程序变更 https://www.jianshu.com/p/2b22daa8e2f6 Q 目标api 23以下的app会受到警告 在 Android Q 中，当用户首次运行以 Android 6.0（API 级别 23）以下的版本为目标平台的任何应用时，Android 平台会向用户发出警告。如果此应用要求用户授予权限，则系统会先向用户提供调整应用权限的机会，然后才会允许此应用首次运行。 Q 撤消了 /proc/net 访问权限 Q 开始，应用必须具有 READ_PRIVILEGED_PHONE_STATE 特许权限才能访问设备的不可重置标识符（包含 IMEI 和序列号）。 如果应用以 Android Q 为目标平台，则会发生 SecurityException。 如果应用以 Android 9（API 级别 28）或更低版本为目标平台，则相应方法会返回 null 或占位符数据（如果应用具有 READ_PHONE_STATE 权限）。否则，会发生 SecurityException。 Q 后台APP不可访问剪切板 Q 无法启用、停用 WIFI；如果必须，使用设置面板 Q telephony API、WLAN API 和 Bluetooth API 需要精确位置权限 Q 开始，如果targetSDK 为 29+，不可以读写SDCard，如果targetSDK 为 29以下，可以继续读写。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
</search>
